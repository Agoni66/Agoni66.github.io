<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小黄鸭的窝窝✨</title>
  
  
  <link href="https://agoni66.github.io/atom.xml" rel="self"/>
  
  <link href="https://agoni66.github.io/"/>
  <updated>2024-09-12T15:08:23.589Z</updated>
  <id>https://agoni66.github.io/</id>
  
  <author>
    <name>小黄鸭的窝窝✨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://agoni66.github.io/posts/0.html"/>
    <id>https://agoni66.github.io/posts/0.html</id>
    <published>2024-09-12T15:06:42.239Z</published>
    <updated>2024-09-12T15:08:23.589Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 闪闪发光的人生<br>date: 2024-09-12 16:00:00<br>tags:</p><ul><li>日文</li><li>文学</li><li>烂尾<br>categories:</li><li>读书笔记<br>abbrlink: 1000006<br>cover: <a href="https://images.pexels.com/photos/28220698/pexels-photo-28220698.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600&amp;lazy=load">https://images.pexels.com/photos/28220698/pexels-photo-28220698.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=600&amp;lazy=load</a><br>comments: false<br>description: 闪闪发光 山茶花 理想的爱</li></ul><h3 id="艾草团子🍡">艾草团子🍡</h3><ul><li>这种喜悦，就好像气泡酒中的泡泡一样，从我的胸腔中一涌而上，化作泪水溢出</li><li>气泡果汁里真的装了许多时令水果，就像只豪华的宝石盒子</li><li>她那么柔软、那么温暖，又散发着淡淡的甘甜气味，就好像刚出锅的寿甘团子</li><li>在土锅里煮上红豆，又在旁边的小炉子里用滚水焯艾草叶。眼见着滚水染上深深的绿色，仿佛把春天都凝聚在一锅之中。舒爽的香味弥漫开来，就好像置身于森林中</li><li>艾草团子厚墩墩的，呈现出复杂的风味——强劲且带着大地气息</li></ul><h3 id="意式冰淇淋🍦">意式冰淇淋🍦</h3><ul><li>生命也是一样，一旦死去，就再也无法恢复原状</li><li>也许走上不同的人生路才是最好的</li><li>只要闭上眼睛，在心中默念“闪闪发光，闪闪发光”，心灵的晦暗之处就会出现星星，照亮四周</li></ul><h3 id="珠芽饭🌱">珠芽饭🌱</h3><ul><li>寄居蟹小姐心中所萌生的好感，就如同植物从大地中抽出枝芽一样，毫不虚伪。自然不会说谎，也不会欺骗自己，会坦率地生，坦率地死</li><li>我们两个都是背着重壳行走的人，我们的天空也不总是那么晴朗，而我已经被你的温柔拯救了不知多少次</li><li>与其去追求已经失去的东西，不如好好珍惜现在掌心中拥有的东西</li></ul><h3 id="蜂斗菜味噌">蜂斗菜味噌</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;title: 闪闪发光的人生&lt;br&gt;
date: 2024-09-12 16:00:00&lt;br&gt;
tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日文&lt;/li&gt;
&lt;li&gt;文学&lt;/li&gt;
&lt;li&gt;烂尾&lt;br&gt;
categories:&lt;/li&gt;
&lt;li&gt;读书笔记&lt;br&gt;
abb</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库系统概念（汇总版）</title>
    <link href="https://agoni66.github.io/posts/1000110.html"/>
    <id>https://agoni66.github.io/posts/1000110.html</id>
    <published>2024-08-10T13:30:00.000Z</published>
    <updated>2024-08-06T09:23:57.849Z</updated>
    
    <content type="html"><![CDATA[<h1>DATABASE SYSTEM CONCEPTS</h1><p><a href="https://agoni66.github.io/posts/1000111.html">Chapter1 Introduction</a></p><p><a href="https://agoni66.github.io/posts/1000112.html">Chapter2 Introduction to Relational Model</a></p><p><a href="https://agoni66.github.io/posts/1000113.html">Chapter3 Introduction to SQL</a></p><p><a href="https://agoni66.github.io/posts/1000114.html">Chapter4 Intermediate SQL</a></p><p><a href="https://agoni66.github.io/posts/1000116.html">Chapter6 Formal Relational Query Languages</a></p><p><a href="https://agoni66.github.io/posts/1000117.html">Chapter7 Entity-Relationship Model</a></p><p><a href="https://agoni66.github.io/posts/1000118.html">Chapter8 Relational Database Design</a></p><p><a href="https://agoni66.github.io/posts/1000115.html">Chapter10 Storage and File Structure</a></p>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter10 Storage and File Structure</title>
    <link href="https://agoni66.github.io/posts/1000115.html"/>
    <id>https://agoni66.github.io/posts/1000115.html</id>
    <published>2024-08-04T09:30:00.000Z</published>
    <updated>2024-08-06T09:23:25.441Z</updated>
    
    <content type="html"><![CDATA[<h3 id="物理存储介质概述">物理存储介质概述</h3><ul><li>高速缓冲存储器</li><li>主存储器</li><li>快闪存储器 电源关闭也可以保存数据</li><li>磁盘存储器</li><li>光学存储器</li><li>磁带存储器</li></ul><p><img src="../img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/2.png" alt="2.png"></p><ul><li>基本存储 最快的存储介质（cache和主存）</li><li>辅助存储 基本存储的下一层介质</li><li>三级存储or脱机存储 最底层的介质</li><li>易失性存储 设备断电后将丢失所有内容</li><li>非易失性存储 设备断电后将不会丢失所有内容</li></ul><h3 id="磁盘和快闪存储器">磁盘和快闪存储器</h3><p><img src="../img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/3.png" alt="Untitled"></p><ul><li><p><strong>磁盘的物理特性</strong></p><ul><li>盘片</li><li>磁道</li><li>扇区 磁道写入和读出信息的最小单位</li><li>读写头 将信息磁化存储到扇区中</li><li>磁盘臂 所有读写头安装在上面一起移动</li><li>柱面 所有盘片的第几条磁道</li><li>磁盘控制器 计算机系统和实际的磁盘驱动器硬件之间的接口</li><li>坏扇区的重映射</li><li>存储区域网</li><li>独立磁盘冗余阵列</li><li>网络附加存储NAS</li></ul></li><li><p><strong>磁盘性能的度量</strong></p><ul><li>访问时间</li><li>寻道时间 平均寻道时间</li><li>旋转等待时间</li><li>数据传输率</li><li>平均故障时间</li></ul></li><li><p><strong>磁盘块访问的优化</strong></p><ul><li>虚拟地址≈快号</li><li>一个块是一个逻辑单元，包含固定数目的连续扇区</li><li>顺序访问</li><li>随机访问</li><li>缓冲(buffering)：从磁盘读取的块暂时存储在内存缓冲区</li><li>预读(read-ahead)：当一个磁盘块被访问时，相同磁道的连续块也读入内存缓冲区</li><li>调度(scheduling)：电梯算法</li><li>文件组织(file organization)</li><li>非易失性写缓冲区(nonvolatile write buffer)</li><li>日志磁盘：用于写顺序日志的磁盘，可以减少写等待时间</li></ul></li><li><p><strong>快闪存储</strong></p><ul><li>NOR快闪 允许随机访问内存中的单个字</li><li>NAND快闪 需要将整个数据页读取到主存储器</li><li>NAND快闪便宜，存储容量高，使用更广泛</li><li>闪存的写入：不能直接覆盖，先擦除再重写，擦除块</li><li>转换表：逻辑到物理的页面映射存储到内存的转换表</li><li>损耗均衡：在物理块中均匀分布擦除操作的原则，因为物理页可能擦除过多而损坏</li><li>混合硬盘驱动器：结合了小容量闪存存储器的硬盘系统</li></ul></li><li><p><strong>RAID</strong></p><ul><li>目的：存储需求增长，为了提高性能和可靠性，易于管理和操作</li><li>独立磁盘冗余阵列</li><li>冗余<ul><li>存储正常情况下不需要的额外信息，这些信息可用于故障时重建恢复</li><li>镜像：复制每一张磁盘</li></ul></li><li>并行<ul><li>数据拆分：提高传输速率的手段</li><li>比特级拆分：每个字节按比特分开，存储到多个磁盘上</li><li>块级拆分：将块拆分到多个磁盘上</li></ul></li><li>RAID级别</li></ul></li><li><p><img src="../img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/4.png" alt="Untitled"></p><ul><li>RAID级别的选择<ul><li>所需的额外磁盘存储带来的花费</li><li>在I/O操作数量方面的性能需求</li><li>磁盘故障时的性能</li><li>数据重建过程中的性能</li></ul></li><li>软件RAID：不改变硬件层 只修改软件的RAID</li><li>硬件RAID：具有硬件支持的RAID</li></ul></li></ul><h3 id="第三级存储">第三级存储</h3><ul><li>光盘</li><li>磁带<ul><li>数字音频磁带DAT：几个GB</li><li>字线性磁带DLT：10~40GB</li><li>Ultrium：100GB</li><li>Amp螺旋扫描磁带：330GB</li><li>数据传输率在每秒几到几十MB</li><li>自动磁带机：存放大量磁道，并有少量可用于安装磁带的动器</li></ul></li></ul><h3 id="文件组织">文件组织</h3><ul><li>一个文件在逻辑上组织成为记录的一个序列</li><li>块：每个文件分成定长的存储单元，是存储分配和数据传输的基本单位</li><li>文件头：分配有一定数量的字节，包含有关文件的各种信息</li><li>定长记录<ul><li>假设记录大小是固定的。</li><li>每个文件只包含一种特定类型的记录。</li><li>不同的文件用于不同的关系</li><li>用空闲链表来存储空余空间</li></ul></li><li>变长记录<ul><li>插槽页头(Slotted page header)包含以下内容：<ul><li>记录条目的数量</li><li>块中空闲空间的结束位置</li><li>每个记录的位置和大小</li></ul></li><li>可以在页面内部移动记录，以保持它们的连续性，中间没有空白空间；页头中的条目必须更新</li><li>指针不应直接指向记录，而应指向页头中记录对应的条目</li></ul></li><li>文件的记录组织<ul><li>堆文件组织：一条记录可以放在文件中的有空间的任何地方（记录无顺序）</li><li>顺序文件组织：记录根据其搜索码的值顺序存储<ul><li>搜索码是任何一个属性或者属性的集合</li><li>重组：使记录在物流上顺序存放</li></ul></li><li>散列文件组织<ul><li>多表聚簇文件组织：在每一块中存储两个或者更多个关系的相关记录的文件结构</li></ul></li></ul></li></ul><h3 id="数据字典存储">数据字典存储</h3><ul><li>元数据：关于数据的数据</li><li>数据字典：存储关系的关系模式和其他元数据</li><li>系统必须存储的信息类型<ul><li>关系的名字</li><li>每个关系中属性的名字</li><li>属性的域和长度</li><li>在数据库上定义的视图的名字和定义</li><li>完整性约束</li></ul></li></ul><h3 id="数据库缓冲区">数据库缓冲区</h3><ul><li>缓冲区：主存储器中用于存储磁盘块拷贝的部分</li><li>缓冲区管理器：负责缓冲区空间分配的子系统<ul><li>为了使数据库系统能够从系统崩溃中恢复，限制一个块写回磁盘的时间是必要的</li><li>被钉住的块：不允许写回磁盘的块</li><li>块的强制写出</li></ul></li><li>缓冲区替换策略<ul><li>最近最少使用LRU</li><li>最近最常使用MRU</li></ul></li></ul>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter10 Storage and File Structure</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter8 Relational Database Design</title>
    <link href="https://agoni66.github.io/posts/1000118.html"/>
    <id>https://agoni66.github.io/posts/1000118.html</id>
    <published>2024-08-03T14:30:00.000Z</published>
    <updated>2024-08-06T09:19:11.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分解">分解</h3><p>如果分解后无法重建原始信息，那么就是有损分解(Lossy Decomposition)，反之则为无损分解(Lossless-Join Decomposition)</p><blockquote><p>好的分解要做到无损分解和依赖保存</p></blockquote><blockquote><p>BCNF 分解可以保证无损，3NF 可以保证依赖保存，但是 3NF 无法保证没有冗余，因此需要在 BCNF 和 3NF 间权衡</p></blockquote><h3 id="第一范式">第一范式</h3><ul><li>如果一个域的元素都是不可分的单位，这个域是<strong>原子的</strong></li><li>一个关系模式R的所有属性的域都是原子的，这个关系模式属于<strong>第一范式(First Normal Form, 1NF)</strong></li><li>原子性实际上是与域的元素如何使用相关的属性，就是说我们怎么看待这个属性</li></ul><h3 id="第二范式">第二范式</h3><ul><li>函数依赖是对合法关系集合的约束条件</li><li>要求某个属性集合的值唯一确定另一个属性集合的值</li><li>定义为：$A\rightarrow B$<ul><li>$A$是模式$(A,B)$的超码</li><li>属性$A$的取值决定$B$的取值</li></ul></li><li>平凡函数依赖：$A\subseteq B$</li><li>完全函数依赖：$A$的任意真子集都推不出$B$</li><li>部分函数依赖：$A$的任意一个真子集可以推出$B$</li><li>非主码都完全函数依赖于主码的，这个关系模式属于<strong>第二范式(Second Normal Form, 2NF)</strong></li></ul><h3 id="第三范式">第三范式</h3><ul><li>闭包<ul><li>$F^{+}$表示所有能从函数依赖$F$中推出的函数依赖闭包</li><li>如果两个函数依赖集的闭包相等，那么我们就说这两个函数依赖集是等价的</li><li>性质<ul><li>自反性</li><li>扩充性</li><li>传递性</li></ul></li><li>附加规则<ul><li>并集规则</li><li>分解规则</li><li>伪传递规则</li></ul></li></ul></li><li>$A\rightarrow B~and~B\rightarrow C\Rightarrow A\rightarrow C$ 成为传递依赖</li><li>没有传递依赖的第二范式，这个关系模式属于<strong>第三范式(Third Normal Form, 3NF)</strong></li></ul><h3 id="BCNF范式">BCNF范式</h3><ul><li>要验证一个属性$x$对于给定的$Ax\rightarrow B$是否冗余，如果$A\rightarrow B$成立，$x$就是冗余的</li><li>关系模式 $R$ 在 BCNF（Boyce-Codd 范式）中，如果对于$R$中的存在的所有函数依赖关系$F$，形式为$A\rightarrow B$，其中$A\subseteq R$且$B\subseteq R$，至少满足以下条件之一<ul><li>$A\subseteq B$</li><li>$A$是$R$的超键</li></ul></li><li>检查BCNF<ul><li>计算函数依赖的闭包$A^{+}$</li><li>验证是否满足$R\subseteq A^{+}$</li></ul></li></ul><h3 id="总结">总结</h3><div class="note info no-icon flat"><p>🧡 <strong>范式之间的关系：</strong><br>第一范式(1NF)<br>非码的非平凡<br>↓ 消除非主属性对码的部分函数依赖<br>第二范式(2NF)<br>↓ 消除非主属性对码的传递函数依赖<br>第三范式(3NF)<br>↓ 消除主属性对码的部分和传递函数依赖<br>BC 范式(BCNF)<br>↓ 消除非平凡且非函数依赖的多值依赖<br>第四范式(4NF)<br>↓ 消除不是由候选码所蕴含的连接依赖<br>第五范式(5NF)</p></div>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter8 Relational Database Design</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter7 Entity-Relationship Model</title>
    <link href="https://agoni66.github.io/posts/1000117.html"/>
    <id>https://agoni66.github.io/posts/1000117.html</id>
    <published>2024-08-02T14:30:00.000Z</published>
    <updated>2024-08-04T16:48:52.714Z</updated>
    
    <content type="html"><![CDATA[<h3 id="E-R模型">E-R模型</h3><p><strong>实体</strong> 是现实世界中可区别于所有其他对象的一个事务，例如大学中的每个人</p><p><strong>实体集</strong> 是相同类型即具有相同属性的一个实体集合，例如大学中的所有人</p><p><strong>属性</strong> 每个实体的每个属性都有一个值</p><p><strong>联系</strong> 是指多个实体间的相互关联</p><p><strong>联系集</strong> 是相同类型联系的集合，是n≥2个实体集上的数学关系</p><p><strong>参与</strong> 实体集之间的关联，实体集$E_1,E_2,…,E_n$参与联系集$R$</p><p><strong>度</strong> 参与联系集的实体集的数目</p><p><strong>域</strong> 每个属性的可取值的集合</p><h3 id="属性分类">属性分类</h3><ul><li>简单和复合<ul><li>简单不能划分为更小饿部分</li><li>复合比如说姓名可以划分为姓和名</li></ul></li><li>单值和多值</li><li>派生 这类属性的值可以从相关属性得出</li></ul><h3 id="约束">约束</h3><p><strong>映射基数</strong> 标识一个实体通过联系集能关联的实体的个数</p><ul><li>一对一</li><li>一对多</li><li>多对一</li><li>多对多</li></ul><p><strong>参与约束</strong></p><ul><li>全部 实体集E对的每个实体都参与到联系集R的至少一个联系</li><li>部分 实体集E只有部分实体参与到联系集R的联系</li></ul><p><strong>码</strong> 唯一标识该实体</p><p><strong>基线约束</strong></p><p>→ 箭头指向 <strong><code>一</code></strong></p><p>— 横线指向 <strong><code>多</code></strong></p><blockquote><p>对于三元（或更高度）关系，我们最多允许从关系中有一个箭头出去，以表示基数约束</p></blockquote><h3 id="E-R图">E-R图</h3><ul><li><strong>矩形</strong>表示实体集<ul><li>复合属性跟在简单属性下面，统一缩进格式</li></ul></li><li>菱形表示关系集</li><li><strong>实体矩形</strong>内列出属性</li><li><strong>下划线</strong>表示主键属性</li><li>非二次的联系集用多条线连接</li><li><strong>弱实体集</strong> 没有主码的实体集</li><li><strong>强实体集</strong> 有主码的实体集</li><li>弱实体集必须与<strong>标识实体集</strong>关联</li></ul><h3 id="关系模式的转化">关系模式的转化</h3><ul><li>E-R图转化为一些关系模式的集合</li><li>强实体集：$(A_1,A_2,…,A_n)$，其中$A_1,A_2,…,A_n$是实体集内的属性</li><li>弱实体集：$(A_1,A_2,…,A_n,p)$，其中$A_1,A_2,…,A_n$是实体集内的属性,$p$是识别强实体集的主码</li><li>联系集：参与的所有实体集的主码的集合 + 自己的属性<ul><li>多对多 双方主码的并集为联系集的主码</li><li>一对多 多的主码为联系集的主码</li><li>一对一 任意的都可以</li></ul></li></ul><h3 id="设计问题">设计问题</h3><span class='p blue'>用实体集还是用属性？</span><ul><li>用实体集比较灵活，可存储额外信息</li></ul><span class='p blue'>用实体集还是用联系集？</span><ul><li>不好说，更多的是用联系集表示实体之间的操作</li></ul><span class='p blue'>用二元关系集还是用n元关系集？</span><ul><li>可以用多个二元关系集表示n元关系集，但n元关系集清楚一些</li></ul><h3 id="扩展的E-R特性">扩展的E-R特性</h3><p><strong>特化</strong></p><ul><li>自顶向下的设计过程</li><li>在实体集内部进行分组的过程，比如说person实体集分为employee和student</li></ul><p><strong>概化</strong></p><ul><li>自底向上的设计过程</li><li>将共享相同特征的多个实体集合并为一个较高层的实体集</li></ul><p>高层和低层实体集也称为<strong>超类</strong>（superclass）和<strong>子类</strong>（subclass）</p><p><strong>属性继承</strong></p><ul><li>高层实体集的属性被低层实体集继承</li><li>高层实体集所关联的所有属性和联系适用于它的所有低层实体集</li><li>低层实体集特有的性质仅适用于特定的低层实体集</li></ul><p><strong>概化上的约束</strong></p><ul><li>条件定义的</li><li>用户定义的</li><li>不相交：一个实体至多属于一个低层实体集</li><li>重叠：一个实体可以属于多个较低级别实体集</li><li>完全性约束<ul><li>全部概化或特化： 每次高层实体必须属于一个低层实体集</li><li>部分概化或特化：允许一些高层实体不属于任何低层实体集</li></ul></li></ul><p><strong>聚集</strong></p><p>使联系化为高层实体，并且可以参与联系</p><ul><li>将关系视为抽象实体</li><li>允许关系之间的关系</li><li>将关系抽象成新的实体，避免引入冗余</li></ul><p><strong>转为关系模式</strong></p><ul><li>方法一<ul><li>为高级实体形成一个模式</li><li>为每个低级实体集形成一个模式，包括上层实体集的主键和局部属性</li><li>缺点：获取有关员工的信息需要访问两个关系，即对应于低级别模式和高级别模式的关系</li></ul></li><li>方法二<ul><li>为每个实体集构建模式，包括所有本地和继承的属性</li><li>缺点：可能会冗余存储</li></ul></li></ul><h3 id="统一建模语言UML">统一建模语言UML</h3><ul><li>类图：与E-R图类似</li><li>用况图：说明用户与系统之间的交互</li><li>活动图：说明系统不同部分之间的任务流</li><li>实现图：在软硬件说明系统的各组成部分以及它们之间的联系</li><li>关联：类比联系集</li></ul><h3 id="数据库设计的其他方面">数据库设计的其他方面</h3><ul><li>数据约束：自动的一致性保持</li><li>使用需求：查询、性能：吞吐量和响应时间</li><li>授权需求</li><li>数据流、工作流</li></ul>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter7 Entity-Relationship Model</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter6 Formal Relational Query Languages</title>
    <link href="https://agoni66.github.io/posts/1000116.html"/>
    <id>https://agoni66.github.io/posts/1000116.html</id>
    <published>2024-08-01T14:30:00.000Z</published>
    <updated>2024-08-01T15:06:37.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系代数">关系代数</h2><p>关系代数是一种过程化查询语言</p><p>一元运算：对一个关系进行运算</p><p>二元运算：对两个关系进行运算</p><ul><li>选择 σ  $\sigma _{p}\left( R\right)$</li></ul>$$\sigma _{p}\left( r\right) =\left\{  t~| t\in r~and~p\left( t\right) \right\}$$<ul><li>投影 π<br>$$\prod a_{1},\ldots ,a_{n}\left( R\right)$$</li><li>笛卡尔积 x</li></ul>$$r\times s= \{ t,q~| t\in r~and~q\in s\}$$<ul><li>自然连接 ⋈</li><li>重命名 ρ<ul><li>$\rho _{x}\left( R\right)$ 表示把关系R重命名为x</li><li>$P_{x\left( A_1\ldots ,A_{n}\right) }\left( R\right)$</li></ul></li><li>集合差 -</li></ul>$$r\cup S=\left\{  t~| t\in r ~or~ t\in s\right\}$$<ul><li>集合交 ∩</li></ul>$$r\cap  S=\left\{  t~| t\in r ~and~ t\in s\right\}$$]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter6 Formal Relational Query Languages</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter4 Intermediate SQL</title>
    <link href="https://agoni66.github.io/posts/1000114.html"/>
    <id>https://agoni66.github.io/posts/1000114.html</id>
    <published>2024-07-31T14:30:00.000Z</published>
    <updated>2024-08-01T14:58:30.929Z</updated>
    
    <content type="html"><![CDATA[<h3 id="连接条件">连接条件</h3><p><code>on</code></p><p>在on语句后写具体的条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">join</span> takes <span class="keyword">on</span> student.ID <span class="operator">=</span> takes.ID;</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student,takes <span class="keyword">where</span> student.ID <span class="operator">=</span> takes.ID;</span><br></pre></td></tr></table></figure><h3 id="外连接">外连接</h3><p>外连接运算与自然连接运算类似，只不过通过在结果中创建空值的方式，保留了在连接中丢失的元组</p><ul><li>左外连接：left outer join，只保留左边这张表的元组</li><li>右外连接：right outer join，只保留右边那张表的元组</li><li>全外连接：full outer join，保留出现在关系中全部的元组</li><li>内连接：inner join，不保留未匹配元组</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">natural</span> <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> takes;</span><br></pre></td></tr></table></figure><p><strong>左外连接和右外连接是对称的</strong></p><h3 id="视图">视图</h3><p>创建视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_name <span class="keyword">as</span> (查询表达式)</span><br></pre></td></tr></table></figure><p>例如，需要访问instructor关系中除salary之外的所有数据的职员</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> faculty <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> ID, name, dept_name</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><p><strong>一般不允许对视图关系进行修改</strong></p><p>视图更新可能存在问题，比如在插入数据时，如果视图的属性列少于基本表，那么可能会出现以下两种情况</p><ol><li>拒绝插入</li><li>向基本表中插入元组，未赋值的属性值为null</li></ol><p>删除视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> view_name</span><br></pre></td></tr></table></figure><h3 id="事务">事务</h3><p>事务(transaction)由查询语句(select)和更新语句(update)的序列组成</p><ul><li>commit work：提交当前事务，将事务所做的更新在数据库中长久保存</li><li>rollback work：回滚当前事务，撤销该事务中所有SQL语句对数据库的更新</li></ul><p>一旦事务执行了commit work，就不能通过rollback work撤销了</p><p>一个较好的选择是，允许多条SQL语句包含在关键字<code>begin atomic……end</code>之间，这些SQL语句构成单一事务</p><h3 id="完整性约束">完整性约束</h3><ul><li>主码约束</li><li>not null</li><li>unique</li><li>check</li><li>参照完整性</li></ul><h3 id="默认值">默认值</h3><p><code>default</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> s</span><br><span class="line">(</span><br><span class="line">sex <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">sno <span class="type">char</span>(<span class="number">5</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="create-table-的拓展">create table 的拓展</h3><p>创建与现有表的模式相同的表</p><p>例如，创建一个与instructor具有相同模式的新表temp_instructor</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> temp_instructor <span class="keyword">like</span> instructor;</span><br></pre></td></tr></table></figure><h3 id="授权">授权</h3><p>SQL标准包括<code>select</code> <code>insert</code> <code>update</code> <code>delete</code></p><p><code>grant</code>语句用来授予权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 表级权限 <span class="keyword">on</span> 关系名或视图名 <span class="keyword">to</span> 用户<span class="operator">/</span>角色列表</span><br></pre></td></tr></table></figure><p>例如，授予数据库用户Amit和Satoshi在department关系上的select权限，授予数据库用户Amit和Satoshi在department关系的budget属性上的update权限，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> department <span class="keyword">to</span> Amit,Satoshi;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">update</span>(budget) <span class="keyword">on</span> department <span class="keyword">to</span> Amit,Satoshi;</span><br></pre></td></tr></table></figure><p><code>revoke</code>语句用来收回权限</p><p>例如，收回授予数据库用户Amit和Satoshi在department关系上的select权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> student <span class="keyword">to</span> Amit,Satoshi;</span><br></pre></td></tr></table></figure><h3 id="角色">角色</h3><p>在数据库中建立角色集，并授予每个角色一定的权限，然后将角色分配给用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> role instructor;</span><br></pre></td></tr></table></figure><p>角色可以授予给用户，也可以授予给其他角色</p>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter4 Intermediate SQL</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter3 Introduction to SQL</title>
    <link href="https://agoni66.github.io/posts/1000113.html"/>
    <id>https://agoni66.github.io/posts/1000113.html</id>
    <published>2024-07-30T14:30:00.000Z</published>
    <updated>2024-07-31T16:23:16.038Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL-数据定义语言（-data-definition-language-DDL）">SQL 数据定义语言（ data-definition language ,DDL）</h3><ul><li>每个关系的模式</li><li>每个属性关联的值域</li><li>完整性约束</li><li>每个关系要维护的索引集合</li><li>每个关系的安全性和授权信息</li><li>每个关系在磁盘上的物理存储结构</li></ul><h3 id="基本类型">基本类型</h3><table><thead><tr><th>语法</th><th>语义</th></tr></thead><tbody><tr><td>char(n)</td><td>指定长度n的字符串</td></tr><tr><td>varchar(n)</td><td>最大长度n的字符串</td></tr><tr><td>int</td><td>整形</td></tr><tr><td>smallint</td><td>小整数</td></tr><tr><td>float(n)</td><td>精度至少是n位浮点数</td></tr><tr><td>numeric(p,d)</td><td>定点数，p长度、d精度</td></tr></tbody></table><p>每种类型都可能包含一个空值</p><h3 id="基本模式定义">基本模式定义</h3><p><strong>创建</strong></p><p>创建一个department关系</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department(</span><br><span class="line">dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">building <span class="type">varchar</span>(<span class="number">15</span>),</span><br><span class="line">budget <span class="type">numeric</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">primary</span> key(dept_name));</span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><p>插入一个名叫Smith的生物教师，其id为10211，工资为6000</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> instructor <span class="keyword">values</span>(</span><br><span class="line"><span class="number">10211</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;Biology&#x27;</span>, <span class="number">6000</span>);</span><br></pre></td></tr></table></figure><p><strong>更新</strong></p><p>所有教师的工资将增长5%</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><p>删除元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><p>删除关系</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> r;</span><br></pre></td></tr></table></figure><p><strong>增加</strong></p><p>为关系增加/删除属性 A属性名 D属性的域</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> r <span class="keyword">add</span> A D;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> r <span class="keyword">delete</span> A;</span><br></pre></td></tr></table></figure><h3 id="完整性约束">完整性约束</h3><ul><li>primary key( ) 主码属性必须非空且唯一</li><li>foreign key( ) references table 外码约束</li><li>not null 不允许空值</li></ul><h3 id="SQL查询">SQL查询</h3><p><code>select</code> <code>from</code> <code>where</code></p><ul><li>单关系查询</li><li>多关系查询</li><li>自然连接 <code>natural join</code></li><li>更名运算<code>as</code></li><li>字符串运算<ul><li><code>like</code></li><li><code>%</code> 任意匹配多个字符</li><li><code>_</code> 任意匹配一个字符</li><li><code>\</code> 转义字符</li></ul></li><li><code>*</code> 所有的属性</li><li>次序<ul><li><code>order by</code></li><li><code>desc</code> 降序</li><li><code>asc</code> 升序</li></ul></li><li>集合运算<ul><li>union 并运算 自动去重（不想就union all）</li><li>intersect 交运算 自动去重（不想就intersect all）</li><li>except 差运算</li></ul></li><li>聚集函数<ul><li><code>avg</code> 平均值</li><li><code>min</code> 最小值</li><li><code>max</code> 最大值</li><li><code>sum</code> 总和</li><li><code>count</code> 计数</li></ul></li><li>分组聚集<code>group by</code><ul><li>group by子句中所有属性相同的元组将分为一个组</li></ul></li><li>having子句<ul><li>聚集函数后只能使用having子句</li><li>having子句应用在group by子句上</li></ul></li><li>嵌套子查询<ul><li>至少比某一个大 <code>&gt;some</code></li><li>至少比某一个小 <code>&lt;some</code></li><li><code>=some</code> 就是 <code>in</code></li><li>比所有都大 <code>&gt;all</code></li><li>比所有都小 <code>&lt;all</code></li><li><code>unique</code> 没有重复元素返回true</li><li><code>exists</code> 子查询非空返回true</li></ul></li></ul>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter3 Introduction to SQL</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter2 Introduction to Relational Model</title>
    <link href="https://agoni66.github.io/posts/1000112.html"/>
    <id>https://agoni66.github.io/posts/1000112.html</id>
    <published>2024-07-30T10:30:00.000Z</published>
    <updated>2024-08-01T14:13:19.556Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识">基础知识</h3><ul><li>实体</li><li>弱实体：没有主码的实体，对应支配实体</li><li>实体集：实体集里面的实体属性一样 $E_1…E_n$</li><li>域：属性的所有可能值的集合</li><li>联系</li><li>联系集</li></ul>$$R=\left\{  \left( e_{1}\ldots e_{n}\right) | e_{1}\in E_{1},e_{n}\in E_{n}\right\} $$<ul><li>实体 联系都有属性</li><li>关系是无序的</li></ul><h3 id="约束constraint">约束constraint</h3><ul><li>关键约束（粗线箭头） 只能是一个</li><li>参与约束<ul><li>完全参与（粗线） 至少一个</li><li>部分参与</li></ul></li></ul><h3 id="码">码</h3><p>一个关系中没有两个元组在所有属性中的取值都相同</p><ul><li>超码：一个或多个属性的集合，这些属性足以在一个关系中唯一标识元组</li><li>候选码：最小超码</li><li>主码</li><li>外码：另一个关系的主码被参照</li></ul><h3 id="关系运算">关系运算</h3><ul><li>选择——行</li><li>投影——列</li><li>连接</li><li>自然连接</li><li>笛卡尔积</li><li>集合运算<ul><li>交 ∩</li><li>并 ∪</li><li>差 -</li></ul></li></ul>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter2 Introduction to Relational Model</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter1 Introduction</title>
    <link href="https://agoni66.github.io/posts/1000111.html"/>
    <id>https://agoni66.github.io/posts/1000111.html</id>
    <published>2024-07-30T02:30:00.000Z</published>
    <updated>2024-07-30T02:22:11.777Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是DBMS？">什么是DBMS？</h3><p>数据库是数据的存储、维护一个非常大的集成的数据</p><p>数据库是对现实世界的建模（实体entities 关系）</p><p>数据库管理系统DBMS是存储和管理数据库的软件包</p><h3 id="文件系统和DBMS的对比">文件系统和DBMS的对比</h3><p>文件系统：应用程序访问的单个文件的集合</p><p>DBMS：用电脑处理的用于记录保存的系统</p><p>文件系统的缺点：</p><ul><li>数据冗余和不一致：多种文件格式，不同文件中的信息重复</li><li>访问数据困难：需要编写新程序来执行每项新任务</li><li>数据孤立</li><li>完整性问题</li><li>原子性问题</li><li>并发访问异常</li><li>安全性问题</li></ul><p>DBMS的优点：</p><ul><li>独立性</li><li>检索 selcet 查询 query</li><li>完整性约束</li><li>安全性（权限、访问控制）</li><li>方便管理和使用</li><li>并发访问</li><li>恢复崩溃</li><li>减少应用开发时间</li></ul><h3 id="数据模型">数据模型</h3><p>数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合</p><ul><li>关系模型 (第二章)<ul><li>关系relation，就是由列和行组成的表格</li><li>每个关系都有模式 schema</li><li>模式就是一个实体的模版</li><li>记录record：行</li><li>属性attribute：列</li></ul></li><li>实体-关系数据模型（主要用于数据库设计）</li><li>基于对象的数据模型（面向对象和对象关系）</li><li>半结构化数据模型 (XML)</li><li>其他旧模型：<ul><li>网络模型</li><li>层次模型</li></ul></li></ul><h3 id="数据抽象">数据抽象</h3><ul><li>外模式（视图） external schema</li><li>概念模式（逻辑模式） conceptual schema</li><li>物理模式（内模式） physical schema</li></ul><p>原因：数据独立性 data independence = 逻辑独立性 + 物理独立性</p><h3 id="DBMS的查询queries">DBMS的查询queries</h3><ul><li>关系代数和关系演算</li><li>structural query language（SQL）</li><li>数据操作语言DML<ul><li>过程化DML：要求用户指定需要什么数据以及如何获得这些数据</li><li>声明化DML：只要求用户指定需要什么数据</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> instructor.dept_name <span class="operator">=</span> <span class="string">&#x27;History&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>数据定义语言DDL</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> instructor (</span><br><span class="line">ID             <span class="type">char</span>(<span class="number">5</span>),</span><br><span class="line">name           <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">dept_name      <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">salary         <span class="type">numeric</span>(<span class="number">8</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure><h3 id="数据库设计">数据库设计</h3><p>数据库设计分为 <strong>6 个阶段</strong>：</p><ol><li><p><strong>需求分析</strong></p><ol><li>调查机构情况与熟悉业务活动，明确用户的需求，确定系统的边界，生成数据字典和用户需求规格说明书</li><li>搜集资料</li><li>分析整理</li><li>数据流图</li><li>数据字典</li><li>用户确认</li></ol></li><li><p><strong>概念结构设计</strong></p><p>将需求分析得到的用户需求抽象为概念模型，绘制E-R图</p></li><li><p><strong>逻辑结构设计</strong></p><p>将E-R图转换为与 DBMS相符合的逻辑结构（包括数据库模式和外模式），例如E-R图向关系模型转换，再根据规范化理论对数据模型进行优化，设计用户子模式</p></li><li><p><strong>物理结构设计</strong></p><p>通常关系数据库物理设计的内容包括关系模式选择存取方法、以及设计关系、索引等数据库文件的物理存储结构</p></li><li><p><strong>数据库实施</strong></p><p>建立实际数据库结构、试运行、装入数据</p></li><li><p><strong>数据库运行和维护</strong></p><p>维护数据库的安全性、完整性控制以及系统的转储和恢复；性能的监督、分析和改进；增加新功能；发现错误和修改错误</p></li></ol><h3 id="事务">事务</h3><ol><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ol><p>ACID properties</p><h3 id="DBMS结构">DBMS结构</h3><ul><li>数据库管理系统</li><li>查询评估引擎<ul><li>分析器</li><li>优化器</li><li>操作器</li><li>操作评估器</li></ul></li><li>CPU</li><li>缓存管理器</li><li>磁盘空间管理器</li><li>并发控制<ul><li>事务管理器</li><li>锁管理器</li></ul></li><li>恢复管理器</li></ul><p><img src="../img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/1.png" alt="Untitled"></p><hr><h3 id="SQL语句执行流程"><strong>SQL语句执行流程</strong></h3><p><img src="../img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/2.webp" alt="Untitled"></p><p>MySQL 可以分为 Server 层和存储引擎层两部分</p><ol><li><p><strong>连接器</strong></p><p><code>mysql -h10.10.0.18 -p3306 -uroot -p</code></p><p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作</p></li><li><p><strong>查询缓存（已经移除）</strong></p><p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集</p><p>执行查询语句时，看看有没有查询过，有则返回之前结果（以 Key-Value 的形式缓存在内存中），没有则继续查询。<strong>当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</strong></p></li><li><p><strong>分析器</strong></p><p>分析器主要是用来分析 SQL 语句是来干嘛的</p><p>第一步，词法分析</p><p>第二步，语法分析</p><p><strong>然后报错</strong></p></li><li><p><strong>优化器</strong></p><p>去选择最优的执行方案</p></li><li><p><strong>执行器</strong></p><p>首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误</p></li></ol>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter1 Introduction</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>算法图解</title>
    <link href="https://agoni66.github.io/posts/1000200.html"/>
    <id>https://agoni66.github.io/posts/1000200.html</id>
    <published>2024-06-07T06:30:00.000Z</published>
    <updated>2024-06-07T06:36:12.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介">1.简介</h2><h3 id="二分查找">二分查找</h3><ul><li><p>最多查找 $\log_{2}n$ 次</p></li><li><p>时间复杂度：$O(\log n)$</p></li><li><p>有序</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params"><span class="built_in">list</span>, item</span>):</span><br><span class="line">low = <span class="number">0</span></span><br><span class="line">high = <span class="built_in">len</span>(<span class="built_in">list</span>) - <span class="number">1</span> </span><br><span class="line"><span class="keyword">while</span> low &lt;= high: </span><br><span class="line">mid =(low + high)</span><br><span class="line">guess = <span class="built_in">list</span>[mid]</span><br><span class="line"><span class="keyword">if</span> guess == item:</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line"><span class="comment"># mid 如果不是，就从 mid 前后继续查找</span></span><br><span class="line"><span class="keyword">if</span> quess &gt; item: </span><br><span class="line">high = mid - <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="旅行商问题">旅行商问题</h3><p>有一位旅行者需要前往 n 个城市，同时确保旅程最短（计算每种顺序及其总旅程）</p><p>$ O(n!) $</p><br/><hr><h2 id="2-选择排序">2.选择排序</h2><p>需要将数据存储到内存时，我需要请求将数据提供存储地址，计算机会给我一个存储地址，我再把数据放里面</p><p><strong>数组</strong></p><ul><li><p>需要连续的存储空间，如果不满足，无法添加数据，则复制（移动）到另一个满足的连续空间</p></li><li><p>解决方法：预留空间，会浪费内存</p></li><li><p>支持随机访问和顺序访问</p></li></ul><p><strong>链表</strong></p><ul><li><p>每个元素都存储下一个元素的地址</p></li><li><p>修改和删除简单，只需修改一两个元素指向的地址</p></li><li><p>缺点：最后一个元素不能直接读取</p></li><li><p>只能顺序访问（从第一个元素开始逐个读取元素）</p></li></ul><h3 id="选择排序">选择排序</h3><ul><li><p>选择单一指标进行排序</p></li><li><p>每次遍历一遍 选一个出来</p></li><li><p>时间复杂度：$ O（n^2） $</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findSmallest</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt;<span class="built_in">int</span>:</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">定义一个找出数组中最小数的函数，返回其索引</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">smallest = arr[<span class="number">0</span>]</span><br><span class="line">smallest_index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line"><span class="keyword">if</span> arr[i] &lt; smallest:</span><br><span class="line">smallest = arr[i]</span><br><span class="line">smallest_index = i</span><br><span class="line"><span class="keyword">return</span> smallest_index</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">selectionSort</span>(<span class="params">arr</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">选择排序</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">newarr = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">smallest_index = findSmallest(arr)</span><br><span class="line">smallest = arr.pop(smallest_index)</span><br><span class="line"><span class="comment"># 使用内置函数实现</span></span><br><span class="line"><span class="comment"># smallest = min(arr)</span></span><br><span class="line"><span class="comment"># app.remove(smallest)</span></span><br><span class="line">newarr.append(smallest)</span><br><span class="line"><span class="keyword">return</span> newarr</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="3-递归">3.递归</h2><blockquote><p>请手写递归逻辑</p></blockquote><p>编写递归函数，必须注意何时停止递归</p><ul><li><p>递归条件：函数调用自己</p></li><li><p>基线条件：函数不再调用自己</p></li></ul><h3 id="栈">栈</h3><ul><li><p>操作</p><ul><li><p>压入</p></li><li><p>弹出</p></li></ul></li><li><p>调用栈(call stack)</p></li><li><p>函数与栈</p><ul><li><p>函数就是栈</p></li><li><p>哪个函数在栈顶就执行哪个函数</p></li><li><p>调用另一个函数时，当前函数暂停并处于未完成状态</p></li><li><p><strong>调用函数——压栈</strong></p></li><li><p><strong>return——出栈</strong></p></li></ul>  <div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0001.jpeg" style="width:78%;height:78%;"/></div></div>  <div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0002.jpeg" style="width:78%;height:78%;"/></div></div></li></ul><hr><h2 id="快速排序">快速排序</h2><h3 id="分而治之（divide-and-conquer-D-C）">分而治之（divide and conquer, D&amp;C）</h3><ul><li><p>步骤</p><ul><li>找出<strong>基线条件</strong></li><li>不断将问题分解（缩小规模），直到符合基线条件</li></ul></li><li><p>例子：sum函数</p><p><img src="../img/%E7%AE%97%E6%B3%95/0003.png" alt="Untitled"></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_arr</span>(<span class="params">arr</span>):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">number = arr.pop()</span><br><span class="line"><span class="keyword">return</span> number + sum_arr(arr)</span><br></pre></td></tr></table></figure></li><li><p>提示：涉及数组的递归函数，基线条件一般是数组为空或只有一个元素</p></li><li><p>提示：python数组是可变的，传进函数的是数组本身</p></li></ul><h3 id="快速排序-2">快速排序</h3><ul><li>基线条件：数组为空或只包含一个元素</li><li>复杂度：O(nlogn)</li><li>首先选择一个元素——基准值</li><li>接着分区<ul><li>一个小于基准值的子数组</li><li>基准值</li><li>一个大于基准值的子数组</li></ul></li><li>对这两个子数组基进行快速排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">array</span>):</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(array) &lt; <span class="number">2</span>:</span><br><span class="line"><span class="comment"># 基线条件</span></span><br><span class="line"><span class="keyword">return</span> array</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 取基准值</span></span><br><span class="line">pivot = array[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 一个小于基准值的子数组</span></span><br><span class="line">less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=pivot]</span><br><span class="line"><span class="comment"># 一个大于基准值的子数组</span></span><br><span class="line">greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i&gt;pivot]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> quicksort(array) + pivot + quicksort(array)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> quicksort([arr])</span><br></pre></td></tr></table></figure><hr><h2 id="4-散列表">4.散列表</h2><h3 id="散列函数">散列函数</h3><p>复杂度：$ O(1)$</p><p>条件：</p><ul><li>必须是一致的，输入和输出一一对应</li><li>将不同的输入映射到不同的数字</li><li>灵活运用索引</li><li>只返回有效索引</li></ul><p>python：字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">book = <span class="built_in">dict</span>()</span><br><span class="line">book[<span class="string">&quot;apple&quot;</span>] = <span class="number">0.67</span></span><br><span class="line">book[<span class="string">&quot;milk&quot;</span>] = <span class="number">1.49</span></span><br><span class="line">book[<span class="string">&quot;avocado&quot;</span>] = <span class="number">1.49</span></span><br><span class="line"><span class="built_in">print</span>(book)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;book&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(book.items())</span><br><span class="line"><span class="built_in">print</span>(book.keys())</span><br><span class="line"><span class="built_in">print</span>(book.values())</span><br></pre></td></tr></table></figure><p>散列表由键和值组成</p><h3 id="散列表的应用">散列表的应用</h3><ul><li>电话簿</li><li>网站地址转IP地址</li><li>缓存</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cache =&#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page</span>(<span class="params">url</span>):</span><br><span class="line"><span class="keyword">if</span> cache.get(url):</span><br><span class="line"><span class="keyword">return</span> cache[url]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">data = get_data_from_server(url)</span><br><span class="line">cache[url] = data</span><br><span class="line"><span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><ul><li>防止重复</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建已投票字典</span></span><br><span class="line">voted = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_voter</span>(<span class="params">name</span>): </span><br><span class="line"><span class="keyword">if</span> voted.get(name):</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;kick them out!&quot;</span> </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">voted[name] = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;let them vote!&quot;</span></span><br></pre></td></tr></table></figure><h3 id="冲突">冲突</h3><p>给两个键分配的位置相同</p><ul><li>散列函数很重要</li><li>如果散列表存储的链表很长，散列表的速度将急剧下降</li></ul><h3 id="性能">性能</h3><ul><li>较低的填装因子</li><li>良好的散列函数</li></ul><p>填装因子：散列表包含的元素数/位置总数</p><p>一旦填装因子大于0.7，可以调整列表长度</p><hr><h2 id="5-广度优先搜索">5.广度优先搜索</h2><p>breadth-first search, BFS</p><p>效果：找到两样东西之间的最短距离</p><p>最短路径问题(shortest-path problem)</p><ul><li>我去北京天安门，需要几个步骤<ul><li>打车到广州南站</li><li>高铁从广州南站到北京</li><li>打车到北京天安门</li></ul></li><li>使用图来建立问题模型</li><li>使用广度优先搜索解决问题</li></ul><h3 id="图">图</h3><p>图模拟一组连接</p><p>图由**节点(node)<strong>和</strong>边(edge)**组成</p><h3 id="广度优先搜索">广度优先搜索</h3><p>解决问题：</p><ol><li>从节点A出发，有前往节点B的路径吗？</li><li>从节点A出发，前往节点B的哪条路经最短？</li></ol><p><strong>队列</strong></p><p>先进先出(First In First Out, FIFO)</p><p>操作：</p><ul><li>入队</li><li>出队</li></ul><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0004.png" style="width:50%;height:50%;"/></div></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;you&quot;</span>] = [<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;claire&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;bob&quot;</span>] = [<span class="string">&quot;anuj&quot;</span>, <span class="string">&quot;peggy&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;alice&quot;</span>] = [<span class="string">&quot;peggy&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;claire&quot;</span>] = [<span class="string">&quot;thom&quot;</span>, <span class="string">&quot;jonny&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;anuj&quot;</span>] = []</span><br><span class="line">graph[<span class="string">&quot;peggy&quot;</span>] = []</span><br><span class="line">graph[<span class="string">&quot;thom&quot;</span>] = []</span><br><span class="line">graph[<span class="string">&quot;jonny&quot;</span>] = []</span><br></pre></td></tr></table></figure><blockquote><p>键-值对的添加顺序不重要，散列表是无序的</p></blockquote><h3 id="🔥实现算法">🔥实现算法</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0005.png" style="width:78%;height:78%;"/></div></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">person_is_seller</span>(<span class="params">name</span>):</span><br><span class="line"><span class="keyword">return</span> name[-<span class="number">1</span>] == <span class="string">&#x27;m&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">name</span>):</span><br><span class="line">search_queue = deque()</span><br><span class="line">search_queue += graph[<span class="string">&quot;you&quot;</span>]</span><br><span class="line">searched = [] <span class="comment"># 记录检查过的人</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> search_queue:<span class="comment"># 只要队列不为空</span></span><br><span class="line"><span class="comment"># 取出队列的第一个人</span></span><br><span class="line">person = search_queue.popleft()</span><br><span class="line"><span class="keyword">if</span> person <span class="keyword">not</span> <span class="keyword">in</span> searched:</span><br><span class="line"><span class="keyword">if</span> person_is_seller(person):</span><br><span class="line"><span class="built_in">print</span>(person + <span class="string">&quot;is a mango seller!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 将其邻居加入队列</span></span><br><span class="line">search_queue += graph[person]</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">search(<span class="string">&quot;you&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>运行时间</strong></p><p>O(V + E) V是顶点数，E为边数</p><p><strong>拓扑排序</strong>是针对有向无环图（DAG，Directed Acyclic Graph）的一种排序算法，它将图中的所有顶点排成一个<strong>线性序列（有序序列）</strong>，使得对于任何一条有向边U→V，顶点U都在顶点V之前</p><p><strong>树</strong>是特殊的图，其中没有往后指的边</p><hr><h2 id="6-迪克斯特拉算法">6.迪克斯特拉算法</h2><p>广度优先搜索 找出段数最少的路径</p><p>迪克斯特拉算法 找出最快、总权重最小的路径</p><ol><li>找出最小的节点（本轮权重最小的节点）</li><li>更新该节点的邻居的开销</li><li>重复🔁该过程，直到遍历完所有节点</li><li>计算最终路径</li></ol><div class="note warning no-icon flat"><p>🍁 <strong>找出图中最便宜的节点，并确保没有到该节点的更便宜的路径</strong></p></div><p><strong>术语</strong></p><ul><li>权重(weight)</li><li>加权图(weighted graph)</li><li>非加权图(unweighted graph)</li><li>环(loop)</li></ul><div class="note info no-icon flat"><p>迪克斯特拉算法只适用于有向无环图(directed acyclic graph, DAG)</p></div><p><strong>负权边</strong></p><p>如果有负权边，就不能使用迪克斯特拉算法</p><p>可以使用贝尔曼-福德算法(Bellman-Ford algorithm)</p><h3 id="实现">实现</h3><p>需要三个散列表</p><ol><li>一个散列表存储邻居和前往邻居的开销（邻居的散列表包含开销的散列表）</li><li>一个散列表存储每个节点的开销（从起点开始计算🧮），终点默认为无穷大</li><li>一个散列表存储父节点，默认为没有None</li></ol><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0006.png" style="width:60%;height:60%;"/></div></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新最小的节点</span></span><br><span class="line">node = find_lowest_cost_node(costs) </span><br><span class="line"><span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"><span class="comment"># 获取该节点的开销和邻居散列表</span></span><br><span class="line">cost = costs[node] </span><br><span class="line">neighbors = graph[node] </span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> neighbors.keys():</span><br><span class="line"><span class="comment"># 遍历当前节点的所有邻居</span></span><br><span class="line">new_cost = cost + neighbors[n] </span><br><span class="line"><span class="keyword">if</span> costs[node] &gt; new_cost:</span><br><span class="line"><span class="comment"># 如果经当前节点前往该邻居更近，就更新该邻居的开销</span></span><br><span class="line">costs[node] = new_cost</span><br><span class="line"><span class="comment"># 同时将该邻居的父节点设置为当前节点</span></span><br><span class="line">parents[node] = node   </span><br><span class="line">processed.append(node)</span><br><span class="line">node = find_lowest_cost_node(costs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_lowest_cost_node</span>(<span class="params">costs</span>):</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">从costs散列表找出开销最小的节点</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">lowest_cost = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">lowest_cost_node = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> costs:</span><br><span class="line">cost =costs[node]</span><br><span class="line"><span class="keyword">if</span> cost &lt; lowest_cost <span class="keyword">and</span> node <span class="keyword">not</span> <span class="keyword">in</span> processed:</span><br><span class="line"><span class="comment"># 如果当前节点的开销更小且未处理过</span></span><br><span class="line">lowest_cost = cost</span><br><span class="line">lowest_cost_node = node</span><br><span class="line"><span class="keyword">return</span> lowest_cost_node</span><br></pre></td></tr></table></figure><h3 id="练习">练习</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;start&quot;</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;a&quot;</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;b&quot;</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;c&quot;</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;d&quot;</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;start&quot;</span>][<span class="string">&quot;a&quot;</span>] = <span class="number">5</span></span><br><span class="line">graph[<span class="string">&quot;start&quot;</span>][<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line">graph[<span class="string">&quot;a&quot;</span>][<span class="string">&quot;c&quot;</span>] = <span class="number">4</span></span><br><span class="line">graph[<span class="string">&quot;a&quot;</span>][<span class="string">&quot;d&quot;</span>] = <span class="number">2</span></span><br><span class="line">graph[<span class="string">&quot;b&quot;</span>][<span class="string">&quot;a&quot;</span>] = <span class="number">8</span></span><br><span class="line">graph[<span class="string">&quot;b&quot;</span>][<span class="string">&quot;d&quot;</span>] = <span class="number">7</span></span><br><span class="line">graph[<span class="string">&quot;c&quot;</span>][<span class="string">&quot;d&quot;</span>] = <span class="number">6</span></span><br><span class="line">graph[<span class="string">&quot;c&quot;</span>][<span class="string">&quot;fin&quot;</span>] = <span class="number">3</span></span><br><span class="line">graph[<span class="string">&quot;d&quot;</span>][<span class="string">&quot;fin&quot;</span>] = <span class="number">1</span></span><br><span class="line">graph[<span class="string">&quot;fin&quot;</span>] = &#123;&#125;</span><br><span class="line">costs = &#123;&#125;</span><br><span class="line">inf = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">costs[<span class="string">&quot;a&quot;</span>] = <span class="number">5</span></span><br><span class="line">costs[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line">costs[<span class="string">&quot;c&quot;</span>] = inf</span><br><span class="line">costs[<span class="string">&quot;d&quot;</span>] = inf</span><br><span class="line">costs[<span class="string">&quot;fin&quot;</span>] = inf</span><br><span class="line">parents = &#123;&#125;</span><br><span class="line">parents[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;start&quot;</span></span><br><span class="line">parents[<span class="string">&quot;b&quot;</span>] = <span class="string">&quot;start&quot;</span></span><br><span class="line">parents[<span class="string">&quot;fin&quot;</span>] = <span class="literal">None</span></span><br><span class="line">processed = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_lowest_cost_node</span>(<span class="params">costs</span>):</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">从costs散列表找出开销最小的节点</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">lowest_cost = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">lowest_cost_node = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> costs:</span><br><span class="line">cost =costs[node]</span><br><span class="line"><span class="keyword">if</span> cost &lt; lowest_cost <span class="keyword">and</span> node <span class="keyword">not</span> <span class="keyword">in</span> processed:</span><br><span class="line"><span class="comment"># 如果当前节点的开销更小且未处理过</span></span><br><span class="line">lowest_cost = cost</span><br><span class="line">lowest_cost_node = node</span><br><span class="line"><span class="keyword">return</span> lowest_cost_node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新最小的节点</span></span><br><span class="line">node = find_lowest_cost_node(costs) </span><br><span class="line"><span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"><span class="comment"># 获取该节点的开销和邻居散列表</span></span><br><span class="line">cost = costs[node] </span><br><span class="line">neighbors = graph[node] </span><br><span class="line"><span class="keyword">for</span> neighbor_node <span class="keyword">in</span> neighbors.keys():</span><br><span class="line"><span class="comment"># 遍历当前节点的所有邻居</span></span><br><span class="line">new_cost = cost + neighbors[neighbor_node] </span><br><span class="line"><span class="keyword">if</span> costs[neighbor_node] &gt; new_cost:</span><br><span class="line"><span class="comment"># 如果经当前节点前往该邻居更近，就更新该邻居的开销</span></span><br><span class="line">costs[neighbor_node] = new_cost</span><br><span class="line"><span class="comment"># 同时将该邻居的父节点设置为当前节点</span></span><br><span class="line">parents[neighbor_node] = node   </span><br><span class="line">processed.append(node)</span><br><span class="line">node = find_lowest_cost_node(costs)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(costs[<span class="string">&quot;fin&quot;</span>])</span><br></pre></td></tr></table></figure><div class="note info no-icon flat"><p>🌍 <strong>所有东西都要初始化</strong></p></div><hr><h2 id="7-贪婪算法">7.贪婪算法</h2><p>每步都选择局部最优解，最终得到的就是全局最优解</p><p><strong>背包问题🎒</strong></p><p><strong>集合覆盖问题</strong></p><ul><li>近似算法(approximation algorithm)</li><li>选出一个覆盖了最多的未覆盖州的广播台</li><li>重复直到覆盖掉所有州</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">provinces_needed = <span class="built_in">set</span>([<span class="string">&quot;京&quot;</span>,<span class="string">&quot;津&quot;</span>,<span class="string">&quot;冀&quot;</span>,<span class="string">&quot;沪&quot;</span>,<span class="string">&quot;黑&quot;</span>,<span class="string">&quot;琼&quot;</span>,<span class="string">&quot;粤&quot;</span>])</span><br><span class="line">stations = &#123;&#125;</span><br><span class="line">stations[<span class="string">&quot;北京&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;京&quot;</span>,<span class="string">&quot;津&quot;</span>,<span class="string">&quot;冀&quot;</span>])</span><br><span class="line">stations[<span class="string">&quot;天津&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;津&quot;</span>,<span class="string">&quot;冀&quot;</span>,<span class="string">&quot;沪&quot;</span>])</span><br><span class="line">stations[<span class="string">&quot;上海&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;冀&quot;</span>,<span class="string">&quot;沪&quot;</span>,<span class="string">&quot;黑&quot;</span>])</span><br><span class="line">stations[<span class="string">&quot;黑龙江&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;冀&quot;</span>,<span class="string">&quot;黑&quot;</span>,<span class="string">&quot;琼&quot;</span>])</span><br><span class="line">stations[<span class="string">&quot;海南&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;琼&quot;</span>,<span class="string">&quot;粤&quot;</span>])</span><br><span class="line">stations[<span class="string">&quot;广东&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;京&quot;</span>,<span class="string">&quot;沪&quot;</span>,<span class="string">&quot;粤&quot;</span>])</span><br><span class="line">final_stations = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> provinces_needed:</span><br><span class="line">    best_station = <span class="literal">None</span></span><br><span class="line">    states_covered = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> station, states_for_station <span class="keyword">in</span> stations.items():</span><br><span class="line">        covered = provinces_needed &amp; states_for_station</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(covered) &gt; <span class="built_in">len</span>(states_covered):</span><br><span class="line">            best_station = station</span><br><span class="line">            states_covered = covered</span><br><span class="line">    final_stations.add(best_station)</span><br><span class="line">    provinces_needed -= states_covered</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(final_stations)</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note primary no-icon flat"><p>创建集合，一个无序的不重复元素序列，<code>set</code> <code>add</code> <code>remove</code> ，交集&amp;、并集｜、差集-</p></div><h3 id="NP完全问题">NP完全问题</h3><p>需要计算所有的解，并从中选出最小/最短的</p><p>阶乘函数(factorial function)</p><p>NP完全问题的特征</p><ul><li>涉及所有组合的</li><li>必须考虑各种可能的情况</li><li>涉及序列且难以解决</li><li>涉及集合且难以解决</li><li>可转换为旅行商问题</li></ul><hr><h2 id="8-动态规划">8.动态规划</h2><h3 id="背包问题">背包问题</h3><p>简单算法：尝试各种组合，找出价值最高的组合($2^n$)</p><p>动态规划</p><ul><li>先解决子问题，再逐步解决大问题</li><li>都从网格开始<ul><li>各行 为可选择的商品</li><li>各列 为不同容量的背包</li></ul></li></ul><p><strong>吉他行</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0007.png" style="width:85%;height:85%;"/></div></div><p>为了让当前的最大价值最大，在只能偷吉他的情况下，在1、2、3、4磅的背包容量单元格只能填¥1500</p><p><strong>音响行</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0008.png" style="width:85%;height:85%;"/></div></div><p>为了让当前的最大价值最大，在只能偷吉他和音响的情况下，在1、2、3磅的背包容量单元格只能填¥1500，因为音响太重了，在4磅的背包单元格终于可以填音响，更新为¥3000</p><p><strong>笔记本行</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0009.png" style="width:90%;height:90%;"/></div></div><p>笔记本较重，3磅的背包容量单元格可以装下笔记本，更新为¥2000</p><p><img src="../img/%E7%AE%97%E6%B3%95/0010.png" alt="Untitled"></p><p>在4磅1的背包容量单元格可以同时装下吉他和笔记本，更新为¥3500</p><p><strong>总结</strong></p><p><img src="../img/%E7%AE%97%E6%B3%95/0011.png" alt="Untitled"></p><ul><li>沿着一列往下走时，最大价值不可能降低</li><li>行的排列顺序与结果无关</li><li>逐行or逐列排序都没有关系</li><li>增加一件更小的商品会增加颗粒度，必须调整网络</li><li>不可以偷商品的一部分</li><li>旅游行程最优化可以使用背包问题</li></ul><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0012.png" style="width:85%;height:85%;"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0013.png" style="width:85%;height:85%;"/></div></div><div class="note info no-icon flat"><p>但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用</p></div><h3 id="最长公共子串">最长公共子串</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0014.png" style="width:80%;height:80%;"/></div></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> word_a[i] == word_b[j]: <span class="comment"># 如果相同设为左上角+1</span></span><br><span class="line">cell[i][j] = cell[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 如果不同设为0</span></span><br><span class="line">cell[i][j] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>答案为网格中最大的数字</strong></p><h3 id="最长公共子序列">最长公共子序列</h3><p><img src="../img/%E7%AE%97%E6%B3%95/0015.png" alt="Untitled"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> word_a[i] == word_b[j]: <span class="comment"># 如果相同设为左上角+1</span></span><br><span class="line">cell[i][j] = cell[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 如果不同设为0</span></span><br><span class="line">cell[i][j] = <span class="built_in">max</span>(cell[i-<span class="number">1</span>][j],cell[i][j-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><hr><h2 id="9-K最近邻算法">9.K最近邻算法</h2><p>k-nearest neighbors, KNN</p><ol><li>对水果进行分类，比如哈密瓜🍈和西瓜🍉中有一个神秘的水果</li><li>查看它三个最近的邻居</li><li>在这些邻居中，哈密瓜🍈数量多于西瓜🍉，因此很可能是哈密瓜</li></ol><h3 id="创建推荐系统">创建推荐系统</h3><p><strong>特征抽取</strong></p><p>计算两点的距离可以用毕达哥斯拉公式</p><p>$$<br>\sqrt{ \left( x_{1}-x_{2}\right) ^{2}+ \left (y_{1}-y_{2}\right)^{2} }<br>$$</p><p><strong>余弦相似度</strong></p><p>余弦相似度的取值范围从-1到1：</p><ul><li>1 表示向量完全相同（指向同一方向）</li><li>0 表示向量正交（完全不同）</li><li>1 表示向量完全相反（指向相反方向）</li></ul><p><strong>计算公式</strong></p><p>对于两个向量 <strong>A</strong> 和 <strong>B</strong>，余弦相似度cosine(<strong>A</strong>,<strong>B</strong>) 定义为：</p><p>$\text{cosine}(\mathbf{A}, \mathbf{B}) = \frac{\mathbf{A} \cdot \mathbf{B}}{|\mathbf{A}| |\mathbf{B}|}$</p><p>其中：</p><ul><li><strong>A</strong>⋅<strong>B</strong> 是向量 <strong>A</strong> 和 <strong>B</strong> 的点积（内积）</li><li>∥<strong>A</strong>∥ 和 ∥<strong>B</strong>∥ 分别是向量 <strong>A</strong> 和 <strong>B</strong> 的欧几里得范数（长度）</li></ul><p>$\text{cosine}(\mathbf{A}, \mathbf{B}) = \frac{\sum_{i=1}^{n} a_i \cdot b_i}{\sqrt{\sum_{i=1}^{n} a_i^2} \cdot \sqrt{\sum_{i=1}^{n} b_i^2}}$</p><p><strong>实例</strong></p><p>假设有两个向量A=[a1,a2,a3]和B=[b1,b2,b3]，它们的余弦相似度计算如下：</p><p>$\text{cosine}(\mathbf{A}, \mathbf{B}) = \frac{a_1 b_1 + a_2 b_2 + a_3 b_3}{\sqrt{a_1^2 + a_2^2 + a_3^2} \cdot \sqrt{b_1^2 + b_2^2 + b_3^2}}$。</p><p>若是评价标准不同呢？</p><p>可使用归一化(normalization)。你可计算每位用户的平均评分，并据此来调整用户的评分</p><p><strong>回归</strong></p><p>就是根据已有数据预测结果（如一个数字）</p><div class="note warning no-icon flat"><p>🏆 <strong>KNN — 分类和回归</strong></p></div><p>建议根据sqrt(n)来推荐</p><h3 id="机器学习简介">机器学习简介</h3><p><strong>OCR(optical character recognition)，光学字符识别</strong></p><ol><li>浏览大量的数字图像，提取特征（线段、点、曲线等）</li><li>遇到新图像时，提取该特征并找出最近的邻居都是谁</li></ol><p><strong>创建垃圾邮件过滤器</strong></p><p>朴素贝叶斯分类器(Naive Bayes classifier)</p><p>假设特征之间相互独立</p><p>$P(A|B) = \frac{P(B|A) \cdot P(A)}{P(B)}$</p><p>$y = \arg\max_{C_i} P(C_i|X) = \arg\max_{C_i} \frac{P(X|C_i) \cdot P(C_i)}{P(X)}$</p><p><strong>预测股票情绪</strong></p><p>几乎不可能</p><hr><h2 id="10-总结">10.总结</h2><ul><li>第一章<ul><li>二分查找的速度比简单查找快得多</li><li>O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多</li><li>算法运行时间并不以秒为单位</li><li>算法运行时间是从其增速的角度度量的</li><li>算法运行时间用大O表示法表示</li></ul></li><li>第二章<ul><li>计算机内存犹如一大堆抽屉</li><li>需要存储多个元素时，可使用数组或链表</li><li>数组的元素都在一起</li><li>链表的元素是分开的，其中每个元素都存储了下一个元素的地址</li><li>数组的读取速度很快</li><li>链表的插入和删除速度很快</li><li>在同一个数组中，所有元素的类型都必须相同(都为int、double等)</li></ul></li><li>第三章<ul><li>递归指的是调用自己的函数</li><li>每个递归函数都有两个条件:基线条件和递归条件</li><li>栈有两种操作:压入和弹出</li><li>所有函数调用都进入调用栈</li><li>调用栈可能很长，这将占用大量的内存</li><li>每次递归会创建新的栈帧，循环始终使用一个栈帧</li></ul></li><li>第四章<ul><li>D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元素的数组</li><li>实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O（n logn）</li><li>大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在</li><li>比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O（log n）的速度比O（n）快得多</li></ul></li><li>第五章<ul><li>你可以结合散列函数和数组来创建散列表</li><li>冲突很糟糕，你应使用可以最大限度减少冲突的散列函数</li><li>散列表的查找、插入和删除速度都非常快</li><li>散列表适合用于模拟映射关系</li><li>一旦填装因子超过0.7，就该调整散列表的长度</li><li>散列表可用于缓存数据（例如，在Web服务器上）</li><li>散列表非常适合用于防止重复</li></ul></li><li>第六章<ul><li>广度优先搜索指出是否有从A到B的路径</li><li>如果有，广度优先搜索将找出最短路径</li><li>面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来解决问题</li><li>有向图中的边为箭头，箭头的方向指定了关系的方向，例如，rama radit表示rama欠adit钱</li><li>无向图中的边不带箭头，其中的关系是双向的，例如，ross - rachel表示 “ross 与rachel约会，而rachel也与ross约会”</li><li>队列是先进先出（FIFO）的。</li><li>栈是后进先出（LIFO）的。</li><li>你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列</li><li>对于检查过的人，务必不要再去检查，否则可能导致无限循环</li></ul></li><li>第七章<ul><li>广度优先搜索用于在非加权图中查找最短路径</li><li>迪克斯特拉算法用于在加权图中查找最短路径</li><li>仅当权重为正时狄克斯特拉算法才管用</li><li>如果图中包含负权边，请使用贝尔曼-福德算法</li></ul></li><li>第八章<ul><li>贪婪算法寻找局部最优解，企图以这种方式获得全局最优解</li><li>对于NP完全问题，还没有找到快速解决方案</li><li>面临NP完全问题时，最佳的做法是使用近似算法</li><li>贪婪算法易于实现、运行速度快，是不错的近似算法</li></ul></li><li>第九章<ul><li>需要在给定约束条件下优化某种指标时，动态规划很有用</li><li>问题可分解为离散子问题时，可使用动态规划来解决</li><li>每种动态规划解决方案都涉及网格</li><li>单元格中的值通常就是你要优化的值</li><li>每个单元格都是一个子问题，因此你需要考虑将问题分解为子问题</li><li>没有放之四海皆准的计算动态规划解决方案的公式</li></ul></li><li>第十章<ul><li>KNN用于分类和回归，需要考虑最近的邻居</li><li>分类就是编组</li><li>回归就是预测结果(如数字)</li><li>特征抽取意味着将物品(如水果或用户)转换为一系列可比较的数字</li><li>能否挑选合适的特征事关KNN算法的成败</li></ul></li></ul><hr>]]></content>
    
    
    <summary type="html">入门的第一本算法书</summary>
    
    
    
    <category term="编程学习" scheme="https://agoni66.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="算法" scheme="https://agoni66.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（六）</title>
    <link href="https://agoni66.github.io/posts/1000106.html"/>
    <id>https://agoni66.github.io/posts/1000106.html</id>
    <published>2024-06-04T08:30:00.000Z</published>
    <updated>2024-09-10T01:17:25.989Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><p><font size="4"><b>计算机网络导航🚀🚀🚀</b></font></p><ol><li><p>🍕<a href="https://agoni66.github.io/posts/1000101.html">第一章 概述</a></p></li><li><p>🍔<a href="https://agoni66.github.io/posts/1000102.html">第二章 物理层</a></p></li><li><p>🍟<a href="https://agoni66.github.io/posts/1000103.html">第三章 数据链路层</a></p></li><li><p>🌭<a href="https://agoni66.github.io/posts/1000104.html">第四章 网际层</a></p></li><li><p>🍿<a href="https://agoni66.github.io/posts/1000105.html">第五章 运输层</a></p></li><li><p>🧂<a href="https://agoni66.github.io/posts/1000106.html">第六章 应用层</a> ⇦ 当前位置🪂</p></li></ol></div><div class="note warning modern"><p><b>图片加载较慢，请耐心等待！🌤️🌥️🌦️</b></p></div><h2 id="应用层概述">应用层概述</h2><p>应用层是计算机网络体系结构的<strong>最顶层</strong>，是<strong>设计和建立计算机网络的最终目的</strong>，也是计算机网络中发展最快的部分</p><h2 id="知识点一：客户-服务器方式（C-S方式）和对等方式（P2P方式）">知识点一：客户/服务器方式（C/S方式）和对等方式（P2P方式）</h2><p>开发一种新的网络应用首先要考虑的问题就是<strong>网络应用程序在各种端系统上的组织方式和它们之间的关系</strong></p><p>目前流行的主要有以下两种：</p><div class="note danger no-icon flat"><p>📏 <strong>客户/服务器(Client/Server，C/S)方式</strong></p></div><ul><li>客户和服务器是指通信中所涉及的两个应用进程</li><li>客户/服务器方式所描述的是进程之间服务和被服务的关系</li><li>客户是服务请求方，服务器是服务提供方</li><li>服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号(例如HTTP服务器的默认端口号为80)，而运行服务器的主机也具有固定的IP地址</li><li>基于C/S方式的应用服务通常是 <strong><code>服务集中型</code></strong> 的，即应用服务集中在网络中比客户计算机少得多的服务器计算机上<ul><li>由于一台服务器计算机要为多个客户机提供服务，在C/S应用中，<strong>常会出现服务器计算机跟不上众多客户机请求的情况</strong></li><li>为此，在C/S应用中，常用<strong>计算机群集</strong>(或服务器场)构建一个强大的虚拟服务器</li></ul></li></ul><div class="note danger no-icon flat"><p>📏 <strong>对等(Peer-to-Peer，P2P)方式</strong></p></div><p>在P2P方式中，<strong>没有固定的服务请求者和服务提供者</strong>，分布在网络边缘各端系统中的应用进程是对等的，被称为<strong>对等方</strong>。<strong>对等方相互之间直接通信</strong>，每个对等方既是服务的请求者，又是服务的提供者。</p><ul><li>基于P2P的应用是 <strong><code>服务分散型</code></strong> 的，因为服务不是集中在少数几个服务器计算机中，而是分散在大量对等计算机中，这些计算机并不为服务提供商所有，而是为个人控制的桌面计算机和笔记本电脑，它们通常位于住宅、校园和办公室中</li><li>P2P方式的最突出特性之一就是它的<strong>可扩展性</strong>。因为系统每增加一个对等方，不仅增加的是服务的请求者，同时也增加了服务的提供者，系统性能不会因规模的增大而降低</li><li>P2P方式<strong>具有成本上的优势</strong>，因为它通常不需要庞大的服务器设施和服务器带宽。为了降低成本，服务提供商对于将P2P方式用于应用的兴趣越来越大</li></ul><hr><h2 id="✨知识点二：动态主机配置协议DHCP">✨知识点二：动态主机配置协议DHCP</h2><p>互联网广泛使用的 <strong><code>动态主机配置协议 DHCP</code></strong> (Dynamic Host Configuration Protocol) 提供了 <strong><code>即插即用</code></strong> 连网 (plug-and-play networking) 的机制</p><p>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置</p><h3 id="DHCP-使用客户-服务器方式"><strong>DHCP 使用客户 - 服务器方式</strong></h3><ul><li>需要 IP 地址的主机在启动时就向 DHCP 服务器<strong>广播</strong>发送发现报文 （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但<strong>只有 DHCP 服务器才回答此广播报文</strong></li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）</li></ul><h3 id="DHCP-工作方式"><strong>DHCP 工作方式</strong></h3><ul><li>DHCP 使用客户-服务器方式，采用请求/应答方式工作。</li><li>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），<strong>DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口</strong></li></ul><h3 id="DHCP交互过程"><strong>DHCP交互过程</strong></h3><ol><li>DHCP客户端将 <strong><code>广播发送DHCP发现报文</code></strong>（DHCP DISCOVER）<ul><li>事务ID</li><li>DHCP客户端的MAC地址</li></ul></li></ol><ul><li><strong>封装该报文的IP数据报的源IP地址为0.0.0.0</strong>，这是因为主机目前还未分配到IP地址，因此使用该地址代替</li><li><strong>目的IP地址为广播地址255.255.255.255</strong>，之所以广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器。它们的IP地址各是什么</li><li>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送</li></ul><ol start="2"><li>DHCP服务端将 <strong><code>广播发送DHCP提供报文</code>（DHCP OFFER）</strong><ul><li>事务ID：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的</li><li>配置信息<ul><li>IP地址：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址（使用ARP来确保所选IP地址未被网络中其他主机占用）</li><li>子网掩码</li><li>地址租期</li><li>默认网关</li><li>DNS服务器</li></ul></li></ul></li><li><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong><ul><li>事务ID</li><li>DHCP客户端的MAC地址</li><li>接收的租约中的IP地址</li><li>提供此租约的DHCP服务器端的IP地址</li><li>源地址：0.0.0.0，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器。它首先要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址</li><li>目的地址：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器</li></ul></li></ol><p>DHCP客户收到该报文后就可以使用租用的IP地址</p><p>在使用前还会 <strong><code>进行ARP检测</code></strong></p><p>使用ARP检测所分配到的IP地址是否已被网络中其他主机占用</p><ul><li>若被占用：给DHCP服务器发送“DHCPDECLINE”报文撤销IP地址租约，并重新发送“DHCP DISCOVER”报文</li><li>若未被占用：可以使用租约中的IP地址与网络中其他主机通信了</li></ul><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5200.png" alt="Untitled"></p><h3 id="DHCP中继代理"><strong>DHCP中继代理</strong></h3><p>给该路由器配置DHCP服务器的IP地址并使之成为DHCP中继代理</p><p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p><hr><h2 id="✨知识点三：域名系统DNS">✨知识点三：域名系统DNS</h2><p>因特网采用层<strong>次树状结构的域名结构</strong></p><p>域名的结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名</p><p>.三级域名.二级域名.顶级域名</p><p>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母。</p><p>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边。</p><p>完整的域名不超过255个字符</p><p>域名系统既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。</p><p>各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理</p><p><strong>顶级域名TLD</strong>(Top Level Domain)分为以下三类：</p><table><thead><tr><th>国家顶级域名nTLD</th><th>采用IS03166的规定。如cn表示中国，us表示美国，uk表示英国、等等</th></tr></thead><tbody><tr><td>通用顶级域名gTLD</td><td>最常见的通用顶级域名有七个，即:com(公司企业net(网络服务机美国教育结构)、构)、org(非营利性组织)、int(国际组织)、edugov(美国政府部门)、mil(美国军事部门)</td></tr><tr><td>反向域arpa</td><td>用于反向域名解析，即IP地址反向解析为域名。</td></tr></tbody></table><p>在<strong>国家顶级域名下注册的二级域名均由该国家自行确定</strong>。例如，顶级域名为jp的日本将其教育和企业机构的二级域名定为ac和co，而不用edu和com</p><p>我国则将<strong>二级域名划分为以下两类</strong>：</p><table><thead><tr><th>类别域名</th><th>共七个:ac(科研机构)om(工、商、金融等企业)、edu(教育机构)gov(政府部门)、net(提供网络服务的机构)、mil(军事机构)和org(非营利性组织)。</th></tr></thead><tbody><tr><td>行政区域名</td><td>共34个，适用于我国的各省、自治区、直辖市。例如:bj为北京市、sh为上海市、js为江苏省，等等。</td></tr></tbody></table><p>注意：名称相同的域名其等级未必相同</p><p><strong><span class='p h3 blue'>域名解析过程</span></strong></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5300.png" alt="Untitled"></p><p>为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了<strong>高速缓存</strong>。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p><p>由于域名到IP地址的映射关系并不是永久不变，为保持高速缓存中的内容正确，域名服务器<strong>应为每项内容设置计时器并删除超过合理时间的项</strong>(例如，每个项目只存放两天)。</p><p>不但在本地域名服务器中需要高速缓存，在用户主机中也很需要。许多用户主机在启动时从本地域名服务器下载域名和IP地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到域名时才向域名服务器查询。同理，主机也需要保持高速缓存中内容的正确性</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5301.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5302.png" alt="Untitled"></p><hr><h2 id="✨知识点四：文件传送协议FTP">✨知识点四：文件传送协议FTP</h2><p><strong><code>文件传送协议FTP</code></strong>(File Transfer Protocol)是因特网上使用得最广泛的文件传送协议。</p><ul><li>FTP提供<strong>交互式的访问</strong>，允许客户<strong>指明文件的类型与格式</strong>(如指明是否使用ASCI码)，并允许<strong>文件具有存取权限</strong>(如访问文件的用户必须经过授权，并输入有效的口令)</li><li><strong>FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件</strong></li></ul><p><strong><span class='p h3 blue'>基本工作原理</span></strong></p><p><strong><code>主动模式</code></strong> 就是客户告诉服务器我要喝茶 把杯子放好  倒水 喝完 拿走 再喝的话 再拿来 喝完再拿走</p><p><strong><code>被动连接</code></strong> 就是客户你要喝茶自己端着杯子过来 我给你茶水 喝完拿走杯子 再喝 再过来</p><p>控制连接与数据连接</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5400.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5401.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5402.png" alt="Untitled"></p><hr><h2 id="✨知识点五：电子邮件">✨知识点五：电子邮件</h2><p>电子邮件系统采用 <strong><code>客户/服务器方式</code></strong></p><p>电子邮件系统的三个主要组成构件</p><p><strong><code>用户代理</code>， <code>邮件服务器</code>，以及 <code>电子邮件所需的协议</code></strong></p><ul><li><strong>用户代理</strong>是用户与电子邮件系统的接口，又称为<strong>电子邮件客户端软件</strong></li><li><strong>邮件服务器</strong>是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是<strong>发送和接收邮件</strong>，同时还要负责维护用户的邮箱</li><li><strong>协议</strong>包括<strong>邮件发送协议</strong>(例如SMTP)和<strong>邮件读取协议</strong>(例如POP3，IMAP)</li></ul><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5500.png" alt="Untitled"></p><h3 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理"><strong>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理</strong></h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5501.png" alt="Untitled"></p><p><strong>14条SMTP命令</strong></p><p><strong>21种SMTP应答</strong></p><p>有什么就答什么，我爱说实话</p><h3 id="电子邮件的信息格式"><strong>电子邮件的信息格式</strong></h3><ul><li>电子邮件的信息格式并不是由SMTP定义的，而是在RFC822中单独定义的。这个RFC文档已在2008年更新为RFC 5322。一个电子邮件有 <strong><code>信封和内容</code>两部分</strong>。而内容又由 <strong><code>首部和主体</code>两部分构成</strong>。</li><li><strong>SMTP协议只能传送 <code>ASCII码</code>文本数据</strong>，不能传送可执行文件或其他的二进制对象</li><li>SMTP不能满足传送多媒体邮件(例如带有图片、音频或视频数据)的需要。并且许多其他非英语国家的文字(例如中文、俄文、甚至带有重音符号的法文或德文)也无法用SMTP传送</li><li>为解决SMTP传送非ASCII码文本的问题，提出了<strong>多用途因特网邮件扩展MIME</strong>(MulipurposeIntemetMai Extensions)。<ul><li>增加了<strong>5个新的邮件首部字段</strong>，这些字段提供了有关邮件主体的信息。</li><li>定义了<strong>许多邮件内容的格式</strong>，对多媒体电子邮件的表示方法进行了标准化。</li><li>定义了<strong>传送编码</strong>，可对任何内容格式进行转换，而不会被邮件系统改变</li></ul></li><li>实际上，MIME不积极用于SMTP，也用于面向ASCII字符的HTTP</li></ul><h3 id="邮件读取"><strong>邮件读取</strong></h3><ul><li><strong><code>邮局协议POP</code></strong> (Post0ffice Protocol)，POP3是其第三个版本，是<strong>因特网正式标准</strong>。非常简单、功能有限的邮件读取协议。用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机。不允许用户在邮件服务器上管理自己的邮件。(例如创建文件夹，对邮件进行分类管理等)。</li><li><strong><code>因特网邮件访问协议IMAP</code></strong> (IntermetMessage Access Protocol)，IMAP4是其第四个版本，目前还只是因特网建议标准。功能比POP3强大的邮件读取协议。用户在自己的计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此IMAP是一个联机协议。</li><li>POP3和IMAP4都采用 <strong><code>基于TCP连接的客户/服务器方式</code></strong>。POP3使用熟知端口110，IMAP4使用熟知端口143。</li></ul><h3 id="基于万维网的电子邮件"><strong>基于万维网的电子邮件</strong></h3><p>通过<strong>浏览器登录</strong>(提供用户名和口令)邮件服务器万维网网站就可以撰写、收发、阅读和管理电子邮件。这种工作模式与IMAP很类似，不同的是用户计算机无需安装专门的用户代理程序，只需要使用通用的万维网浏览器。</p><p>邮件服务器网站通常都提供非常强大和方便的邮件管理功能，用户可以在邮件服务器网站上管理和处理自己的邮件，而不需要将邮件下载到本地进行管理。</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5502.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5503.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5504.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5505.png" alt="Untitled"></p><hr><h2 id="✨知识点六：万维网">✨知识点六：万维网</h2><ul><li>万维网 WWW (World Wide Web) 并非某种特殊的计算机网络。</li><li>万维网是一个大规模的、联机式的<strong>信息储藏所</strong>。</li><li>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li><li>这种访问方式称为“<strong>链接</strong>”。</li><li>万维网以<strong>客户 - 服务器</strong>方式工作。</li><li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。</li><li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)</li><li>浏览器最重要的部分是<strong>渲染引擎</strong>，也就是<strong>浏览器内核</strong>。负责对网页内容进行解析和显示。</li></ul><h3 id="URL"><strong>URL</strong></h3><p>为了方便地访问在世界范围的文档，万维网使用 <strong><code>统一资源定位符URL</code></strong> 来指明因特网上任何种类“资源”的位置。URL的一般形式由以下四个部分组成:</p><div class="note info no-icon flat"><p>🌐 <strong>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</strong></p></div><h3 id="超文本传输协议HTTP（Hyper-Transfer-Protocol）"><strong>超文本传输协议HTTP（Hyper Transfer Protocol）</strong></h3><ol><li>每个万维网网点都有一个服务器进程，它不断地 <strong><code>监听 TCP 的端口 80</code></strong>，以便发现是否有浏览器向它发出连接建立请求。</li><li>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。</li><li>最后，TCP 连接就被释放了</li></ol><h3 id="HTTP的报文格式"><strong>HTTP的报文格式</strong></h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5600.png" alt="Untitled"></p><h3 id="使用Cookie在服务器上记录用户信息"><strong>使用Cookie在服务器上记录用户信息</strong></h3><p>早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态的文档。因此HTTP被设计为一种 <strong><code>无状态</code></strong> 的协议。这样可以简化服务器的设计</p><p>现在，用户可以通过万维网实现各种复杂的应用，如网上购物、电子商务等。这些应用往往需要万维网服务器能够识别用户</p><p>Cookie提供了一种机制使得万维网服务器能够“记住”用户，而无需用户主动提供用户标识信息。也就是<strong>Cookie是一种对无状态的HTTP进行状态化的技术</strong></p><h3 id="万维网缓存与代理服务器"><strong>万维网缓存与代理服务器</strong></h3><p>在万维网中还可以使用缓存机制以提高万维网的效率。</p><p>万维网缓存又称为<strong>Web缓存</strong>(WebCache)，可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为<strong>代理服务器</strong>(ProxyServer)。</p><p>Web缓存把最近的一些请求和响应暂存在本地磁盘中。<strong>当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源</strong>。</p><p>若WEb缓存的命中率比较高</p><p>则会大大减小了该链路上的通信量，因而减少了访问因特网的时延</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5601.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5602.png" alt="Untitled"></p><hr>]]></content>
    
    
    <summary type="html">计网</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="计算机网络" scheme="https://agoni66.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="四大件" scheme="https://agoni66.github.io/tags/%E5%9B%9B%E5%A4%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（五）</title>
    <link href="https://agoni66.github.io/posts/1000105.html"/>
    <id>https://agoni66.github.io/posts/1000105.html</id>
    <published>2024-06-04T04:30:00.000Z</published>
    <updated>2024-09-10T01:17:51.918Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><p><font size="4"><b>计算机网络导航🚀🚀🚀</b></font></p><ol><li><p>🍕<a href="https://agoni66.github.io/posts/1000101.html">第一章 概述</a></p></li><li><p>🍔<a href="https://agoni66.github.io/posts/1000102.html">第二章 物理层</a></p></li><li><p>🍟<a href="https://agoni66.github.io/posts/1000103.html">第三章 数据链路层</a></p></li><li><p>🌭<a href="https://agoni66.github.io/posts/1000104.html">第四章 网际层</a></p></li><li><p>🍿<a href="https://agoni66.github.io/posts/1000105.html">第五章 运输层</a> ⇦ 当前位置🪂</p></li><li><p>🧂<a href="https://agoni66.github.io/posts/1000106.html">第六章 应用层</a></p></li></ol></div><div class="note warning modern"><p><b>图片加载较慢，请耐心等待！🌤️🌥️🌦️</b></p></div><h2 id="运输层概述">运输层概述</h2><ul><li>之前课程所介绍的计算机网络体系结构中的物理层、数据链路层以及网络层它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了 <strong><code>主机到主机的通信</code></strong></li><li>但实际上在计算机网络中进行通信的真正实体是位于 <strong><code>通信两端主机中的进程</code></strong></li><li><strong>如何为运行在不同主机上的应用进程提供直接的通信服务</strong>是运输层的任务，运输层协议又称为<strong>端到端协议</strong></li><li>运输层向高层用户屏蔽了下面网络核心的细节(如网络拓扑、所采用的路由选择协议等)，它使应用进程看见的就<strong>好像是在两个运输层实体之间有一条端到端的逻辑通信信道</strong></li><li>根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即 <strong><code>面向连接的TCP</code>和 <code>无连接的UDP</code></strong>，这两种协议就是本章要讨论的主要内容</li></ul><h2 id="知识点一：运输层端口号、复用与分用的概念">知识点一：运输层端口号、复用与分用的概念</h2><ul><li>运行在计算机上的进程使用 <strong><code>进程标识符PID</code></strong> 来标志:</li><li>因特网上的计算机并不是使用统一的操作系统，不同的操作系统(windows，Linux，MacOS)又使用<strong>不同格式的进程标识符</strong></li><li>为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须<strong>使用统一的方法对TCP/IP体系的应用进程进行标识</strong></li><li>TCP/IP体系的运输层使用 <strong><code>端口号</code></strong> 来区分应用层的不同应用进程</li><li>端口号使用16比特表示，取值范围 <strong><code>0~65535</code></strong>：<ul><li><strong><code>熟知端口号</code></strong> 0 ~1023，IANA把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，例如:FTP使用21/20，HTTP使用80，DNS使用53</li><li><strong><code>登记端口号</code></strong> 1024~49151，为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。例如:Microsoft RDP微软远程桌面使用的端口是3389</li><li><strong><code>短暂端口号</code></strong> 49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用</li></ul></li><li><strong>端口号只具有本地意义</strong>，即端口号只是为了<strong>标识本计算机应用层中的各进程</strong>，在因特网中<strong>不同计算机中的相同端口号是没有联系的</strong></li></ul><hr><h3 id="TCP-IP体系的应用层常用协议所使用的运输层熟知端口号"><strong>TCP/IP体系的应用层常用协议所使用的运输层熟知端口号</strong></h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4100.png" alt="Untitled"></p><h3 id="运输层传输流程"><strong>运输层传输流程</strong></h3><p><strong>举例</strong></p><ol><li>在浏览器输入域名，回车浏览</li><li>然后<strong>用户PC</strong>中的DNS客户端进程会发送一个<strong>DNS查询请求报文</strong><ul><li>DNS查询请求报文需要使用运输层的UDP协议</li><li>首部中的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程</li><li>首部中的目的端口字段的值：53，是<strong>DNS服务器端</strong>进程所使用的熟知端口号</li></ul></li><li>之后，<strong>用户PC</strong>将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器</li><li><strong>DNS服务器</strong>收到该IP数据报后，从中解封出UDP用户数据报<ul><li>UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程</li><li>DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找<strong>对应的IP地址</strong></li><li>之后，会给用户PC发送<strong>DNS响应报文</strong>，DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报</li><li>其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报，目的端口的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号</li></ul></li><li><strong>DNS服务器</strong>将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC</li><li>用户PC收到该数据报后，从中解封出UDP用户数据报<ul><li>UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS响应报文，交付给用户PC中的DNS客户端进程</li><li>DNS客户端进程解析DNS响应报文的内容，就可知道自己之前<strong>所请求的Web服务器的域名对应的IP地址</strong></li></ul></li><li><strong>现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文（和DNS发送和接收流程差不多）</strong></li></ol><hr><h2 id="✨知识点二：UDP和TCP的对比">✨知识点二：UDP和TCP的对比</h2><table><thead><tr><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>无连接</td><td>面向连接</td></tr><tr><td>支持一对一，一对多，多对一和多对多交互通信</td><td>每一条TCP连接只能有两个端点EP，只能是一对一通信</td></tr><tr><td>对应用层交付的报文直接打包</td><td>面向字节流</td></tr><tr><td>尽最大努力交付，也就是不可靠；不使用流量控制和拥塞控制</td><td>可靠传输，使用流量控制和拥塞控制</td></tr><tr><td>首部开销小，仅8字节</td><td>首部最小20字节，最大60字节</td></tr></tbody></table><p>两个对等运输实体在通信时传送的数据单位叫作 <strong><code>运输协议数据单元 TPDU</code></strong> (Transport Protocol Data Unit)。</p><ul><li>TCP 传送的数据单位协议是  <strong><code>TCP 报文段</code></strong>(segment)。</li><li>UDP 传送的数据单位协议是  <strong><code>UDP 报文或用户数据报</code></strong></li><li>UDP的通信是无连接的，<strong>不需要套接字</strong>（Socket）</li><li>TCP是面向连接的，TCP之间的通信必须要<strong>在两个套接字</strong>（Socket）之间<strong>建立连接</strong></li></ul><h3 id="TCP报文段运输过程"><strong>TCP报文段运输过程</strong></h3><p><strong>发送方</strong></p><ul><li>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，TCP并不知道这些待传送的字节流的含义</li><li>并将他们编号，并存储在自己发送缓存中</li><li>TCP会根据发送策略，提取一定量的字节构建TCP报文并发送</li></ul><p><strong>接收方</strong></p><ul><li>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</li><li>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</li><li>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</li></ul><hr><h2 id="✨知识点三：TCP的流量控制">✨知识点三：TCP的流量控制</h2><h3 id="引入"><strong>引入</strong></h3><p>一般来说，我们总是希望数据传输得更快一些。</p><p>但如果发送方把数据<strong>发送得过快，接收方就可能来不及接收，这就会造成数据的丢失</strong></p><p>所谓<strong>流量控制</strong>(flow control)就是让<strong>发送方的发送速率不要太快，要让接收方来得及接收</strong></p><p>利用<strong>滑动窗口</strong>机制可以很方便地在TCP连接上实现对发送方的流量控制</p><p>TCP接收方利用自己的<strong>接收窗口</strong>的大小来限制发送方发送窗口的大小</p><p>TCP发送方收到接收方的<strong>零窗口通知</strong>后，应<strong>启动持续计时器</strong>。持续计时器超时后，向接收方发送<strong>零窗口探测报文</strong></p><h3 id="举例">举例</h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4300.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4301.png" alt="Untitled"></p><p>如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面</p><p>因为 <strong><code>零窗口探测报文段也有重传计时器</code></strong>，重传计时器超时后，零窗口探测报文段会被重传</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4302.png" alt="Untitled"></p><hr><h2 id="✨知识点四：TCP的拥塞控制">✨知识点四：TCP的拥塞控制</h2><p>在某段时间，若<strong>对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏</strong>。这种情况就叫做 <strong><code>拥塞</code></strong> (congestion)</p><p>在计算机网络中的链路容量(即带宽)、交换结点中的缓存和处理机等，都是网络的<strong>资源</strong></p><p>若<strong>出现拥塞而不进行控制</strong>，整个网络的<strong>吞吐量将随输入负荷的增大而下降</strong></p><h3 id="网络拥塞往往是由许多因素引起的"><strong>网络拥塞往往是由许多因素引起的</strong></h3><p>例如：</p><ol><li>点缓存的容量太小</li><li>链路的容量不足</li><li>处理机处理的速率太慢</li><li>拥塞本身会进一步加剧拥塞</li></ol><h3 id="监测网络的拥塞"><strong>监测网络的拥塞</strong></h3><p>主要指标有：</p><ol><li>由于缺少缓存空间而被丢弃的分组的百分数</li><li>平均队列长度</li><li>超时重传的分组数</li><li>平均分组时延</li><li>分组时延的标准差，等等</li></ol><p>上述这些指标的上升都标志着拥塞的增长</p><h3 id="拥塞控制的算法"><strong>拥塞控制的算法</strong></h3><p>发送方维护一个叫做<strong>拥塞窗口cwnd</strong>的状态变量，其值取决于<strong>网络的拥塞程度</strong>，并且<strong>动态变化</strong></p><ul><li>拥塞窗口cwnd的<strong>维护原则</strong>：只要网络没有出现拥塞，<strong>拥塞窗口就再增大一些</strong>；但只要网络出现拥塞，拥塞窗口就减少一些</li><li>判断出现网络拥塞的依据:没有按时收到应当到达的确认报文(即发生超时重传)</li></ul><p><strong>发送方</strong>将拥塞窗口作为<strong>发送窗口swnd</strong>，即<strong>swnd=cwnd</strong></p><p>维护一个<strong>慢开始门限ssthresh状态变量</strong>（防止拥塞窗口增长过大引起网络拥塞）</p><ul><li>当cwnd&lt;ssthresh时，使用<strong>慢开始算法</strong></li><li>当cwnd&gt;ssthresh时，停止使用慢开始算法而改用<strong>拥塞避免算法</strong></li><li>当cwnd =ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法</li></ul><div class="note danger no-icon flat"><p>🌐 <strong>真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值)</strong></p></div><p><strong>传输轮次：</strong></p><ol><li>发送方给接收方发送数据报文段后，接收方给发送方发发回相应的确认报文段</li><li>一个传输轮次所经历的时间其实就是往返时间，往返时间并非是恒定的数值</li><li>使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并受到了对已发送的最后一个报文段的确认</li></ol><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4400.png" alt="Untitled"></p><h3 id="慢开始（slow-start）"><strong>慢开始（slow-start）</strong></h3><p>每经过一个传输轮次，拥塞窗口就加倍</p><h3 id="拥塞避免（congestion-avoidance）"><strong>拥塞避免（congestion avoidance）</strong></h3><p>每经过一个传输轮次，拥塞窗口 cwnd =<br>cwnd + 1</p><h3 id="快重传（fast-retrasmit）"><strong>快重传（fast retrasmit）</strong></h3><ul><li>要求接收方不要等待自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong></li><li>即使收到了失序的报文段也要立即发出对已收到的报文段的<strong>重复确认</strong></li><li>发送方一旦<strong>收到3个连续的重复确认</strong>，就将相应的报文段<strong>立即重传</strong>，而不是等该报文段的超时重传计时器超时再重传</li></ul><h3 id="快恢复（fast-recovery）"><strong>快恢复（fast recovery）</strong></h3><p>发送方一旦<strong>收到3个重复确认</strong>，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而执行<strong>快恢复算法</strong></p><p><strong>发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半</strong></p><p><strong>开始执行拥塞避免算法</strong></p><ul><li>也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh+3<ul><li>既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络</li><li>这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中</li><li>可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些</li></ul></li></ul><h3 id="重传计时器超时"><strong>重传计时器超时</strong></h3><p>判断网络很可能出现了拥塞，进行以下工作</p><ol><li>将ssthresh值<strong>更新为发生拥塞时cwnd值的一半</strong></li><li>将<strong>cwnd值减少为1</strong>，并重新开始执行慢开始算法</li></ol><hr><h2 id="✨知识点五：TCP超时重传时间的选择">✨知识点五：TCP超时重传时间的选择</h2><p>如果超时重传时间RTO的值设置得比往返时间RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大</p><p>如果超时重传时间RTO的值设置得远大于往返时间RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率</p><h3 id="RFC6298建议使用下式计算超时重传时间RTO"><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4500.png" alt="Untitled"></p><p>针对<strong>出现超时重传时无法测准往返时间RTT</strong>的问题，<strong>Karn</strong>提出了一个算法:<strong>在计算加权平均往返时间RTTS时，只要报文段重传了，就不采用其往返时间RTT样本</strong>。也就是出现重传时，不重新计算RTTS，进而超时重传时间RTO也不会重新计算</p><p>这又引起了新的问题。设想出现这样的情况:报文段的时延突然增大了很多，并且之后很长一段时间都会保持这种时延。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据Karn算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。这会导致报文段反复被重传</p><p>因此，要对Karn算法进行修正。方法是：<strong>报文段每重传一次，就把超时重传时间RTO增大一些</strong>。典型的做法是将新RTO的值取为I日RTO值的2倍</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4501.png" alt="Untitled"></p><hr><h2 id="✨知识点六：TCP可靠传输的实现">✨知识点六：TCP可靠传输的实现</h2><p>TCP基于 <strong><code>以字节为单位的滑动窗口</code></strong> 来实现可靠传输</p><ul><li>TCP基于以字节发送方在未收到接收方的确认时，可将发送窗口内还未发送的数据全部发送出去</li><li>接收方只接收序号落入发送窗口内的数据</li><li>后沿的移动情况有两种情况<ul><li>不动（没有收到新的确认）</li><li>前移（收到了新的确认）</li></ul></li><li>前沿的移动情况有三种可能：<ul><li>通常是不断向前移动</li><li>不动<ul><li>没有收到新的确认，对方通知的窗口大小也不变</li><li>收到新确认但对方通知的窗口缩小，使发送窗口前沿正好不动；</li></ul></li><li>向后收缩（对方通知的窗口缩小了）</li></ul></li></ul><h3 id="如何描述发送窗口的状态？"><strong>如何描述发送窗口的状态？</strong></h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4600.png" alt="Untitled"></p><p>虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，<strong>发送方的发送窗口并不总是和接收方的接收窗口一样大</strong></p><ul><li>网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的</li><li>发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸</li></ul><p>对于<strong>不按序到达的数据</strong>应如何处理，TCP并无明确规定</p><ul><li>如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利，因为发送方会重复传送较多的数据</li><li>TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，<strong>再按序交付上层的应用进程</strong></li></ul><p>TCP要求接收方必须有 <strong><code>累积确认和捎带确认机制</code></strong>，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。</p><ul><li><strong>接收方不应过分推迟发送确认</strong>，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源</li><li>TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认[RFC 1122]</li><li>捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据</li></ul><p>TCP的通信是<strong>全双工通信</strong>。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4601.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4602.png" alt="Untitled"></p><hr><h2 id="✨知识点七：TCP的运输连接管理">✨知识点七：TCP的运输连接管理</h2><ul><li>TCP是面向连接的协议，它基于运输连接来传送TCP报文段。</li><li>TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。</li><li>TCP运输连接有以下 <strong><code>三个阶段</code></strong><ol><li>建立TCP连接</li><li>数据传送</li><li>释放TCP连接</li></ol></li><li>TCP的运输链接管理就是使运输连接的建立和释放都能正常地进行</li></ul><div class="note info no-icon flat"><p>🌐 <strong>TCP的连接建立</strong></p></div><p>TCP 建立连接的过程叫做<strong>握手</strong>。</p><p>握手需要在客户和服务器之间<strong>交换三个 TCP 报文段</strong>。称之为<strong>三报文握手</strong>。</p><p>采用三报文握手主要是<strong>为了防止已失效的连接请求报文段突然又传送到了，因而产生错误</strong></p><p>TCP的连接建立要解决以下<strong>三个问题</strong></p><ul><li>使TCP双方能够确知对方的存在</li><li>使TCP双方能够协商一些参数(如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等)</li><li>使TCP双方能够对运输实体资源(如缓存大小、连接表中的项目等)进行分配</li></ul><h3 id="建立连接过程"><strong>建立连接过程</strong></h3><p>TCP 连接的建立采用 <strong><code>客户服务器方式</code></strong></p><p>主动发起连接建立的应用进程叫做 <strong><code>TCP客户</code></strong> (client)</p><p>被动等待连接建立的应用进程叫做 <strong><code>TCP服务器</code></strong> (server)</p><ol><li><p>最初两端的TCP进程都处于<strong>关闭状态(CLOSED)</strong></p></li><li><p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等</p><p>之后，就准备接受TCP客户端进程的连接请求</p><p>此时，<strong>TCP服务器</strong>进程就进入<strong>监听状态(LISTEN)</strong>，等待TCP客户端进程的连接请求（TCP服务器进程是被动等待来自TCP客户端进程的连接请求，因此成为<strong>被动打开</strong>连接）</p></li><li><p>TCP客户进程也是首先创建传输控制块(由于TCP连接建立是由TCP客户端主动发起的，因此称为<strong>主动打开</strong>连接)</p></li><li><p>然后，在打算建立TCP连接时，<strong>向TCP服务器进程发送TCP连接请求报文段</strong>，并<strong>进入同步已发送状态(SYN-SENT)</strong></p></li></ol><ul><li><p><strong>TCP连接请求报文段首部中</strong></p><ul><li>同步位SYN被设置为1，表明这是一个TCP连接请求报文段</li><li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号</li><li>请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</li></ul></li></ul><ol start="5"><li><strong>TCP服务器进程收到TCP连接请求报文段后</strong>，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入<strong>同步已接收状态(SYN-RCVD)</strong></li></ol><ul><li><p><strong>TCP连接请求确认报文段首部中</strong></p><ul><li>同步位SYN和确认为ACK都设置为1，表明这是一个TCP连接请求确认报文段</li><li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，</li><li>确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认</li><li>请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号</li></ul></li></ul><ol start="6"><li><strong>TCP客户进程收到TCP连接请求确认报文段后</strong>，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入<strong>连接已建立状态(ESTABLISHED)</strong></li></ol><ul><li><p><strong>普通的TCP确认报文段首部中</strong></p><ul><li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1</li><li>确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</li><li>请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号</li></ul></li></ul><ol start="7"><li><strong>TCP服务器进程</strong>收到该确认报文段后也进入<strong>连接已建立状态(ESTABLISHED)</strong></li><li>现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输</li></ol><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4700.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4701.png" alt="Untitled"></p><div class="note info no-icon flat"><p>🌐 <strong>TCP的连接释放</strong></p></div><ul><li>TCP 连接释放过程比较复杂。</li><li>数据传输结束后，<strong>通信的双方都</strong>可释放连接(任何一方都可以在数据传送结束后发出连接释放的通知)</li><li>TCP 连接释放过程是<strong>四报文握手</strong></li></ul><ol><li>现在TCP客户进程和TCP服务器进程都处于<strong>连接已建立状态</strong></li><li><strong>TCP客户进程</strong>的应用进程通知其主动关闭TCP连接</li><li><strong>TCP客户进程会发送TCP连接释放报文段</strong>，并进入<strong>终止等待1状态</strong></li></ol><ul><li><strong>TCP连接释放报文段首部中</strong><ul><li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1</li><li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1</li><li>请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</li></ul></li></ul><ol start="4"><li><strong>TCP服务器进程收到TCP连接释放报文段后</strong>，会发送一个普通的TCP确认报文段并进入<strong>关闭等待状态</strong></li></ol><ul><li><strong>普通的TCP确认报文段首部中</strong><ul><li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配</li><li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认</li></ul></li></ul><ol start="5"><li><strong>TCP服务器进程应该通知高层应用进程</strong>，TCP客户进程要断开与自己的TCP连接</li></ol><ul><li>此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了</li><li>这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了</li><li>但如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭</li></ul><ol start="6"><li><strong>TCP客户进程收到TCP确认报文段</strong>后就进入<strong>终止等待2状态</strong>，等待TCP服务器进程发出的TCP连接释放报文段</li></ol><ul><li>若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接</li><li>由于<strong>TCP连接释放是由TCP客户进程</strong>主动发起的，因此TCP服务器进程对TCP连接的释放称为<strong>被动关闭</strong>连接</li></ul><ol start="7"><li><p><strong>TCP服务器进程发送TCP连接释放报文段</strong>并进入<strong>最后确认状态</strong></p><p><strong>该报文段首部中</strong></p></li></ol><ul><li>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送</li><li>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认</li></ul><ol start="8"><li><strong>TCP客户进程收到TCP连接释放报文段</strong>后，必须针对该报文段发送普通的TCP确认报文段，之后进入<strong>时间等待状态</strong></li></ol><ul><li>该报文段首部中<ul><li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号</li><li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认</li></ul></li></ul><ol start="9"><li><strong>TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态</strong></li></ol><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4702.png" alt="Untitled"></p><p>TCP客户进程在发送完最后一个确认报文后，为什么<strong>不直接进入关闭状态？而是要进入时间等待状态</strong></p><ol><li>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态</li><li>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段</li></ol><h3 id="TCP保活计时器的作用"><strong>TCP保活计时器的作用</strong></h3><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障</p><p>TCP服务器进程以后就不能再收到TCP客户进程发来的数据</p><p>因此，应当有措施使<strong>TCP服务器进程不要再白白等待下去</strong></p><p>措施：</p><p>TCP服务器进程每收到一次TCP客户进程的数据，就<strong>重新设置并启动保活计时器</strong>(2小时定时)</p><p>若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段，以后则<strong>每隔75秒钟发送一次</strong>。若<strong>一连发送10个探测报文段后仍无TCP客户进程的响应</strong>，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接</p><hr><h2 id="✨知识点八：TCP报文段的首部格式">✨知识点八：TCP报文段的首部格式</h2><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4800.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4801.png" alt="Untitled"></p><hr>]]></content>
    
    
    <summary type="html">计网</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="计算机网络" scheme="https://agoni66.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="四大件" scheme="https://agoni66.github.io/tags/%E5%9B%9B%E5%A4%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（四）</title>
    <link href="https://agoni66.github.io/posts/1000104.html"/>
    <id>https://agoni66.github.io/posts/1000104.html</id>
    <published>2024-06-03T15:30:00.000Z</published>
    <updated>2024-09-10T01:17:50.389Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><p><font size="4"><b>计算机网络导航🚀🚀🚀</b></font></p><ol><li><p>🍕<a href="https://agoni66.github.io/posts/1000101.html">第一章 概述</a></p></li><li><p>🍔<a href="https://agoni66.github.io/posts/1000102.html">第二章 物理层</a></p></li><li><p>🍟<a href="https://agoni66.github.io/posts/1000103.html">第三章 数据链路层</a></p></li><li><p>🌭<a href="https://agoni66.github.io/posts/1000104.html">第四章 网际层</a> ⇦ 当前位置🪂</p></li><li><p>🍿<a href="https://agoni66.github.io/posts/1000105.html">第五章 运输层</a></p></li><li><p>🧂<a href="https://agoni66.github.io/posts/1000106.html">第六章 应用层</a></p></li></ol></div><div class="note warning modern"><p><b>图片加载较慢，请耐心等待！🌤️🌥️🌦️</b></p></div><h2 id="网际层概述">网际层概述</h2><p>网络层的主要任务是实现<strong>网络互连</strong>，进而实现<strong>数据包在各网络之间的传输</strong></p><p>Q：网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）</p><p>在数据链路层那课讲过的可靠传输，详情可以看那边的笔记：网络层对以下的<strong>分组丢失、分组失序、分组重复</strong>的传输错误采取措施，使得接收方能正确接受发送方发送的数据，就是<strong>可靠传输</strong>，反之，如果什么措施也不采取，则是<strong>不可靠传输</strong></p><p>Q：网络层寻址问题</p><p>Q：路由选择问题</p><p>路由器收到数据后，是依据什么来决定将数据包从自己的哪个接口转发出去？</p><p><strong>依据数据包的目的地址和路由器中的路由表</strong></p><p>但在实际当中，路由器是怎样知道这些路由记录？</p><p>由用户或网络管理员进行人工配置，这种方法只适用于规模较小且网络拓扑不改变的小型互联网</p><p><strong>另一种是实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路有记录，这种方法更适合规模较大且网络拓扑经常改变的大型互联网</strong></p><p>网络层（网际层）除了IP协议外，还有之前介绍过的地址解析协议ARP，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3004.png" alt="Untitled"></p><hr><h2 id="知识点一：网络层提供的两种服务">知识点一：网络层提供的两种服务</h2><h3 id="面向连接的虚电路服务"><strong>面向连接的虚电路服务</strong></h3><ol><li>计算机网络应模仿电信网络，使用面向连接的通信方式。</li><li>通信之前先建立虚电路 (Virtual Circuit)，以保证双方通信所需的一切网络资源</li><li>如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复</li></ol><h3 id="过程（和电路交换差不多）"><strong>过程</strong>（和电路交换差不多）</h3><ol><li>必须建立网络层的连接——<strong>虚电路VC(Virtual Circuit)</strong></li><li>通信双方沿着<strong>已建立的虚电路发送分组</strong></li><li>目的主机的地址仅在连接建立阶段使用，之后每个<strong>分组的首部只需携带一条虚电路的编号</strong>(构成虚电路的每一段链路都有一个虚电路编号)</li><li>这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方(无差错按序到达、不丢失、不重复)</li><li><strong>通信结束后，需要释放之前所建立的虚电路</strong></li></ol><p>其中，虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接</p><h3 id="无连接的数据报服务"><strong>无连接的数据报服务</strong></h3><ul><li>网络层向上只提供简单灵活的、<strong>无连接的、尽最大努力交付的数据报服务</strong></li><li>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）</li><li>网络层<strong>不提供服务质量的承诺</strong>。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限</li><li><strong>可靠通信应当由用户主机来保证</strong></li><li><strong>不需要建立网络层连接</strong></li><li><strong>每个分组可走不同的路径</strong></li><li>每个分组的<strong>首部必须携带目的主机的完整地址</strong></li><li>这种通信方式所传送的<strong>分组可能误码、丢失、重复和失序</strong></li><li>由于<strong>网络本身不提供端到端的可靠传输服务</strong>，这就使网络中的路由器可以做得比较简单，而且价格低廉(与电信网的交换机相比较)</li><li>因特网采用了这种设计思想，也就是<strong>将复杂的网络处理功能置于因特网的边缘(用户主机和其内部的运输层)</strong>，而将相对简单的尽最大努力的分组交付功能置于因特网核心</li></ul><h3 id="对比"><strong>对比</strong></h3><table><thead><tr><th>对比的方面</th><th>虚电路服务</th><th>数据报服务</th></tr></thead><tbody><tr><td>思路</td><td>可靠通信应当由网路来保证</td><td>可靠通信应当由用户主机来保证</td></tr><tr><td>连接的建立</td><td>必须有</td><td>不需要</td></tr><tr><td>终点地址</td><td>仅在连接建立阶段使用，每个分组使用短的虚电路号</td><td>每个分组都有终点的完整地址</td></tr><tr><td>分组的转发</td><td>属于同一条虚电路的分组均按照同一路由进行转发</td><td>每个分组独立选择路由进行转发</td></tr><tr><td>当结点出故障时</td><td>所有通过出故障的结点的虚电路均不能工作</td><td>出故障的结点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td>分组的顺序</td><td>总是按发送顺序到达终点</td><td>到达终点时不一定按发送顺序</td></tr><tr><td>端到端的差错处理和流量控制</td><td>可以由网络负责，也可以由用户主机负责</td><td>由用户主机负责</td></tr></tbody></table><hr><h2 id="✨知识点二：IPv4">✨知识点二：IPv4</h2><p><strong><code>IPv4地址</code></strong> 就是给因特网(Internet)上的 <strong><code>每一台主机(或路由器)</code></strong> 的每一个接口分配一个在全世界范围内是 <strong><code>唯一的32比特的标识符</code></strong></p><p>点分十进制表示方法</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3100.png" alt="Untitled"></p><div class="note danger no-icon flat"><p>⚙ 分类编制</p></div><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3101.png" alt="Untitled"></p><ul><li>IPv4地址分为A类、B类、C类、D类和E类</li><li>每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号 host-id，它标志该主机（或路由器）</li><li>主机号在它前面的网络号所指明的网络范围内必须是唯一的</li><li>由此可见，一个 IP 地址在整个互联网范围内是唯一的</li></ul><h3 id="A类地址"><strong>A类地址</strong></h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3102.png" alt="Untitled"></p><h3 id="B类地址"><strong>B类地址</strong></h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3103.png" alt="Untitled"></p><p>属于荷兰</p><h3 id="C类地址"><strong>C类地址</strong></h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3104.png" alt="Untitled"></p><p><strong>未分配出去</strong></p><h3 id="习题">习题</h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3105.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3106.png" alt="Untitled"></p><div class="note danger no-icon flat"><p>⚙ <strong>划分子网</strong></p></div><p>Q：为什么要划分子网？</p><p>IP 地址的设计确实不够合理</p><ul><li>IP 地址空间的利用率有时很低</li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏</li><li>两级的 IP 地址不够灵活</li></ul><p><strong><code>子网掩码</code></strong> 划分子网的工具，使两级的 IP 地址变成为三级的 IP 地址</p><h3 id="如何划分子网"><strong>如何划分子网</strong></h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3107.png" alt="Untitled"></p><ol><li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器</li><li>然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网</li><li>最后就将 IP 数据报直接交付目的主机</li></ol><h3 id="优点"><strong>优点</strong></h3><ol><li>减少了 IP 地址的浪费</li><li>使网络的组织更加灵活</li><li>更便于维护和管理</li></ol><p><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络</p><h3 id="原理实现"><strong>原理实现</strong></h3><p><strong>32比特的子网掩码</strong>可以表明<strong>分类IP地址的主机号部分被借用了几个比特作为子网号</strong></p><ul><li>子网掩码使用<strong>连续的比特1来对应网络号和子网号</strong></li><li>子网掩码使用<strong>连续的比特0来对应主机号</strong></li><li>将划分子网的<strong>IPv4地址</strong>与其相应的子网掩码进行<strong>逻辑与运算（全1为1，一0就0）<strong>就可得到IPv4地址</strong>所在子网的网络地址</strong></li></ul><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3108.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3109.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3110.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3111.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3112.png" alt="Untitled"></p><h3 id="默认子网掩码"><strong>默认子网掩码</strong></h3><p><strong><code>默认子网掩码是在未划分子网的情况下使用的子网掩码</code></strong></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3113.png" alt="Untitled"></p><h3 id="重点"><strong>重点</strong></h3><p><strong>划分出的子网数量每个子网可分配的IP地址数量每个子网的网络地址和广播地址每个子网可分配的最小和最大地址</strong></p><ul><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li><li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码</li></ul><h3 id="无分类编码">无分类编码</h3><p>原因：划分子网在一定程度上缓解了因特网在发展中遇到的困难，但是 **<code>数量巨大的C类网</code>**因为 **<code>其地址空间太小</code>**并没有得到充分使用，而因特网的IP地址仍在加速消耗，<strong>整个IPv4地址空间面临全部耗尽的威胁</strong></p><p>结果：</p><p>1993年，IETF发布了<strong>无分类域间路由选择CIDR</strong>(Classless Inter-Domain<br>Routing)的RFC文档：RFC1517~1519和1520。</p><ul><li><strong>CIDR消除了传统的A类、B类和C类地址，以及划分子网的概念</strong></li><li><strong>CIDR可以更加有效地分配IPv4的地址空间</strong>，并且可以在新的IPv6使用之前允许因特网的规模继续增长</li></ul><p><strong>特点：</strong></p><ol><li>CIDR使用各种长度的“<strong>网络前缀</strong>”(network-prefix)来代替分类地址中的网络号和子网号</li><li>IP 地址从<strong>三级编址（使用子网掩码）<strong>又回到了</strong>两级编址</strong></li><li>CIDR使用“<strong>斜线记法</strong>”，或称CIDR记法。即在IPv4地址后面加上斜线“/”，在斜线后面<strong>写上网络前缀所占的比特数量</strong></li><li><strong>CIDR实际上是将网络前缀都相同的连续的IP地址组成一个“CIDR地址块”</strong></li><li>全部细节<ul><li><strong>地址块的最小地址</strong></li><li><strong>地址块的最大地址</strong></li><li><strong>地址块中的地址数量</strong></li><li><strong>地址块聚合某类网络(A类、B类或C类)的数量</strong></li><li><strong>地址掩码(也可继续称为子网掩码)</strong></li></ul></li></ol><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3114.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3115.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3116.png" alt="Untitled"></p><h3 id="路由聚合（构造超网）"><strong>路由聚合（构造超网）</strong></h3><p><strong>网络前缀越长，地址块越小，路由越具体</strong></p><ol><li>若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为 <strong><code>最长前缀匹配</code></strong>，因为这样的路由更具体</li></ol><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3117.png" alt="Untitled"></p><h3 id="IPv4地址的应用规划"><strong>IPv4地址的应用规划</strong></h3><p><strong>定长的子网掩码FLSM（Fixed Length Subnet Mask）</strong></p><ul><li>使用同一个子网掩码来划分子网</li><li>子网划分方式<strong>不灵活</strong>：只能划分出个子网(n是从主机号部分借用的用来作为子网号的比特数量)</li><li>每个子网所分配的IP地址数量相同，容易造成IP地址浪费</li></ul><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3118.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3119.png" alt="Untitled"></p><p>通过上面步骤分析，就可以从子网1 ~ 8中任选5个分配给左图中的N1 ~ N5</p><h3 id="变长的子网掩码VLSM（Variable-Length-Subnet-Mask）"><strong>变长的子网掩码VLSM（Variable Length Subnet Mask）</strong></h3><ul><li>使用不同的子网掩码来划分子网</li><li>子网划分方式灵活:可以按需分配</li><li>每个子网所分配的IP地址数量可以不同，尽可能减少对IP地址的浪费</li></ul><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3120.png" alt="Untitled"></p><hr><h2 id="知识点三：IP数据报的发送和转发过程">知识点三：IP数据报的发送和转发过程</h2><p>分为<strong>两部分</strong></p><ul><li>主机发送IP数据报</li><li>路由器转发IP数据报</li></ul><h3 id="主机发送IP数据报"><strong>主机发送IP数据报</strong></h3><p>可以通过<strong>目的地址IP和源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到目的网络地址</p><ul><li>如果 目的网络地址 和 源网络地址 相同，就是在<strong>同一个网络</strong>中，属于<strong>直接交付</strong></li><li>如果目的网络地址和源网络地址 不相同，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的默认网关（路由器）,由<strong>默认网关帮忙转发</strong></li></ul><h3 id="默认网关"><strong>默认网关</strong></h3><p>用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，所指定的路由器，也被称为<strong>默认网关</strong></p><h3 id="路由器收到IP数据报后如何转发？"><strong>路由器收到IP数据报后如何转发？</strong></h3><ol><li>检查IP数据报首部是否出错：</li></ol><ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul><ol><li>根据IP数据报的目的地址在路由表中查找匹配的条目：</li></ol><ul><li>若找到匹配的条目，则转发给条目中指示的下一跳</li><li>若找不到，则<strong>丢弃</strong>该数据报并通告源主机（不可靠）</li></ul><h3 id="查找过程"><strong>查找过程</strong></h3><p>逐条检查路由条目，将目的地址与路由条目中的地址掩码进行逻辑与运算得到目的网络地址，然后与路由条目中的目的网络进行比较，如果相同，则这条路由条目就是匹配的路由条目，按照它的下一跳指示的也就是接口1转发该IP数据报</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3200.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3201.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3202.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3203.png" alt="Untitled"></p><hr><h2 id="知识点四：静态路由配置及其可能产生的路由环路问题">知识点四：静态路由配置及其可能产生的路由环路问题</h2><p>静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器 <strong><code>人工配置路由表</code></strong></p><ol><li>这种人工配置方式简单、开销小。但不能及时适应网络状态(流量、拓扑等)的变化</li><li>一般只在小规模网络中采用</li></ol><p>使用静态路由配置可能出现以下导致产生 <strong><code>路由环路</code></strong> 的错误</p><ol><li>配置错误</li><li>聚合了不存在的网络</li><li>网络故障</li></ol><p><strong><span class='p red h3'>静态路由配置</span></strong></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3400.png" alt="Untitled"></p><p>解决方法：</p><p>给聚合网络中不存在的网络配置<strong>黑洞路由（下一跳为空，路由器内部的虚拟接口，IP数据报进入它后就被丢弃）</strong>，当转发不存在的网络地址时，根据最长前缀匹配，优先匹配<strong>黑豆路由</strong>，而不是聚合网络路由，这样IP数据报就被“<strong>吞掉了</strong>”</p><p><strong>网络故障而导致路由环路</strong></p><p>某主机因网络故障而不可达，就会自动在其路由表中删除该路由条目，这样其他转发过来该网络的数据报到该路由器，根据 <strong><code>默认路由匹配</code></strong> ，转发到上一跳 反复横跳，形成路由环路</p><p>解决方法：</p><p>添加故障的网络为 <strong><code>黑洞路由</code></strong></p><p><strong>ELSE</strong></p><p>网络故障恢复后</p><p>路由器会<strong>自动</strong>地得出了其接口的直连网络的路由条目</p><p>针对该网络的黑洞网络会<strong>自动失效</strong></p><p>如果又故障</p><p>自动删除其接口的直连网络的路由条目</p><p>则<strong>生效</strong>该网络的黑洞网络</p><hr><h2 id="✨知识点五：路由选择协议">✨知识点五：路由选择协议</h2><h3 id="概述">概述</h3><table><thead><tr><th>静态路由选择</th><th>动态路由选择</th></tr></thead><tbody><tr><td>由人工配置的网络路由、默认路由、特定主机路由、黑洞路由等都属于静态路由</td><td>路由器通过路由选择协议自动获取路由信息</td></tr><tr><td>这种人工配置方式简单、开销小</td><td></td></tr><tr><td>但不能及时适应网络状态(流量、拓扑等)的变化</td><td>比较复杂、开销比较大</td></tr><tr><td>能较好地适应网络状态的变化</td><td></td></tr><tr><td>一般只在小规模网络中采用</td><td>适用于大规模网络</td></tr></tbody></table><h3 id="因特网所采用的路由选择协议的主要特点">因特网所采用的<strong>路由选择协议的主要特点</strong></h3><ol><li>自适应（动态路由选择，能较好地适应网络状态的变化）</li><li>分布式（路由器之间交换路由信息）</li><li>分层次（将整个因特网划分为许多较小的<strong>自治系统AS</strong>（<strong>A</strong>utonomous <strong>S</strong>ystem））<ul><li>自治系统：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由</li><li>自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为<strong>域内路由选择</strong></li><li>域间路由选择使用<strong>外部网关协议EGP</strong>这个类别的路由选择协议</li><li>域内路由选择使用<strong>内部网关协议IGP</strong>这个类别的路由选择协议</li><li>EGP和IGP都仅仅是统称</li><li>网关协议的名称可称为<strong>路由协议</strong></li></ul></li></ol><h3 id="常见的路由选择协议"><strong>常见的路由选择协议</strong></h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3500.png" alt="Untitled"></p><h3 id="路由器的基本结构"><strong>路由器的基本结构</strong></h3><p>路由器是一种具有多个输入端口，和输出端口的专用计算机，其任务是转发分组</p><p><strong>路由器结构可划分为两大部分：</strong></p><h4 id="一、分组转发部分"><strong>一、分组转发部分</strong></h4><p>由三部分构成</p><ul><li>交换结构</li><li><strong><code>一组输入端口</code></strong><ol><li>信号从某个输入端口进入路由器</li><li>物理层将信号转换成比特流，送交数据链路层处理</li><li>数据链路层识别从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理</li></ol><ul><li>如果送交网络层的分组是普通待转发的数据分组，则根据分组首部中的目的地址进行<strong>查表转发</strong></li><li>若找不到匹配的转发条目，则<strong>丢弃</strong>该分组，否则，按照匹配条目中所指示的端口（默认路由）进行转发</li></ul></li><li><strong><code>一组输出端口</code></strong><ol><li>网络层更新数据分组首部中某些字段的值，例如<strong>将数据分组的生存时间减1</strong>，然后送交数据链路层进行封装</li><li>数据链路层将数据分组封装成帧，交给物理层处理</li><li>物理层将帧看成比特流将其变换成相应的电信号进行发送</li></ol></li></ul><p>路由器的各端口还会有<strong>输入缓冲区</strong>和<strong>输出缓冲区</strong></p><ul><li>输入缓冲区用来暂存新进入路由器但还来不及处理的分组</li><li>输出缓冲区用来暂存已经处理完毕但还来不及发送的分组</li></ul><p><strong>路由器的端口一般都具有输入和输出功能</strong>，这些实例分出了输入端口和输出端口是更好演示路由基本工作过程</p><h4 id="二、路由选择部分"><strong>二、路由选择部分</strong></h4><p>路由选择部分的核心构件是 <strong><code>路由选择处理机</code></strong>，它的任务是根据所使用的路由选择协议。周期性地与其他路由器进行路由信息的交互，来更新路由表</p><p>如果送交给输入端口的网络层的分组是路由器之间交换路由信息的路由报文，则把这种分组送交给路由选择处理机</p><p>路由选择处理机根据分组的内容来更新自己的 <strong><code>路由表</code></strong></p><p>路由选择处理机还会周期性地给其他路由器发送自己所知道的路由信息</p><ul><li>路由表一般仅包含从目的网络到下一跳的映</li><li>路由表需要对网络拓扑变化的计算最优化</li><li>转发表是从路由表得出的</li><li>转发表的结构应当使查找过程最优化</li></ul><hr><h2 id="✨知识点六：路由信息协议RIP">✨知识点六：路由信息协议RIP</h2><ul><li><strong><code>路由信息协议RIP</code></strong> (Routing Information Protocol)是内部网关协议IGP中最先得到广泛使用的协议之一，其相关标准文档为RFC 1058</li><li>RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“ <strong><code>距离向量D-V</code></strong> (Distance-Vector)”</li><li>RIP使用 <strong><code>跳数</code></strong> (Hop Count)作为度量(Metric)来衡量到达目的网络的距离<ul><li>路由器到直连网络的距离定义为1</li><li>路由器到非直连网络的距离定义为所经过的路由器数加1</li><li>允许一条路径最多只能包含15个路由器。<strong>“距离”等于16时相当于不可达</strong>，因此，RIP只适用于<strong>小型互联网</strong></li></ul></li><li>RIP认为<strong>好的路由就是“距离短”的路由</strong>，也就是所通过<strong>路由器数量最少</strong>的路由</li><li>当到达同一目的网络有多条“距离相等”的路由时，可以进行<strong>等价负载均衡</strong></li><li>RIP包含三个要点：<ul><li><strong>和谁交换信息</strong>——仅和 <strong><code>相邻路由器</code></strong> 交换信息</li><li><strong>交换什么信息</strong>——自己的 <strong><code>路由表</code></strong></li><li><strong>何时交换信息</strong>—— <strong><code>周期性交换</code></strong></li></ul></li></ul><h3 id="RIP的基本工作过程"><strong>RIP的基本工作过程</strong></h3><ul><li><strong>初始化</strong>：路由器刚开始工作时，<strong>只知道自己到直连网络的距离为1</strong></li><li><strong>发展</strong>：每个路由器仅和<strong>相邻路由器周期性地交换并更新路由信息</strong></li><li><strong>收敛</strong>：若干次交换和更新后，<strong>每个路由器都知道到达本AS内各网络的最短距离和下一跳地址</strong>，称为收敛</li></ul><h3 id="RIP的路由条目的更新规则"><strong>RIP的路由条目的更新规则</strong></h3><ol><li>路由器C的表到达各目的网络的下一条都记为问号，可以理解为<strong>路由器D并不需要关心路由器C的这些内容</strong></li><li>假设路由器C的RIP更新报文发送周期到了，则路由器C将自己路由表中的相关路由信息封装到**RIP更新报文（距离+1，吓一跳全是C）**中发送给路由器D</li><li>路由器D根据自己的路由表更新路由表<ol><li>到达目的网络，相同下一跳，最新消息，<strong>更新</strong></li><li>发现了新的网络，<strong>添加</strong></li><li>到达目的网络，不同下一跳，新路由优势，<strong>更新</strong></li><li>到达目的网络，不同下一跳，<strong>等价负载均衡</strong></li><li>到达目的网络，不同下一跳，新路由优势，<strong>不更新</strong></li></ol></li></ol><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3600.png" alt="Untitled"></p><h3 id="RIP存在“坏消息传播得慢”的问题"><strong>RIP存在“坏消息传播得慢”的问题</strong></h3><ul><li>“坏消息传播得慢”又称为<strong>路由环路</strong>或<strong>距离无穷计数</strong>问题，<strong>这是距离向量算法的一个固有问题</strong>，可以采取多种措施减少出现该问题的概率或<strong>减小</strong>该问题带来的危害**（只要还是RIP就不能避免或者彻底消除）**</li></ul><p><strong>措施</strong></p><ul><li><strong>限制最大路径距离</strong>为15(16表示不可达)</li><li>当路由表发生变化时就立即发送更新报文(即“<strong>触发更新</strong>”)，而不仅是周期性发送</li><li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送(即“<strong>水平分割</strong>”)</li></ul><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3601.png" alt="Untitled"></p><h3 id="优缺点">优缺点</h3><p><strong>优点</strong></p><p>实现简单，开销较小</p><p><strong>缺点</strong></p><ol><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li><li>“坏消息传播得慢”，使更新过程的收敛时间过长。</li></ol><hr><h2 id="✨知识点七：开放最短路径优先OSPF">✨知识点七：开放最短路径优先OSPF</h2><h3 id="开放最短路径优先-OSPF-Open-Shortest-Path-First"><strong>开放最短路径优先 OSPF (Open Shortest Path First)</strong></h3><p>注意：OSPF只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”</p><h3 id="概念">概念</h3><ul><li>开放最短路径优先OSPF(0pen ShortestPath First)，是为克服RIP的缺点在1989年开发出来的<ul><li>“开放”表明OSPF协议不是受某一家厂商控制，而是<strong>公开发表</strong>的。</li><li>“最短路径优先”是因为使用了Dijkstra提出的 <strong><code>最短路径算法SPF</code></strong></li></ul></li><li>OSPF是 <strong><code>基于链路状态</code></strong> 的，而不像RIP那样是基于距离向量的</li><li>OSPF采用SPF算法计算路由，从算法上保证了 <strong><code>不会产生路由环路</code></strong></li><li><strong>OSPF不限制网络规模</strong>，更新效率高， <strong><code>收敛速度快</code></strong></li><li>链路状态是指本路由器都<strong>和哪些路由器相邻</strong>，以及相应<strong>链路的“代价”(cost)</strong><ul><li>“代价”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定</li></ul></li></ul><h3 id="链路状态通告LSA"><strong>链路状态通告LSA</strong></h3><p>使用OSPF的每个路由器都会产生链路状态通告LSA(LinkStateAdvertisement)。LSA中包含以下内容：</p><ul><li>直连网络的链路状态信息</li><li>邻居路由器的链路状态信息</li></ul><h3 id="链路状态数据库同步"><strong>链路状态数据库同步</strong></h3><p>使用OSPF的每个路由器都有一个 <strong><code>链路状态数据库LSDB</code></strong> ，用于存储LSA</p><p>LSA被封装在 <strong><code>链路状态更新分组LSU</code></strong> 中，采用 <strong><code>洪泛法发送</code></strong></p><p>通过各路由器洪泛发送封装有自己LSA的LSU分组，各路由器的LSDB最终将达到一致</p><p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong></p><p>使用OSPF的各路由器基于LSDB进行<strong>最短路径优先SPF</strong>计算，构建出各自到达其他各路由器的<strong>最短路径</strong>，即构建各自的路由表</p><div class="note danger no-icon flat"><p>🛠 <strong>OSPF有以下五种分组类型</strong></p></div><ul><li><strong>问候(Hello)分组</strong></li></ul><p>用来发现和维护邻居路由器的可达性</p><ul><li><strong>数据库描述(Database Description)</strong></li></ul><p>向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息</p><ul><li><strong>分组链路状态请求(Link State Request)分组</strong></li></ul><p>向邻居路由器请求发送某些链路状态项目的详细信息</p><ul><li><strong>链路状态更新(Link State Update)分组</strong></li></ul><p>路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态</p><ul><li><strong>链路状态确认(Link State Acknowledgment)分组</strong></li></ul><p>这是对链路状态更新分组的确认分组</p><div class="note danger no-icon flat"><p>🛠 <strong>OSPF的基本工作过程</strong></p></div><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3700.png" alt="Untitled"></p><h3 id="OSPF在多点接入网络中路由器邻居关系的建立"><strong>OSPF在多点接入网络中路由器邻居关系的建立</strong></h3><p>问题：如果不采用其他机制，将会产生大量的多播分组</p><p>措施：</p><ul><li>选举<strong>指定路由器DR</strong>(designated router)和<strong>备用的指定路由器BDR</strong>(backup designated router)</li><li><strong>非DR/BDR之间通过DR/BDR交换信息</strong></li><li><strong>所有的非DR/BDR只与DR/BDR建立邻居关系</strong></li><li><strong>若DR出现问题，则由BDR顶替DR</strong></li></ul><p>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做<strong>区域</strong>(Area)</p><ul><li>区域内路由器IR</li><li>区域边界路由器ABR</li><li>主干路由器BBR</li><li>自治系统边界路由器ASBR</li></ul><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3701.png" alt="Untitled"></p><p>划分区域的好处就是把利用洪泛法交换链路状体信息的范围局限于每一个区域而不是整个自治系统，这就减少了整个网络上的通信量</p><hr><h2 id="✨知识点八：边界网关协议BGP">✨知识点八：边界网关协议BGP</h2><p><code>BGP</code>（BorderGateway Protocol） 是 <strong><code>不同自治系统的路由器之间交换路由信息</code></strong> 的协议</p><ul><li>在不同自治系统内，度量路由的“代价”(距离，带宽，费用等)可能不同。因此，对于自治系统之间的路由选择，使用“代价”作为度量来寻找最佳路由是不行的</li><li>自治系统之间的路由选择必须考虑相关策略(政治，经济，安全等)</li><li>BGP只能是力求寻找一条能够到达目的网络且比较好的路由(不能兜圈子)，而<strong>并非要寻找一条最佳路由</strong></li><li>在配置BGP时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的“<strong>BGP发言人</strong>”</li><li>不同自治系统的BGP发言人要交换路由信息，首先必须<strong>建立TCP连接</strong>，<strong>端口号为179</strong><ul><li>在此TCP连接上交换BGP报文以<strong>建立BGP会话</strong></li><li>利用BGP会话<strong>交换路由信息</strong>(例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等)</li><li>使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的<strong>邻站</strong>(neighbor)或<strong>对等站</strong>(peer)</li></ul></li><li>BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP，例如OSPF或RIP</li><li>BGP发言人<strong>交换网络可达性的信息</strong>(要到达某个网络所要经过的一系列自治系统)</li><li>当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就<strong>根据</strong>所采用的<strong>策略</strong>从收到的路由信息中<strong>找出到达各自治系统的较好的路由</strong>。也就是构造出树形结构、<strong>不存在回路的自治系统连通图</strong></li><li>BGP适用于多级结构的因特网</li></ul><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3800.png" alt="Untitled"></p><h3 id="BGP-4有以下四种报文"><strong>BGP-4有以下四种报文</strong></h3><table><thead><tr><th>OPEN(打开)报文</th><th>用来与相邻的另一个BGP发言人建立关系，使通信初始化</th></tr></thead><tbody><tr><td>UPDATE(更新)报文</td><td>用来通告某一路由的信息，以及列出要撤销的多条路由。</td></tr><tr><td>KEEPALIVE(保活)报文</td><td>用来周期性地证实邻站的连通性。</td></tr><tr><td>NOTIFICATION(通知)报文</td><td>用来发送检测到的差错。</td></tr></tbody></table><h3 id="直接封装RIP、OSPF和BGP报文的协议"><strong>直接封装RIP、OSPF和BGP报文的协议</strong></h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3801.png" alt="Untitled"></p><hr><h2 id="✨知识点九：IPv4数据报的首部格式">✨知识点九：IPv4数据报的首部格式</h2><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3900.png" alt="Untitled"></p><p>一个IP 数据报由 <strong><code>首部</code></strong> 和 <strong><code>数据</code></strong> 两部分组成。</p><p>首部的前一部分是固定长度，共 <strong><code>20 字节</code></strong> ，是所有 IP 数据报必须具有的。</p><p>在首部的固定部分的后面是一些可选字段，其长度是可变的（ <strong><code>0~40字节</code></strong>）</p><p>图中的每一行都由 <strong><code>32个比特（也就是4个字节）</code></strong> 构成，每个小格子称为字段或者域，每个字段或某些字段的组合用来表达IP协议的相关功能</p><p><strong><span class='p h3 blue'>具体格式</span></strong></p><div class="note danger no-icon flat"><p>📏 <strong>版本</strong></p></div><p>占4比特，表示<strong>IP协议的版本</strong></p><p>通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为4(即IPv4)</p><div class="note danger no-icon flat"><p>📏 <strong>首部长度</strong></p></div><p>占4比特，<strong>表示IP数据报首部的长度</strong></p><p>该字段的取值以4字节为单位</p><p>最小十进制取值为5，表示IP数据报首部只有20字节固定部分</p><p>最大十进制取值为15，表示IP数据报首部包含20字节固定部分和最大40字节可变部分</p><div class="note danger no-icon flat"><p>📏 <strong>可选字段</strong></p></div><p><strong>长度从1个字节到40个字节不等</strong>。用来支持排错、测量及安全等措施可选字段增加了IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理IP数据报的开销。实际上可选字段很少被使用</p><div class="note danger no-icon flat"><p>📏 <strong>填充字段</strong></p></div><p>确保首部长度为4字节的整数倍。使用<strong>全0</strong>进行填充。</p><p>IP数据报的首部长度一定是4字节的整数倍</p><p>当20字节的固定部分加上1到40个字节长度不等的可变部分，会造成首部长度不是4字节整数倍时，就用取值为全0的<strong>填充字段</strong>填充相应个字节</p><div class="note danger no-icon flat"><p>📏 <strong>区分服务</strong></p></div><p>占8比特，用来获得更好的服务。</p><p>该字段在旧标准中叫作服务类型，但实际上一直没有被使用过。</p><p>1998年，因特网工程任务组IETF把这个字段改名为区分服务。</p><p>利用该字段的不同数值可提供不同等级的服务质量。</p><p>只有在使用区分服务时，该字段才起作用。一般情况下都不使用该字段</p><div class="note danger no-icon flat"><p>📏 <strong>总长度</strong></p></div><p>占16比特，表示IP数据报的<strong>总长度(首部+数据载荷)</strong></p><p>最大取值为十进制的65535，以字节为单位</p><div class="note danger no-icon flat"><p>📏 <strong>标识</strong></p></div><p>占16比特，属于同一个数据报的各分片数据报应该具有相同的标识</p><p>IP软件维持一个计数器，每产生一个数据报，计数器值加1，并将此值赋给标识字段</p><div class="note danger no-icon flat"><p>📏 <strong>标志</strong></p></div><p>占3比特，各比特含义如下:</p><ul><li>DF位：1表示不允许分片；0表示允许分片</li><li>MF位：1表示“后面还有分片”；0表示“这是最后一个分片”</li><li>保留位：必须为0</li></ul><div class="note danger no-icon flat"><p>📏 <strong>片偏移</strong></p></div><p>占13比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位</p><p>片偏移以8个字节为单位</p><div class="note danger no-icon flat"><p>📏 <strong>生存时间TTL</strong></p></div><p>占8比特，最初以秒为单位，最大生存周期为255秒；路由器转发IP数据报时，将IP数据报首部中的该字段的值减去IP数据报在本路由器上所耗费的时间，若不为0就转发，否则就丢弃。</p><p>现在以“跳数”为单位，路由器转发IP数据报时，将IP数据报首部中的该字段的值减1，若不为0就转发，否则就丢弃</p><div class="note danger no-icon flat"><p>📏 <strong>协议</strong></p></div><p>占8比特，指明IPv4数据报的数据部分是何种协议数据单元。</p><p>常用的一些协议和相应的协议字段值如下。</p><table><thead><tr><th>协议名称</th><th>ICMP</th><th>IGMP</th><th>TCP</th><th>UDP</th><th>IPv6</th><th>OSPF</th></tr></thead><tbody><tr><td>协议字段值</td><td>1</td><td>2</td><td>6</td><td>17</td><td>41</td><td>89</td></tr></tbody></table><div class="note danger no-icon flat"><p>📏 <strong>首部检验和</strong></p></div><p>占16比特，用来检测首部在传输过程中是否出现差错。比CRC检验码简单，称为因特网检验和。</p><p>IP数据报每经过一个路由器，路由器都要重新计算首部检验和，因为某些字段(生存时间、标志、片偏移等)的取值可能发生变化。</p><p>由于IP层本身并不提供可靠传输的服务，并且计算首部校验和是一项耗时的操作，因此在IPv6中路由器不再计算首部校验和，从而更快转发IP数据报。</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3901.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3902.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3903.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3904.png" alt="Untitled"></p><hr><h2 id="✨知识点十：网际控制报文协议ICMP">✨知识点十：网际控制报文协议ICMP</h2><p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了 <strong><code>网际控制报文协议CMP</code></strong> (Internet Control Message Protocol)。</p><p>主机或路由器使用ICMP来 <strong><code>发送差错报告报文和询问报文</code></strong></p><p><strong><code>ICMP报文被封装在IP数据报</code></strong> 中发送</p><p>ICMP差错报告报文共有以下五种：</p><table><thead><tr><th>终点不可达</th><th>当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知、目的主机未知等13种错误</th></tr></thead><tbody><tr><td>源点抑制</td><td>当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢</td></tr><tr><td>时间超过</td><td>1. 当路由器收到一个目的IP地址不是自己的IP数据报，会将其生存时间TTL字段的值减1。若结果不为0，则将该IP数据报转发出去；若结果为0，除丢弃该IP数据报外，还要向源点发送时间超过报文    2. 另外，当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点发送时间超过报文。</td></tr><tr><td>参数问题</td><td>当路由器或目的主机收到IP数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文。</td></tr><tr><td>改变路由(重定向)</td><td>路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)（发的很好，下次别发了）</td></tr></tbody></table><h3 id="以下情况不应发送ICMP差错报告报文：">以下情况<strong>不应发送ICMP差错报告报文</strong>：</h3><ol><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li><li>对具有多播地址的数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文</li></ol><h3 id="常用的ICMP询问报文有以下两种">常用的ICMP询问报文有以下两种:</h3><ul><li><strong>回送请求和回答</strong><ul><li>ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问</li><li>收到此报文的主机<strong>必须</strong>给源主机或路由器发送ICMP回送回答报文</li><li>这种询问报文用来<strong>测试目的站是否可达</strong>及了解其有关状态</li></ul></li><li><strong>时间戳请求和回答</strong></li></ul><p>ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从<strong>1900年1月1日</strong>起到当前时刻一共有多少秒。</p><p>这种询问报文用来<strong>进行时钟同步和测量时间</strong></p><h3 id="ICMP应用"><strong>ICMP应用</strong></h3><p><strong>分组网间探测PING（Packet InterNet Groper）</strong></p><ul><li>用来测试主机或路由器间的连通性</li><li>应用层直接使用<strong>网际层的ICMP</strong>(没有通过运输层的TCP或UDP)</li><li>使用ICMP回送请求和回答报文</li></ul><p><strong>跟踪路由traceroute</strong></p><ul><li>用来测试IP数据报从源主机到达目的主机要经过哪些路由器</li><li>Windows版本<ul><li>tracert命令</li><li>应用层直接使用网际层ICMP</li><li>使用了ICMP回送请求和回答报文以及差错报告报文</li></ul></li><li>Unix版本<ul><li>traceroute命令</li><li>在运输层使用UDP协议</li><li>仅使用ICMP差错报告报文</li></ul></li></ul><h3 id="traceroute实现原理"><strong>traceroute实现原理</strong></h3><p>先从TTL=1开始发送ICMP会送请求，该路径上的路由器因为TTL=0丢弃IP数据报并给源主机发送ICMP差错报告(时间超过)，再TTL累加1（TTL=2）发送，获取差错报告，这样就能得到路径上的所有信息</p><hr><h2 id="✨知识点十一：虚拟专用网VPN与网络地址转换NAT">✨知识点十一：虚拟专用网VPN与网络地址转换NAT</h2><h3 id="虚拟专用网VPN（Virtual-Private-Network）">虚拟专用网VPN（Virtual Private Network）</h3><ul><li>由于 <strong>IP 地址的紧缺</strong>，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。</li><li>考虑到<strong>互联网并不很安全</strong>，一个机构内也并不需要把所有的主机接入到外部的互联网。</li><li>假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些<strong>仅在机构内部</strong>使用的计算机就可以由本机构<strong>自行分配其 IP 地址</strong></li><li><strong>利用公用的因特网</strong>作为本机构各专用网之间的通信载体，这样的专用网又称为<strong>虚拟专用网</strong></li><li>由于<strong>IPv4地址的紧缺</strong>，一个机构能够申请到的IPv4地址数量往往远小于本机构所拥有的主机数量。因此，<strong>虚拟专用网中的各主机所分配的地址应该是本机构可自由分配的专用地址</strong>而不是需要申请的、在因特网上使用的公有地址。</li><li>同一机构内不同部门的内部网络所构成的虚拟专用网VPN又称为<strong>内联网VPN</strong></li><li>有时一个机构的VPN需要有某些外部机构(通常就是合作伙伴)参加进来。这样的VPN就称为<strong>外联网VPN</strong></li><li>在外地工作的员工需要访问公司内部的专用网络时，只要在任何地点接入到因特网，运行驻留在员工PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，即可访问专用网络中的资源。这种VPN称为<strong>远程接入VPN</strong></li></ul><p><strong><span class='p h3'>专用(私有)地址：</span></strong></p><p>10.0.0.0~10.255.255.255(10/8地址块)</p><p>172.16.0.0~172.31.255.255(172.16/12地址块)</p><p>192.168.0.0~192.168.255.255(192.168/16地址块)</p><p>私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信</p><p>私有地址只能用作本地地址而不能用作全球地址</p><p>因特网中所有路由器对目的地址是<strong>私有地址</strong>的IP数据报<strong>一律不进行转发</strong></p><h3 id="本地地址与全球地址"><strong>本地地址与全球地址</strong></h3><p>本地地址——仅在机构内部使用的<br>IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</p><p>全球地址——全球唯一的<br>IP 地址，必须向互联网的管理机构申请。</p><p>问题：在内部使用的本地地址就有可能和互联网中某个<br>IP 地址重合，这样就会出现地址的二义性问题。</p><p>两个专用网内的主机间发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样</p><p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路</p><p>因此也被称为 <strong><code>IP隧道技术</code></strong></p><h3 id="网络地址转换NAT-Network-Address-Translation">网络地址转换NAT(Network Address Translation)</h3><ul><li>由于IP地址的紧缺，一个机构能够申请到的IP地址数量往往远小于本机构所拥有的主机数量。因此，<strong>虚拟专用网中的各主机所分配的地址应该是本机构可自由分配的专用地址</strong>，而不是需要申请的、在因特网上使用的公有地址</li><li>虽然因特网采用了无分类编址方式来减缓IP地址空间耗尽的速度，但由于因特网用户数目的激增，特别是大量小型办公室网络和家庭网络接入因特网的需求不断增加，IPv4地址空间即将面临耗尽的危险仍然没有被解除。</li><li>1994年提出了一种网络地址<strong>转换NAT的方法再次缓解了IP地址空间耗尽的问题</strong></li><li>NAT能使<strong>大量使用内部专用地址的专用网络用户共享少量外部全球地址</strong>来访问因特网上的主机和资源</li><li>由于绝大多数的网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换。这样，用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种将端口号和IP地址一起进行转换的技术叫作<strong>网络地址与端口号转换NAPT</strong>(Network Address and Port Translation).</li><li>对于一些P2P网络应用，需要<strong>外网主机主动与内网主机进行通信</strong>，在通过NAT时会遇到问题（内网主机与外网主机的通信，不能由外网主机首先发起），需要网络应用自己使用一些特殊的NAT穿越技术来解决问题</li><li>由于<strong>NAT对外网屏蔽了内网主机的网络地址，能为内网的主机提供一定的安全保护</strong></li></ul><h3 id="NAT实现原理">NAT实现原理</h3><p>使用私有地址的主机，如何才能与因特网上使用全球IP地址的主机进行通信？</p><p>这需要在专用网络连接到因特网的路由器上安装NAT软件</p><p>专有NAT软件的路由器叫做 <strong><code>NAT路由器</code></strong></p><p>它<strong>至少</strong>有一个有效的外部全球IP地址</p><p>这样，所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换为全球IP地址</p><p>问题：当专用网中的这两台使用私有地址的主机都要给因特网使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与全球地址的对应关系；如果NAT路由器具有N个全球IP地址，那么至多只能有N个内网主机能够同时和因特网上的主机通信。</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4000.png" alt="Untitled"></p><hr>]]></content>
    
    
    <summary type="html">计网</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="计算机网络" scheme="https://agoni66.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="四大件" scheme="https://agoni66.github.io/tags/%E5%9B%9B%E5%A4%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（三）</title>
    <link href="https://agoni66.github.io/posts/1000103.html"/>
    <id>https://agoni66.github.io/posts/1000103.html</id>
    <published>2024-06-03T13:30:00.000Z</published>
    <updated>2024-09-10T01:17:33.492Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><p><font size="4"><b>计算机网络导航🚀🚀🚀</b></font></p><ol><li><p>🍕<a href="https://agoni66.github.io/posts/1000101.html">第一章 概述</a></p></li><li><p>🍔<a href="https://agoni66.github.io/posts/1000102.html">第二章 物理层</a></p></li><li><p>🍟<a href="https://agoni66.github.io/posts/1000103.html">第三章 数据链路层</a> ⇦ 当前位置🪂</p></li><li><p>🌭<a href="https://agoni66.github.io/posts/1000104.html">第四章 网际层</a></p></li><li><p>🍿<a href="https://agoni66.github.io/posts/1000105.html">第五章 运输层</a></p></li><li><p>🧂<a href="https://agoni66.github.io/posts/1000106.html">第六章 应用层</a></p></li></ol></div><div class="note warning modern"><p><b>图片加载较慢，请耐心等待！🌤️🌥️🌦️</b></p></div><h2 id="知识点一：数据链路层概述">知识点一：数据链路层概述</h2><p><strong><span class='p h3'>概述</span></strong></p><ul><li><strong><code>链路</code></strong> 是从一个结点到<strong>相邻结点</strong>的一段物理线路，而中间没有任何其他的交换节点</li><li><strong><code>数据链路</code></strong> 则是在链路的基础上增加了一些必要的<strong>硬件</strong>（如网络适配器）和<strong>软件</strong>（如协议的实现）</li><li>数据链路层以 <strong><code>帧</code></strong> 为单位 传输和处理数据</li><li><strong>注意：不同的链路层可能采用不同的数据链路层协议，但都是无确认的无连接服务</strong></li></ul><p><strong><span class='p h3'>数据链路层使用的信道</span></strong></p><p>数据链路层属于计算机网路的低层。数据链路层使用的信道主要有以下<strong>两种类型</strong>：</p><ul><li>点对点信道（一对一）</li><li>广播信道（一对多）</li></ul><p>现在，在 <code>有线（局域网）领域</code> 使用 <strong><code>点对点链路和链路层交换机的交换式局域网</code></strong> 取代了 <code>共享式局域网</code></p><p>在无线局域网中仍然使用的是 <strong><code>共享信道</code></strong> 技术</p><hr><h2 id="知识点二：封装成帧">知识点二：封装成帧</h2><p><strong><code>封装成帧</code></strong> 是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p><ul><li><p><strong>帧头和帧尾中包含有重要的控制信息</strong></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2200.png" alt="Untitled"></p></li><li><p>帧头和帧尾的作用之一就是 <strong><code>帧定界</code></strong></p><ul><li><strong>作用：</strong> 接收方的数据链路层如何从物理层交付的比特流中提取出一个个的帧</li><li>但并不是每一种数据链路层协议的帧都包含有帧定界标志，比如以太网V2的MAC帧，但是MAC帧会加上<strong>前导码</strong> ，前导码包括 <strong><code>前同步码</code></strong>（作用是使接收方的时钟同步）和 <strong><code>帧开始定界符</code></strong> （表明其后面紧跟着的就是MAC帧）</li><li>另外以太网还规定了帧间间隔为96比特时间，因此，MAC帧不需要帧结束定界符</li></ul></li></ul><p><strong>透明传输</strong></p><p><strong><code>透明传输</code></strong> 是指数据链路层对上层交付的传输数据没有任何限制，好像数据链路层不存在一样</p><blockquote><p>个人理解 就是无论网络层传什么文件，数据链路层都可以把数据传给对面的数据链路层</p></blockquote><p>特殊情况</p><ul><li>帧界定标志也就是个特定数据值，如果在上层交付的协议数据单元中， 恰好也包含这个特定数值，接收方就不能正确接收</li><li><strong>解决方法</strong>：面向字节的物理链路使用 <strong><code>字节填充</code></strong> (byte stuffing) 或 <strong><code>字符填充</code></strong> (character stuffing)，面向比特的物理链路使用比特填充的方法实现透明传输</li><li>发送端的数据链路层在数据中出现 <strong>控制字符 <code>“SOH”</code>或 <code>“EOT”</code></strong> 的前面插入一个 <strong><code>转义字符“ESC”</code> (其十六进制编码是1B，数值是27)</strong></li><li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符</li><li>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个</li></ul><p><strong>帧的数据部分长度</strong></p><p>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些</p><p>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即 <strong><code>最大传送单元MTU</code></strong> (Maximum Transfer Unit)</p><p><strong>流量控制</strong></p><p>限制发送方的数据流量</p><hr><h2 id="✨知识点三：差错检测">✨知识点三：差错检测</h2><ul><li><strong><code>比特差错</code></strong>  实际的通信链路都不是理想的，比特在传输过程中可能会产生差错:1可能会变成0而0也可能变成1</li><li>在一段时间内，传输错误的比特占所传输比特总数的比率称为 <strong><code>误码率BER</code></strong> (Bit Error Rate)</li><li>使用 <strong><code>差错检测码</code></strong> 来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一</li></ul><hr><h3 id="奇偶校验"><strong>奇偶校验</strong></h3><ul><li>在待发送的数据后面添加1位奇偶校验位，使整个数据(包括所添加的校验位在内)中“1”的个数为奇数(奇校验)或偶数(偶校验)。</li><li>如果有奇数个位发生误码，则奇偶性发生变化，可以检查出误码</li><li>如果有偶数个位发生误码，则奇偶性不发生变化，不能检查出误码(<strong>漏检</strong>)</li></ul><hr><h3 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><strong>循环冗余校验CRC(Cyclic Redundancy Check)</strong></h3><ul><li>收发双方约定好一个 <strong><code>生成多项式G(x)</code></strong></li><li>发送方基于待发送的数据和生成多项式计算出 <strong><code>差错检测码</code>(冗余码)</strong> 将其添加到待传输数据的后面一起传输</li><li>接收方通过生成多项式来计算收到的数据是否产生了误码</li></ul><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2300.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2301.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2302.png" alt="Untitled"></p><p>发送方需要后面补最高次数个零，接收方不需要补零，中间的计算是异或计算（同 0 异 1）</p><p><strong><code>帧校验序列 FCS</code></strong> 是添加在数据后面的冗余码</p><div class="note warning no-icon flat"><p>🍠 注意：数据链路层仅适应了CRC的检错功能，检查到帧出错直接丢弃，是为了方便协议的实现，CRC其实也有纠错功能</p></div><hr><h2 id="知识点四：可靠传输">知识点四：可靠传输</h2><ul><li>使用 <strong><code>差错检测技术</code></strong> (例如循环冗余校验CRC)，接收方的数据链路层就可检测出帧在传输过程中是否产生了<strong>误码</strong>(比特错误)。</li><li>数据链路层向上层提供的服务类型<ul><li><strong><code>不可靠传输服务</code> 仅仅丢弃</strong> 有误码的帧，其他什么也不做（视频通话中的卡顿）</li><li><strong><code>可靠传输服务</code></strong> 想办法实现<strong>发送端发送什么，接收端就收到什么</strong>（例子：发送图片）</li></ul></li><li>一般情况下， <strong><code>有线链路</code></strong> 的误码率比较低，为了减小开销，并<strong>不要求数据链路层</strong>向上提供可靠传输服务，即使出现了误码，可靠传输的问题由其上层处理</li><li><strong><code>无线链路</code></strong> 易受干扰，误码率比较高，因此要求数据链路层必须向上层提供 <strong><code>可靠传输服务</code></strong></li><li><strong>比特差错</strong>只是传输差错中的一种。</li><li>从整个计算机网络体系结构来看，传输差错还包括 <strong><code>分组丢失</code> <code>分组失序</code> 以及 <code>分组重复</code></strong><ul><li>分组丢失：路由器输入队列快满了，主动丢弃收到的分组</li><li>分组失序：数据并未按照发送顺序依次到达接收端</li><li>分组重复：由于某些原因，有些分组在网络中滞留了，没有及时到达接收端，这可能会造成发送端对该分组的<strong>重发</strong>，重发的分组到达接收端，但一段时间后，滞留在网络的分组也到达了接收端，这就造成分组重复的传输差错</li></ul></li><li><strong>可靠传输服务并不仅局限于数据链路层</strong>，其余各层均可选择实现可靠传输<ul><li>TCP向其上层提供面向连接的可靠传输服务</li><li>UDP向其上层提供无连接、不可靠传输服务</li><li>IP向其上层提供无连接、不可靠传输服务</li><li>802.11无线局域网要求数据链路层实现可靠传输</li><li>以太网不要求数据链路层实现可靠传输</li></ul></li></ul><hr><h2 id="✨知识点五：流量控制三种可靠协议">✨知识点五：流量控制三种可靠协议</h2><p><code>停止-等待协议SW</code></p><p><code>回退N帧协议GBN</code></p><p><code>选择重传协议SR</code></p><p>这三种协议是一点一点递进的，计算机网络知识也是一点一点递进的</p><div class="note danger no-icon flat"><p>⛔ <strong>停止-等待协议SW</strong></p></div><ul><li>接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方<strong>尽早重传</strong>，也可给发送方<strong>发送NAK分组</strong></li><li>为了让接收方能够判断所收到的数据分组是否是重复的，需要给<strong>数据分组编号</strong>。由于<strong>停止-等待协议</strong>的停等特性，<strong>只需1个比特编号</strong>就够了，即编号0和1</li><li>为了让发送方能够判断所收到的ACK分组是否是重复的，需要给<strong>ACK分组编号</strong>，所用比特数量与数据分组编号所用比特数量<strong>一样</strong>（一个即可）数据链路层一般不会出现ACK分组迟到的情况，因此<strong>在数据链路层实现停止-等待协议可以不用给ACK分组编号</strong></li><li>超时计时器设置的重传时间应仔细选择。一般可将<strong>重传时间</strong>选为<strong>略大于“从发送方到接收方的平均往返时间”</strong><ul><li>在数据链路层点对点的往返时间比较确定，重传时间比较好设定</li><li>然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。</li></ul></li></ul><h3 id="四种问题">四种问题</h3><ol><li>确认与否认</li><li>超时重传</li><li>确认丢失</li><li>确认迟到</li></ol><p><strong>停止-等待协议的信道利用率</strong></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2500.png" alt="Untitled"></p><ul><li><code>TD</code> 是发送方发送数据分组所耗费的发送时延</li><li><code>RTT</code> 是收发双方之间的往返时间</li><li><code>TA</code> 是接收方发送确认分组所耗费的发送时延</li></ul><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2501.png" alt="Untitled"></p><ul><li>当往返时延RTT远大于数据帧发送时延T时(例如使用卫星链路)，信道利用率非常低</li><li>若出现重传，则对于传送有用的数据信息来说，信道利用率还要降低</li><li>为了克服停止-等待协议信道利用率很低的缺点，就产生了另外两种协议，即后退N帧协议GBN和选择重传协议SR</li></ul><blockquote><p><strong>自动请求重传协议ARQ</strong>(Automatic Repeat reQuest)<br>像停止-等待协议这样通过确认和重传机制实现的可靠传输协议，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p></blockquote><div class="note danger no-icon flat"><p>⛔ <strong>回退N帧协议GBN</strong></p></div><p>在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组</p><p>回退N帧协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数</p><h3 id="过程">过程</h3><p><strong>无差错情况</strong></p><p>发送方将序号落在发送窗口内的0~4号数据分组，依次连续发送出去</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2502.png" alt="Untitled"></p><p>他们经过互联网传输正确到达接收方，就是没有乱序和误码，接收方按序接收它们，<strong>每接收一个，接收窗口就向前滑动一个位置</strong>，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2503.png" alt="Untitled"></p><p><strong>发送方每接收一个、发送窗口就向前滑动一个位置</strong>，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2504.png" alt="Untitled"></p><h3 id="累计确认"><strong>累计确认</strong></h3><ul><li>接收方<strong>不一定</strong>要对收到的数据分组<strong>逐个发送确认</strong>，而是可以在收到几个数据分组后(由具体实现决定)<strong>对按序到达的最后一个数据分组发送确认</strong>。</li><li>ACK<sub>n</sub>表示序号为<strong>n及以前的所有数据分组都已正确接收</strong>。</li><li>优点:<ul><li>即使确认分组丢失，发送方也可能不必重传</li><li>减小接收方的开销</li><li>减小对网络资源的占用</li></ul></li><li>缺点：<ul><li>不能向发送方及时反映出接收方已经<strong>正确接收的数据分组信息</strong>（展示：有差错情况）</li></ul></li></ul><p><strong>Q：若WT超过取值范围，例如WT=8，会出现什么情况？</strong></p><p>A：接收方无法辨别新旧的数据分组</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2505.png" alt="Untitled"></p><h3 id="总结">总结</h3><ul><li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种<strong>连续ARQ协议</strong></li><li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为<strong>滑动窗口协议</strong></li><li>由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并<strong>不比停止-等待协议高</strong></li></ul><div class="note danger no-icon flat"><p>⛔ <strong>选择重传协议SR</strong></p></div><ul><li><p><strong>回退N帧协议</strong>的接收窗口尺寸w<sub>r</sub> <strong>只能等于1</strong>，因此<strong>接收方只能按序接收正确到达的数据分组</strong></p></li><li><p>一个数据分组的误码就会导致其后续多个数据分组不能被接收方按序接收而丢弃(尽管它们无乱序和误码)。这必然会造成发送方对这些数据分组的超时重传，显然这是对通信资源的极大浪费</p></li><li><p>为了进一步提高性能，可设法只重传出现误码的数据分组。因此，接收窗口的尺寸w<sub>r</sub><strong>不应再等于1(而应大于1)</strong>，以便<strong>接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组</strong>，等到所缺分组收齐后再一并送交上层。这就是<strong>选择重传协议</strong></p></li><li><p>注意:</p><ul><li>选择重传协议为了使发送方仅重传出现差错的分组，接收方<strong>不能再采用累积确认</strong>，而需要对每个正确接收到的数据分组进行<strong>逐一确认</strong>!</li></ul><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2506.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2507.png" alt="Untitled"></p></li></ul><hr><h2 id="✨知识点六：PPP协议">✨知识点六：PPP协议</h2><p><code>点对点协议PPP</code>（Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层<strong>协议</strong></p><p><code>PPPoE</code> 是为宽带上网的主机使用的链路层协议，也就是说基本上使用PPPoE</p><p>PPP协议为在点对点链路传输各种协议数据报提供了一个<strong>标准方法</strong>（<strong>意思就是这就是标准，但也仅此而已</strong>），主要由以下<strong>三部分</strong>构成：</p><ol><li>对各种协议数据报的封装方法(封装成帧)</li><li>链路控制协议LCP 用于建立、配置以及测试数据链路的连接</li><li>一套网络控制协议NCPS 其中的每一个协议支持不同的网络层协议</li></ol><h3 id="帧格式">帧格式</h3><p>必须<strong>规定特殊</strong>的字符作为帧定界符</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2600.png" alt="Untitled"></p><ul><li><p>标志(Flag)字段:PPP帧的定界符，取值为0x7E</p></li><li><p>地址(Address)字段:取值为0xFF，预留(目前没有什么作用)</p></li><li><p>控制(Control)字段:取值为0x03，预留(目前没有什么作用)</p></li><li><p>协议(Protocol)字段:指明帧的数据部分送交哪个协议处理</p><ul><li>取值0x0021表示:帧的数据部分为IP数据报</li><li>取值0xC021表示:帧的数据部分为LCP分组</li><li>取值0x8021表示:帧的数据部分为NCP分组</li><li></li></ul><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2601.png" alt="Untitled"></p></li><li><p>帧检验序列(Frame Check Sequence)字段:CRC计算出的校验位</p></li></ul><h3 id="透明传输">透明传输</h3><p>实现透明传输的方法</p><h3 id="面向-字节的异步链路：-字节填充法（插入“转义字符”）">面向 <code>字节</code>的异步链路： <code>字节填充法</code>（插入“转义字符”）</h3><p>发送方的处理：</p><table><thead><tr><th>出现的每一个7E(PPP帧的定界符)</th><th>字节转变成2字节序列(7D,5E)</th></tr></thead><tbody><tr><td>出现的每一个7D(转义字符)</td><td>字节转变成2字节序列(7D,5D)</td></tr><tr><td>出现的每一个ASCII码控制字符(数值小于0x20的字符)</td><td>该字符前面插入一个7D字节，同时将该字符的编码加上0x20</td></tr></tbody></table><p>接收方的处理：进行 <strong><code>反变换</code></strong> 即可恢复出原来的帧的数据部分</p><h3 id="面向-比特的同步链路：-比特填充法（插入“比特0”）">面向 <code>比特</code>的同步链路： <code>比特填充法</code>（插入“比特0”）</h3><p>发送方的处理：</p><p>对帧的数据部分进行扫描(一般由硬件实现)。只要<strong>发现5个连续的比特1，则立即填充1个比特0</strong></p><p>接收方的处理：</p><p>对帧的数据部分进行扫描(一般由硬件实现)。只要<strong>发现5个连续的比特1，就把其后的1个比特0删除</strong></p><h3 id="差错检测">差错检测</h3><p>能够对接收端收到的帧进行检测，并立即丢弃有差错的帧</p><p>接收方每收到一个PPP帧，就进行CRC检验。若CRC检验正确，就收下这个帧；反之，就丢弃这个帧。使用PPP的数据链路层向上不提供可靠传输服务</p><h3 id="工作状态">工作状态</h3><ol><li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li><li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li><li>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机</li><li>分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li><li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接</li></ol><hr><h2 id="知识点七：媒体接入控制（介质访问控制）——广播信道">知识点七：媒体接入控制（介质访问控制）——广播信道</h2><p><code>媒体接入控制</code>（介质访问控制）使用 <code>一对多</code>的 <code>广播通信</code>方式</p><p><strong><span class='p h3'>局域网的数据链路层</span></strong></p><p>局域网最主要的<strong>特点</strong>是：</p><ul><li>网络为一个单位所拥有</li><li>地理范围和站点数目均有限</li></ul><p>局域网具有如下主要<strong>优点</strong>：</p><ul><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变</li><li>提高了系统的可靠性、可用性和残存性</li></ul><p>Q：为什么要媒体接入控制（介质访问控制）？</p><p>若多个设备在共享信道上同时发送数据，则会造成彼此干扰，导致发送失败</p><p>共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即 <strong><code>媒体接入控制MAC</code></strong>(Medium Access Control)。</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2700.png" alt="Untitled"></p><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用<strong>点对点链路和链路层交换机的交换式局域网</strong>在<strong>有线领域</strong>已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是<strong>共享媒体技术</strong></p><hr><h2 id="✨知识点八：CSMA-CD协议">✨知识点八：CSMA/CD协议</h2><h3 id="随机接入（CSMA-CD协议）"><strong>随机接入（CSMA/CD协议）</strong></h3><p>多用于 <strong><code>有线协议</code></strong></p><p>载波监听多址接入/碰撞检测<br>CSMA/CD(Carrier Sense Multiple Access/Collision Detection)</p><ol><li><strong>多址接入MA</strong></li></ol><p>表示许多主机以多点接入的方式连接在一根总线上</p><ol start="2"><li><strong>载波监听CS</strong></li></ol><p>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞 <strong>(先听后说)</strong></p><blockquote><p>信道空闲96比特时间</p></blockquote><ol start="3"><li><strong>碰撞检测CD</strong></li></ol><ul><li>“<strong>碰撞检测</strong>”就是计算机<strong>边发送数据边检测</strong>信道上的信号电压大小。</li><li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）</li><li>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞</li><li><strong>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”</strong></li><li>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来</li><li><strong>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送</strong></li><li>以太网还采取一种叫做<strong>强化碰撞</strong>的措施。这就是当发送帧的站点一旦检测到碰撞，除了立即停止发送帧外，还要再继续发送<strong>32比特或48比特的人为干扰信号</strong>(Jamming Signal)，以便<strong>有足够多的碰撞信号使所有站点都能检测出碰撞</strong></li></ul><h3 id="CSMA-CD-协议工作流程"><strong>CSMA/CD 协议工作流程</strong></h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2800.png" alt="Untitled"></p><h3 id="CSMA-CD-协议工作——争用期（碰撞窗口）"><strong>CSMA/CD 协议工作——争用期（碰撞窗口）</strong></h3><ul><li>主机最多经过2T(即8-0)的时长就可检测到本次发送是否遭受了碰撞</li><li>因此，以太网的端到端往返传播时延2t称为 <strong><code>争用期</code></strong> 或 <strong><code>碰撞窗口</code></strong></li><li>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞</li><li>每一个主机在自己发送帧之后的一小段时间内，存在着遭遇碰撞的可能性。这一小段时间是不确定的。它取决于另一个发送帧的主机到本主机的距离，但不会超过总线的端到端往返传播时延，即<strong>一个争用期时间</strong></li><li>显然，在以太网中发送帧的主机越多，端到端往返传播时延越大，发生碰撞的概率就越大。因此，<strong>共享式以太网不能连接太多的主机，使用的总线也不能太长</strong><ul><li>10Mb/s以太网把争用期定为<strong>512比特</strong>发送时间，即51.2us，因此其总线长度不能超过5120m，但考虑到其他一些因素，如信号衰减等，以太网规定总线长度不能超过2500m</li></ul></li></ul><h3 id="CSMA-CD-协议工作——最小帧长"><strong>CSMA/CD 协议工作——最小帧长</strong></h3><ul><li>以太网规定最小帧长为 <strong><code>64字节</code></strong>，即512比特(512比特时间即为争用期)<ul><li>如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节</li></ul></li><li>以太网的<strong>最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞</strong><ul><li>如果在争用期(共发送64字节)没有检测到碰撞，那么后续发送的数据就一定不会发生碰撞</li><li>如果在争用期内检测到碰撞，就立即中止发送，这时已经发送出去的数据一定小于64字节，因此凡<strong>长度小于64字节的帧都是由于碰撞而异常中止的无效帧</strong></li></ul></li></ul><h3 id="CSMA-CD-协议工作——最大帧长"><strong>CSMA/CD 协议工作——最大帧长</strong></h3><p>为了 <strong><code>避免一直占用总线</code></strong></p><table><thead><tr><th>以太网V2的MAC帧</th><th>最大长度为1518字节</th></tr></thead><tbody><tr><td>插入VLAN标记后的802.1Q帧</td><td>最大长度为1522字节</td></tr></tbody></table><h3 id="CSMA-CD-协议工作——截断二进制指数退避算法"><strong>CSMA/CD 协议工作——截断二进制指数退避算法</strong></h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2801.png" alt="Untitled"></p><ul><li>若连续多次发生碰撞，就表明可能有较多的主机参与竞争信道。但使用上述退避算法可<strong>使重传需要推迟的平均时间随重传次数而增大</strong>(这也称为<strong>动态退避</strong>)，因而<strong>减小发生碰撞的概率</strong>，有利于整个系统的稳定。</li><li><strong>当重传达16次仍不能成功时</strong>，表明同时打算发送帧的主机太多，以至于连续发生碰撞，则<strong>丢弃该帧</strong>，并向高层报告</li></ul><h3 id="CSMA-CD-协议工作——信道利用率"><strong>CSMA/CD 协议工作——信道利用率</strong></h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2802.png" alt="Untitled"></p><h3 id="CSMA-CD-协议工作——帧接收流程"><strong>CSMA/CD 协议工作——帧接收流程</strong></h3><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2803.png" alt="Untitled"></p><h3 id="CSMA-CD-协议的重要特性"><strong>CSMA/CD 协议的重要特性</strong></h3><p>使用 CSMA/CD<br>协议的以太网不能进行全双工通信而 <strong><code>只能进行双向交替通信（半双工通信）</code></strong></p><p>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</p><p>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</p><p>CSMA/CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。</p><p><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA/CD协议</strong></p><hr><h2 id="✨知识点九：CSMA-CA协议">✨知识点九：CSMA/CA协议</h2><h3 id="无线局域网使用的协议：CSMA-CA"><strong>无线局域网使用的协议：CSMA/CA</strong></h3><p><strong>Q：无限局域网为什么不能使用CSMA/CD</strong></p><ul><li><strong>在无线局域网中，仍然可以使用载波监听多址接入CSMA</strong>，即在发送帧之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以免发生碰撞</li><li><strong>在无线局域网中，不能使用碰撞检测CD</strong>，原因如下:<ul><li>由于无线信道的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度(可能相差百万倍)。<strong>如果要在无线网卡上实现碰撞检测CD，对硬件的要求非常高</strong></li><li>即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性(<strong>存在隐蔽站问题</strong>)，<strong>进行碰撞检测的意义也不大</strong></li></ul></li><li><strong>802.11无线局域网</strong>使用CSMA/CA协议，在CSMA的基础上增加了一个<strong>碰撞避免CA功能</strong>，而不再实现碰撞检测功能。</li><li>由于<strong>不可能避免所有的碰撞</strong>并且<strong>无线信道误码率较高</strong>，802.11标准还使用了**数据链路层确认机制(停止-等待协议)**来保证数据被正确接收</li><li>802.11的MAC层标准定义了两种不同的媒体接入控制方式:<ul><li><strong>分布式协调功能DCF(Distributed Coordination Function)</strong>。在DCF方式下，没有中心控制站点，每个站点使用CSMA/CA协议通过争用信道来获取发送权，这是802.11定义的默认方式</li><li><strong>点协调功能PCF(Point Coordination Function)</strong>。PCF方式使用集中控制的接入算法(一般在接入点AP实现集中控制)，是802.11定义的可选方式，在实际中较少使用</li></ul></li></ul><h3 id="帧间间隔IFS（InterFrame-Space）"><strong>帧间间隔IFS（InterFrame Space）</strong></h3><ul><li>802.11标准规定，所有的<strong>站点必须在持续检测到信道空闲一段指定时间后才能发送帧</strong>，这段时间称为<strong>帧间间隔IFS</strong></li><li>帧间间隔的长短取决于该站点要发送的帧的类型:<ul><li>高优先级帧需要等待的时间较短，因此可优先获得发送权;</li><li>低优先级帧需要等待的时间较长。若某个站的低优先级帧还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级帧就只能再推迟发送了。这样就减少了发生碰撞的机会</li></ul></li><li>常用的两种帧间间隔如下:<ul><li><strong>短帧间间隔SIFS(28us)</strong>，是最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方式切换到接收方式。使用SIFS的帧类型有ACK帧、CTS帧、由过长的MAC帧分片后的数据帧、以及所有回答AP探询的帧和在PCF方式中接入点AP发送出的任何帧</li><li><strong>DCF帧间间隔DIFS(128us)</strong>，它比短帧间间隔SIFS要长得多，在DCF方式中用来发送数据帧和管理帧</li></ul></li></ul><div class="note danger no-icon flat"><p>🔑 <strong>CSMA/CA协议的工作原理</strong></p></div><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2900.png" alt="Untitled"></p><p>Q：源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</p><p>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</p><p>Q：目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</p><p><strong>SIFS是最短的帧间间隔</strong>，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式<strong>切换</strong>到接收方式</p><p>Q：信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</p><p><strong>防止多个站点同时发送数据而产生碰撞</strong></p><h3 id="CSMA-CA协议的退避算法">CSMA/CA协议的退避算法</h3><p>使用退避算法的时机</p><ol><li>当站点检测到信道是空闲的，并且所发送的数据帧不是成功发送完上一个数据帧之后立即连续发送的数据帧则不使用退避算法。</li><li>以下情况必须使用退避算法:<ol><li>在发送数据帧之前检测到信道处于忙状态时;</li><li>在每一次重传一个数据帧时;</li><li>在每一次成功发送后要连续发送下一个帧时(这是为了避免一个站点长时间占用信道)</li></ol></li></ol><p>在执行退避算法时，站点为退避计时器设置一个随机的退避时间：</p><ul><li>当退避计时器的时间减小到零时，就开始发送数据</li><li>当退避计时器的时间还未减小到零时而信道又转变为忙状态，这时就<strong>冻结</strong>退避计时器的数值，重新等待信道变为空闲，<strong>再经过时间DIFS后，继续启动退避计时器（解冻）</strong></li></ul><p>在进行第i次退避时，退避时间在时隙编号{0，1，…，2?、1}中随机选择一个，然后乘以基本退避时间(也就是一个时隙的长度)就可以得到随机的退避时间。这样做是为了使不同站点选择相同退避时间的概率减少。当时隙编号达到255时(对应于第6次退避)就不再增加了</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2901.png" alt="Untitled"></p><h3 id="CSMA-CA协议的信道预约和虚拟载波监听"><strong>CSMA/CA协议的信道预约和虚拟载波监听</strong></h3><p>为了 <strong><code>尽可能减少碰撞的概率</code></strong> 和降低碰撞的影响，802.11标准允许要发送数据的站点 <strong><code>对信道进行预约</code></strong></p><ol><li>源站在发送数据帧之前先发送一个短的控制帧，称为<strong>请求发送</strong>RTS（Request To<br>Send），它包括源地址、目的地址以及这次通信（包括相应的确认帧）所需的<strong>持续时间</strong>。</li><li>若目的站正确收到源站发来的RTS帧，且媒体空闲，就发送一个响应控制帧，称为<strong>允许发送CTS</strong>（Clear To Send），它也包括这次通信所需的持续时间（从RTS帧中将此持续时间复制到CTS顿中）</li><li>源站收到CTS帧后，再等待一段时间SIFS后，就可发送其数帧。</li><li>若目的站正确收到了源站发来的数据帧，在等待时间SIFS后，就向源站发送确认帧ACK</li></ol><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2902.png" alt="Untitled"></p><h3 id="解决隐蔽站问题">解决隐蔽站问题</h3><p>A和C互为隐蔽站</p><p>A发送RTS后，接受站向自己的领域发送CTS，C站虽然不知道A站的存在，但从CTS中得知信道需要占用一段时间，那么在这段时间内C站不能发送帧，A站在这段时间可以尽情发送数据帧</p><hr><h2 id="✨知识点十：MAC地址、IP地址、ARP协议">✨知识点十：MAC地址、IP地址、ARP协议</h2><p>MAC地址是以太网的MAC子层所使用的地址 <strong><code>（数据链路层）</code></strong></p><p>IP地址是TCP/IP体系结构网络层所使用的地址 <strong><code>（网际层）</code></strong></p><p>ARP协议属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址 <strong><code>（网际层）</code></strong></p><hr><h3 id="MAC地址">MAC地址</h3><p>使用点对点信道的数据链路层不需要使用地址</p><p>使用广播信道的数据链路层 <strong><code>必须使用地址</code></strong> 来区分各主机</p><p><strong><code>MAC地址</code></strong> 在每个主机发送的帧中必须<strong>携带标识发送主机和接收主机的地址</strong>。由于这类地址是用于<strong>媒体接入控制MAC</strong>(MediaAccessControl)</p><ul><li>MAC地址一般被固化在网卡(网络适配器)的电可擦可编程只读存储器EEPROM中，因此MAC地址也被称为 <strong><code>硬件地址</code></strong></li><li>MAC地址有时也被称为 <strong><code>物理地址</code></strong>。请注意：这并不意味着MAC地址属于网络体系结构中的物理层!</li></ul><hr><p><strong><code>IEEE 802局域网的MAC地址格式</code></strong></p><p>一共六个字节，48位，前三个字节是OUI，后三个字节是网络接口标识符</p><p><strong><code>组织唯一标识符OUI</code></strong></p><ul><li>生产网络设备的厂商，需要向IEEE的注册管理机构申请一个或多个OUI</li></ul><p><strong><code>网络接口标识符</code></strong></p><ul><li>由获得OUI的厂商自行随意分配</li></ul><p><strong><code>EUI-48</code></strong></p><ul><li>48是这个MAC地址的位数</li></ul><p><strong><code>单播、多播、全球、本地</code></strong></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3000.png" alt="Untitled"></p><p><strong><code>关于无效的 MAC 帧</code></strong></p><ol><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>数据字段的长度不在 46 ~ 1500 字节之间。</li><li>有效的 MAC 帧长度为 64 ~ 1518 字节之间</li></ol><p><strong><code>IEEE 802局域网的MAC地址发送顺序</code></strong></p><table><thead><tr><th>字节发送顺序</th><th>第一字节→第六字节</th></tr></thead><tbody><tr><td>字节内的比特发送顺序</td><td>b_0→b_7</td></tr></tbody></table><hr><h2 id="单播MAC地址举例">单播MAC地址举例</h2><p>主机B给主机C发送<strong>单播帧</strong>，主机B首先要构建该<strong>单播帧</strong>，<strong>在帧首部中的目的地址字段填入主机C的MAC地址</strong>，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该<strong>单播帧</strong></p><p><strong><code>过程</code></strong></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3001.png" alt="Untitled"></p><ol><li>主机B将该单播帧发送出去，主机A和C都会收到该单播帧</li><li>主机A的网卡发现该单播帧的目的MAC地址与自己的MAC地址不匹配，丢弃该帧</li><li>主机C的网卡发现该单播帧的目的MAC地址与自己的MAC地址匹配，接受该帧</li><li>并将该帧交给其上层处理</li></ol><h3 id="广播MAC地址举例">广播MAC地址举例</h3><p>假设主机B要发送一个<strong>广播帧</strong>，主机B首先要构建该<strong>广播帧</strong>，<strong>在帧首部中的目的地址字段填入广播地址</strong>，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>广播帧</strong></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3002.png" alt="Untitled"></p><p>主机B讲该<strong>广播帧</strong>发送出去，主机A和C都会收到该<strong>广播帧</strong>，<strong>发现该帧首部中的目的地址字段的内容是广播地址</strong>，就知道该帧是<strong>广播帧</strong>，主机A和主机C都接受该帧，并将该帧交给上层处理</p><h3 id="多播MAC地址举例">多播MAC地址举例</h3><p>假设主机A要发送<strong>多播帧</strong>给该<strong>多播地址</strong>。将该<strong>多播地址</strong>的左起第一个字节写成8个比特，第一个字节的最低比特位是1，这就表明该地址是<strong>多播地址</strong></p><p>快速判断地址是不是<strong>多播地址</strong>，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是<strong>多播地址</strong></p><p>假设主机B，C和D支持多播，各用户给自己的主机配置多播组列表如下所示</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3003.png" alt="Untitled"></p><p>主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组</p><p><strong><code>过程</code></strong></p><ol><li>主机A首先要构建该<strong>多播帧</strong>，<strong>在帧首部中的目的地址字段填入该多播地址</strong>，源地址点填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>多播帧</strong></li><li>主机A将该<strong>多播帧</strong>发送出去，主机B、C、D都会收到该<strong>多播帧</strong></li><li><strong>主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中</strong>，主机B和C都会接受该帧</li><li>主机D发现该<strong>多播帧</strong>的目的MAC地址不在自己得多播组列表中，则丢弃该<strong>多播帧</strong></li></ol><div class="note info no-icon flat"><p><strong>⚛️ IP地址</strong></p></div><p>IP地址属于网络层的范畴，不属于数据链路层的范畴</p><p><strong>IP地址</strong>是因特网(Internet)上的主机和路由器所使用的地址，用于标识<strong>两部分信息</strong></p><ul><li><strong>网络编号</strong>：标识因特网上数以百万计的网络</li><li><strong>主机编号</strong>：标识同一网络上不同主机(或路由器各接口)</li></ul><p><strong>IP地址和MAC地址在网络体系结构</strong></p><p>IP地址在网络层首部</p><p>MAC地址在链路层首部</p><p><strong>数据包转发过程中IP地址与MAC地址的变化情况</strong></p><p>数据包转发过程中<strong>源IP地址和目的IP地址保持不变</strong></p><p>数据包转发过程中<strong>源MAC地址和目的MAC地址逐个链路</strong>(或逐个网络)改变</p><p>Q：如何从IP地址找出其对应的MAC地址？</p><div class="note info no-icon flat"><p>📖 <strong>ARP协议（地址解析协议）</strong></p></div><p><strong>ARP高速缓存表</strong></p><ol><li>当主机B要给主机C发送数据包时，会首先在<strong>自己的ARP高速缓存表中</strong>查找主机C的IP地址所对应的MAC地址，但未找到，因此，主机B需要<strong>发送ARP请求报文</strong>，来获取主机C的MAC地址</li><li><strong>ARP请求报文</strong>被封装在<strong>MAC帧</strong>中发送，目的地址为<strong>广播地址</strong>，主机B发送封装有ARP请求报文的广播帧，<strong>总线上的其他主机都能收到该广播帧</strong></li><li>收到ARP请求报文的主机A和主机C会把ARP<strong>请求报文交给上层</strong>的ARP进程：主机A发现所询问的IP地址不是自己的IP地址，因此不用理会；主机C的发现所询问的IP地址是自己的IP地址，需要进行<strong>响应（单播</strong>，发送IP地址和MAC地址到目的地址**）**</li></ol><p><strong>动态与静态的区别</strong></p><p>动态：自动获取，生命周期默认为两分钟;</p><p>静态：手工设置，不同操作系统下的生命周期不同，例如系统重启后不存在或系统重启后依然有效。</p><p><strong>ARP协议的作用范围：</strong></p><p><strong>ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用</strong></p><p>除ARP请求和响应外，ARP还有其他类型的报文(例如用于检查IP地址冲突的“无故ARP、免费ARP(Gratuitous<br>ARP)”)</p><p>ARP没有安全验证机制，存在<strong>ARP欺骗(攻击)问题</strong></p><p>ARP表中的IP地址与MAC地址的对应关系记录，是会<strong>定期自动删除的</strong>，因为IP地址与MAC地址的对应关系<strong>不是永久性的</strong></p><hr><h2 id="✨知识点十一：集线器与交换机的区别">✨知识点十一：集线器与交换机的区别</h2><h3 id="集线器-在物理层扩展以太网"><strong>集线器-在物理层扩展以太网</strong></h3><ul><li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用的还是<strong>CSMA/CD协议，只能工作在半双工模式，收发帧不能同时进行</strong></li><li><strong>集线器只工作在物理层</strong>，它的每个接口仅简单地转发比特，不进行碰撞检测(由各站的网卡检测)</li><li><strong>集线器一般都有少量的容错能力和网络管理功能</strong>。例如，若网络中某个网卡出了故障，不停地发送帧。此时，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网仍然能正常工作</li></ul><h3 id="集线器HUB在物理层扩展以太网"><strong>集线器HUB在物理层扩展以太网</strong></h3><p>使用集线器扩展：将多个以太网段连成更大的、多级星形结构的以太网**（物理层）**</p><p>优点：</p><ol><li>使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信</li><li>扩大了以太网覆盖的地理范围</li></ol><p>缺点：</p><ol><li>碰撞域增大了，但总的吞吐量并未提高。</li><li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来</li></ol><p><strong><code>碰撞域</code></strong></p><ul><li><strong><code>碰撞域</code></strong>（collision domain）又称为 <strong><code>冲突域</code></strong>，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</li><li>碰撞域越大，发生碰撞的概率越高</li></ul><h3 id="以太网交换机-在数据链路层扩展以太网"><strong>以太网交换机-在数据链路层扩展以太网</strong></h3><p>交换式集线器常称为以太网交换机<br>(switch) 或第二层交换机 (L2 switch)，强调这种交换机工作在<strong>数据链路层</strong></p><p>以太网交换机实质上就是一个<strong>多接口的网桥</strong></p><div class="note danger no-icon flat"><p>📢 <strong>集线器HUB与交换机SWITCH区别</strong></p></div><ul><li>以太网交换机通常都有<strong>多个接口</strong>。每个接口都可以直接与一台主机或另一个以太网交换机相连。一般都工作在<strong>全双工方式</strong></li><li>以太网交换机具有<strong>并行性</strong>，能同时<strong>连通多对接口</strong>，使<strong>多对主机能同时通信</strong>，无碰撞(不使用CSMA/CD协议)</li><li>以太网交换机一般都具有多种速率的接口，例如：10Mb/s、100Mb/s、1Gb/s、10Gb/s接口的多种组合。</li><li>以太网交换机工作在数据链路层(也包括物理层)，它收到后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧</li><li>以太网交换机是一种<strong>即插即用</strong>设备，其内部的帧交换表是通过<strong>自学习算法</strong>自动地逐渐建立起来的。</li><li>帧的两种转发方式:<ol><li>存储转发（把整个数据帧 <strong><code>先缓存</code></strong> 后再进行处理）</li><li>直通交换:采用基于硬件的交叉矩阵(交换时延非常小，但 <strong><code>不检查帧是否有差错</code></strong> )</li></ol></li></ul><p><strong>单播：</strong></p><ol><li>使用交换机互连而成的交换式以太网上的某个主机，要给<strong>另一个主机发送单播帧</strong>，该单播帧进入交换机后，<strong>交换机会将该单播帧转发给目的主机，而不是网络中的其他各个主机</strong></li><li><strong>不碰撞</strong>（会将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞）</li></ol><p><strong>广播：没区别</strong></p><p><strong>多个单播</strong></p><p>集线器：扩大广播域，扩大碰撞域</p><p>交换机：扩大广播域 <strong>，隔离碰撞域</strong></p><p>广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收</p><hr><h2 id="知识点十二：以太网交换机的生成树协议STP">知识点十二：以太网交换机的生成树协议STP</h2><p><strong>目的：提高以太网的可靠性</strong></p><p><strong>做法：<strong>添加</strong>冗余链路</strong></p><p>影响：形成<strong>网络环路</strong></p><ul><li><strong>广播风暴</strong></li></ul><p>大量消耗网络资源，使得网络无法正常转发其他数据帧</p><ul><li><strong>主机收到重复的广播帧</strong></li></ul><p>大量消耗主机资源</p><ul><li><strong>交换机的帧交换表震荡(漂移)</strong></li></ul><p>故，提出<strong>生成树协议STP</strong></p><ul><li>可以在增加冗余链路来提高网络可靠性的同时又<strong>避免网络环路带来的各种问题</strong></li><li>不论交换机之间采用怎样的物理连接，交换机都能够<strong>自动计算并构建一个逻辑上没有环路的网络</strong>，其<strong>逻辑拓扑结构</strong>必须是<strong>树型的(无逻辑环路)</strong></li><li>最终生成的树型逻辑拓扑要<strong>确保连通整个网络</strong></li><li>当首次连接交换机或网络物理拓扑<strong>发生变化</strong>时(有可能是人为改变或故障)，交换机都将进行<strong>生成树的重新计算</strong></li><li>其要点是：<strong>不改变网络的实际拓扑</strong>，但在<strong>逻辑上</strong>则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状</strong>结构，从而消除了兜圈子现象</li></ul><hr><h2 id="✨知识点十三：虚拟局域网VLAN">✨知识点十三：虚拟局域网VLAN</h2><p>原因：</p><ol><li>在同一个广播域中，广播风暴会浪费网络资源和各主机的CPU资源</li><li>网络中会频繁出现广播信息<ol><li>TCP/IP<ul><li>地址解析协议ARP(已知IP地址，找出其相应的MAC地址)</li><li>路由信息协议RIP(一种小型的内部路由协议)</li><li>动态主机配置协议DHCP(用于自动配置IP地址)</li></ul></li><li>NetBEUl:Widnows下使用的广播型协议</li><li>IPX/SPX:Novell网络的协议栈</li><li>Apple Talk:Apple公司的网络协议栈</li></ol></li></ol><p>方法：</p><ol><li>使用<strong>路由器</strong>，成本较高</li><li>虚拟局域网VLAN</li></ol><p><strong><code>虚拟局域网VLAN</code></strong> (Virtual Local Area Network)是一种将局域网内的<strong>设备划分成与物理位置无关的逻辑组的技术</strong>，这些逻辑组具有某些共同的需求**（逻辑上的**，虚拟局域网其实只是局域网给用户提供的一种服务）</p><p><strong><code>实现机制</code></strong></p><p>虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现<strong>两种</strong>功能：</p><ol><li>能够处理带有VLAN标记的帧—— <strong><code>IEEE 802.1 Q帧</code>（I Tripple E）</strong><ul><li>VLAN标记的<strong>最后12比特</strong>称为 <strong><code>VLAN标识符VID</code></strong>，它唯一地标志了以太网帧属于哪一个VLAN。<ul><li><p>VID的取值范围是0~4095（0~-1）</p></li><li><p>0和4095都不用来表示VLAN，因此用于表示VLAN的VID的<strong>有效取值范围</strong>是<strong>1~4094</strong></p></li></ul></li><li>802.1Q帧是由 <strong><code>交换机</code></strong> 来处理的，<strong>而不是用户主机来处理的</strong><ul><li>当交换机收到普通的以太网帧时，会将其插入<strong>4字节的VLAN标记转变为802.1Q帧</strong>，简称“<strong>打标签</strong>”</li><li>当交换机转发802.1Q帧时，可能会删除其4字节VLAN标记转变为普通以太网帧，简称“<strong>去标签</strong>”</li></ul></li></ul></li><li>交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同</li></ol><div class="note info no-icon flat"><p>♻️ <strong>Access端口</strong></p></div><ul><li>Access端口一般用于连接用户计算机</li><li>Access端口只能属于一个VLAN</li><li>Access端口的PVID值与端口所属VLAN的ID相同(默认为1)</li></ul><p><strong>Access端口接收处理方法</strong></p><p>一般只接受“未打标签”的普通以太网MAC帧。<strong>根据接收帧的端口的PVID给帧“打标签”</strong>，即插入4字节VLAN标记字段，<strong>字段中的VID取值与端口的PVID取值相等</strong></p><p><strong>Access端口发送处理方法</strong></p><p><strong>若帧中的VID与端口的PVID相等，则“去标签“并转发该帧</strong>;否则不转发</p><div class="note info no-icon flat"><p>♻️ <strong>Truck端口</strong></p></div><ul><li>Trunk端口一般用于交换机之间或交换机与路由器之间的互连</li><li>Trunk端口可以属于多个VLAN用户可以设置</li><li>Trunk端口的PVID值。默认情况下，Trunk端口的PVID值为1</li></ul><p><strong>Trunk端口发送处理方法</strong></p><ol><li>对VID等于PVID的帧，<strong>“去标签”再转发</strong></li><li>对VID不等于PVID的帧，<strong>直接转发</strong></li></ol><p><strong>Trunk端口接收处理方法</strong></p><ol><li>接收“未打标签”的帧，根据接收帧的端口的PVID给帧“打标签”，即插入4字节VLAN标记字段，<strong>字段中的VID取值与端口的PVID取值相等</strong></li><li>直接转发</li></ol><p>例题：</p><p>下图给出了用于交换机互连的Trunk端口的PVID值的组合，试回答以下问题</p><p>(1)主机A发送广播帧，则帧的传递过程是什么?</p><p>(2)主机C发送广播帧，则帧的传递过程是什么?</p><p>(3)从上述过程可以得出什么结论?</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2100.png" alt="Untitled"></p><div class="note info no-icon flat"><p>♻️ <strong>Hybrid</strong></p></div><ul><li>Hybrid端口既可用于交换机之间或交换机与路由器之间的互连(同Trunk端口)，也可用于交换机与用户计算机之间的互连(同Access端口)</li><li>Hybrid端口可以属于多个VLAN(同Trunk端口)</li><li>用户可以设置Hybrid端口的PVID值。默认情况下Hybrid端口的PVID值为1(同Trunk端口)</li></ul><p><strong>Hybrid端口发送处理方法(与Trunk端口不同)</strong></p><p>查看帧的VID是否在端口的“去标签”列表中</p><ul><li>若存在，则“去标签”后再转发</li><li>若不存在，则直接转发</li></ul><p><strong>Hybrid端口接收处理方法(同Trunk端口)</strong></p><ul><li>接收“未打标签”的帧，根据接收帧的端口的PVID给帧“打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等</li><li>接收“已打标签的帧”</li></ul><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2101.png" alt="Untitled"></p><p><strong><span class='p h3'>虚拟局域网优点</span></strong></p><p>虚拟局域网（VLAN）技术具有以下主要优点：</p><ol><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性</li></ol><hr>]]></content>
    
    
    <summary type="html">计网</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="计算机网络" scheme="https://agoni66.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="四大件" scheme="https://agoni66.github.io/tags/%E5%9B%9B%E5%A4%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（二）</title>
    <link href="https://agoni66.github.io/posts/1000102.html"/>
    <id>https://agoni66.github.io/posts/1000102.html</id>
    <published>2024-06-03T12:30:00.000Z</published>
    <updated>2024-09-10T01:18:34.876Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><p><font size="4"><b>计算机网络导航🚀🚀🚀</b></font></p><ol><li><p>🍕<a href="https://agoni66.github.io/posts/1000101.html">第一章 概述</a></p></li><li><p>🍔<a href="https://agoni66.github.io/posts/1000102.html">第二章 物理层</a> ⇦ 当前位置🪂</p></li><li><p>🍟<a href="https://agoni66.github.io/posts/1000103.html">第三章 数据链路层</a></p></li><li><p>🌭<a href="https://agoni66.github.io/posts/1000104.html">第四章 网际层</a></p></li><li><p>🍿<a href="https://agoni66.github.io/posts/1000105.html">第五章 运输层</a></p></li><li><p>🧂<a href="https://agoni66.github.io/posts/1000106.html">第六章 应用层</a></p></li></ol></div><div class="note warning modern"><p><b>图片加载较慢，请耐心等待！🌤️🌥️🌦️</b></p></div><h2 id="知识点一：物理层的基本概念">知识点一：物理层的基本概念</h2><ul><li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流</li><li>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么</li></ul><p><strong>物理层协议的主要任务</strong></p><ul><li><code>机械特性</code> 指明接口所用接线器的<strong>形状和尺寸</strong>、<strong>引脚数目和排列</strong>、<strong>固定和锁定装置</strong></li><li><code>电气特性</code> 指明在接口电缆的各条线上出现的<strong>电压的范围</strong></li><li><code>功能特性</code> 指明某条线上出现的某一电特性平的<strong>电压表示何种意义</strong></li><li><code>过程特性</code> 指明对于不同功能的各种可能<strong>事件的出现顺序</strong></li></ul><hr><h2 id="知识点二：物理层下面的传输媒体">知识点二：物理层下面的传输媒体</h2><p><strong>传输媒体</strong><br>也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路</p><p>传输媒体课分为两大类，即 <strong><code>导引型传输媒体</code>和 <code>非导引型传输媒体</code></strong></p><p><strong><span class='p h3'>导引型传输媒体</span></strong></p><ul><li><strong>同轴电缆</strong><ul><li><p>基带同轴电缆(50Ω)</p><p>数字传输，过去用于局域网</p></li><li><p>宽带同轴电缆（75Ω）</p><p>模拟传输，目前主要用于有线电视</p></li><li><p>同轴电缆价格较贵且布线不够灵活和方便，随着集线器的出现，在局域网领域基本上都是采用双绞线作为传输媒体</p></li></ul></li><li><strong>双绞线</strong><ul><li>无屏蔽双绞线</li><li>屏蔽双绞线</li><li>绞合的作用<ul><li>低于部分来自外界的电磁波干扰</li><li>减少相邻导线的电磁干扰</li></ul></li></ul></li><li><strong>光纤</strong><ul><li><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1201.png" alt="Untitled"></li><li><strong><code>多模光纤</code></strong> 可以存在多条不同角度入射的光线在一条光纤中传输</li><li><strong><code>单模光纤</code></strong> 若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射</li></ul></li><li>电力线</li></ul><p><strong><span class='p h3'>非导引型传输媒体</span></strong></p><p>非导引型传输媒体是指自由空间</p><ul><li>无线电波</li><li>微波<ul><li>直线传播</li><li>300MHz～300GHz</li><li>地面一般只有50km</li><li>多径效应  多条路径的信号叠加后一般会产生很大的失真</li><li>地面微波接力通信与卫星通信</li></ul></li><li>红外线</li><li>可见光</li></ul><p><strong>信噪比越大，误码率越低</strong></p><hr><h2 id="知识点三：传输方式">知识点三：传输方式</h2><p><strong><span class='p h3'>串行传输和并行传输</span></strong></p><p><strong>串行传输：</strong></p><p>数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可</p><p><strong>并行传输：</strong></p><p>一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p><p>并行传输的优点是比串行传输的速度n倍，但<strong>成本高</strong></p><p>数据在<strong>传输线路上</strong>的传输采用是<strong>串行传输</strong>，<strong>计算机内部的数据</strong>传输常用<strong>并行传输</strong></p><p><strong><span class='p h3'>同步传输和异步传输</span></strong></p><p><strong>同步传输</strong></p><p>数据块以稳定的比特流的形式传输。<strong>字节之间没有间隔</strong></p><ul><li>接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1</li><li>由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位</li></ul><p>所以需要收发双方时钟保持同步</p><ul><li><strong>外同步</strong>：在收发双方之间添加一条单独的时钟信号线</li><li><strong>内同步</strong>：发送端将时钟同步信号编码到发送数据中一起传输(例如曼彻斯特编码)</li></ul><p><strong>异步传输：</strong></p><ul><li>以字节为独立的传输单位，字节之间的时间间隔不是固定</li><li>接收端仅在每个字节的起始处对字节内的比特实现同步</li><li>通常在每个字节前后分别加上起始位和结束位</li><li><strong>异步</strong><ul><li><strong>字节之间异步(字节之间的时间间隔不固定)</strong></li><li><strong>字节中的每个比特仍然要同步(各比特的持续时间是相同的)</strong></li></ul></li></ul><p><strong><span class='p h3'>单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）</span></strong></p><table><thead><tr><th>名称</th><th>定义</th><th>例子</th></tr></thead><tbody><tr><td>单向通信</td><td>又称为单工通信，即只能有一个方向的通信而没有反方向的交互</td><td>无线电广播</td></tr><tr><td>双向交替通信</td><td>通信的双方可以发送信息，但不能双方同时发送（当然也就不能同时接收）</td><td>对讲机</td></tr><tr><td>双向同时通信</td><td>通信的双方可以同时发送和接收信息</td><td>手机</td></tr></tbody></table><p>单向通信只需要<strong>一条信道</strong>，而双向交替通信或双向同时通信则需要<strong>两条信道（每个方向各一条）</strong></p><hr><h2 id="✨知识点四：编码与调制">✨知识点四：编码与调制</h2><p><strong><span class='p h3'>基础知识</span></strong></p><ul><li><strong>数据 (data)</strong> —— 运送消息的实体。</li><li><strong>信号 (signal)</strong> —— 数据的电气的或电磁的表现。</li><li><strong>模拟信号 (analogous signal)</strong> —— 代表消息的参数的取值是连续的。</li><li><strong>数字信号 (digital signal)</strong> —— 代表消息的参数的取值是离散的。</li><li><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，<strong>代表不同离散数值的基本波形</strong>。</li><li><strong>基带信号（即基本频带信号）</strong>—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</li></ul><p><strong><span class='p h3'>传输媒体与信道的关系</span></strong></p><p><strong>信道</strong>  一般用来表示向某一个方向传送信息的媒体（信源、信道、信宿）</p><ul><li>严格来说，传输媒体不能和信道划等号</li><li>对于单工传输，传输媒体只包含一个信道，要么是发送信道，要么是接收信道</li><li>对于半双工和全双工，传输媒体中要包含两个信道，一个发送信道，另一个是接收信道</li><li>如果使用<strong>信道复用技术</strong>，一条传输媒体还可以包含多个信道</li></ul><div class="note danger no-icon flat"><p>🛀 <strong>常用编码</strong></p></div><h4 id="不归零编码">不归零编码</h4><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1400.png" alt="Untitled"></p><p>所谓不归零编码，就是指在整个码元时间内，电平不会出现零电平</p><p>实际比特1和比特0的表示要看现实怎么规定</p><p>Q：接收端如何判断这是n个码元？</p><p>这需要发送方的发送与接收方的接收做到严格的<strong>同步</strong></p><ol><li>需要<strong>额外一根传输线来传输时钟信号</strong>，使发送方和接收方同步，接收方按时钟信号的节拍来逐个接收码元</li><li>但是对于计算机网络，宁愿利用<strong>这根传输线传输数据信号</strong>，而不是传输时钟信号</li></ol><p>由于不归零编码存在<strong>同步问题</strong>，因此计算机网络中的数据传输不采用这类编码</p><h4 id="归零编码">归零编码</h4><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1401.png" alt="Untitled"></p><p>**每个码元传输结束后信号都要“归零”**所以接收方只要在信号归零后进行采样即可，不需要单独的时钟信号</p><p>实际上，归零编码相当于把时钟信号用“归零”方式编码在了数据之内，这称为“<strong>自同步</strong>”信号</p><p>但是，归零编码中大部分的<strong>数据带宽</strong>都用来传输“归零”而<strong>浪费</strong>掉了</p><p><strong>归零编码</strong>虽然<strong>自同步</strong>，但<strong>编码效率低</strong></p><h4 id="曼彻斯特编码">曼彻斯特编码</h4><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1402.png" alt="Untitled"></p><p><strong>在每个码元时间的中间时刻，信号都会发生跳变</strong></p><ul><li>码元中间时刻的跳变即表示时钟，又表示数据</li><li>实际比特1和比特0的表示要看现实怎么规定</li><li>传统以太网使用的就是曼切斯特编码</li></ul><h4 id="差分曼彻斯特编码">差分曼彻斯特编码</h4><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1403.png" alt="Untitled"></p><p>在每个码元时间的中间时刻，信号都会发送跳变，但与曼彻斯特不同</p><ul><li><strong>跳变仅表示时钟</strong></li><li><strong>码元开始处电平是否变换表示数据</strong></li><li>实际比特1和比特0的表示要看现实怎么规定</li></ul><p>比曼彻斯特编码变化少，更适合较高的传输速率</p><h4 id="编码总结">编码总结</h4><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1404.png" alt="Untitled"></p><div class="note danger no-icon flat"><p>🛀 <strong>调制</strong></p></div><h4 id="基本调制方法">基本调制方法</h4><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1405.png" alt="Untitled"></p><ul><li>**调幅AM：**所调制的信号由两种不同振幅的基本波形构成。每个基本波形只能表示1比特信息量。</li><li>**调频FM：**所调制的信号由两种不同频率的基本波形构成。每个基本波形只能表示1比特信息量。</li><li>**调相PM：**所调制的信号由两种不同初相位的基本波形构成。每个基本波形只能表示1比特信息量。</li></ul><p><strong>但是使用基本调制方法，1个码元只能包含1个比特信息</strong></p><h4 id="混合调制">混合调制</h4><ul><li>因为<strong>频率和相位是相关</strong>的，即频率是相位随时间的变化率。所以<strong>一次只能调制频率和相位两个中的一个</strong></li><li>通常情况下，相位和振幅可以结合起来一起调制，称为<strong>正交振幅调制QAM</strong><ul><li>12种相位</li><li>每种相位有1或2种振幅可选</li><li>可以调制出16种码元(波形)每种码元可以对应表示4个比特</li><li>码元与4个比特的对应关系采用格雷码</li><li>任意两个相邻码元只有1个比特不同</li></ul></li></ul><hr><h2 id="✨知识点五：奈氏准则和香农准则">✨知识点五：奈氏准则和香农准则</h2><p><strong><span class='p h3'>信道的极限容量</span></strong></p><ul><li>任何实际的信道都<strong>不是理想的</strong>，在传输信号时会产生各种<strong>失真</strong>以及带来多种<strong>干扰</strong>。</li><li>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重</li></ul><p><strong><span class='p h3'>失真的原因</span></strong></p><ul><li>码元传输的速率越高</li><li>信号传输的距离越远</li><li>噪声干扰越大</li><li>传输媒体质量越差</li></ul><div class="note danger no-icon flat"><p>✅ <strong>奈氏准则和香农公式对比</strong></p></div><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1500.png" alt="Untitled"></p><ul><li>奈氏准则：在假定的<strong>理想条件</strong>下，为了<strong>避免码间串扰</strong>，码元传输速率是由上限的</li><li><strong>低通就是只要低于该频率的就能通过，带通就是某个区间内的频率能通过</strong></li><li>信道宽度：W  单位Hz</li><li>信噪比：S/N</li><li>码元传输速率又称为波特率、调制速率、波形速率或符号速率。它与比特率有一定关系：<ul><li>当1个码元只携带1比特的信息量时，则波特率(码元/秒)与比特率(比特/秒)在<strong>数值上是相等的</strong></li><li>当1个码元携带n比特的信息量时，则波特率转换成比特率时，<strong>数值要乘以n</strong></li></ul></li><li>在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高<strong>信息的传输速率</strong>就必须采用<strong>多元制(<strong>更好的调制方法)和努力</strong>提高信道中的信噪比</strong></li><li>自从香农公式发表后，各种新的信号处理和调制方法就不断出现，其目的都是为了尽可能地<strong>接近香农公式给出的传输速率极限</strong></li></ul><p>Q：只要采用更好的调制方法，让码元可以携带更多的比特，岂不是可以无限制地提高信息的传输速率?</p><p>A：答案是否定的。因为信道的极限信息传输速率还要受限于实际的信号在信道中传输时的信噪比。</p><p><strong><span class='p h3'>习题</span></strong></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1501.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1502.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1503.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1504.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1505.png" alt="Untitled"></p><hr><h2 id="知识点六：信道复用技术">知识点六：信道复用技术</h2><p><code>复用</code> (multiplexing) 是通信技术中的基本概念。</p><p>它允许用户使用一个共享信道进行通信，降低成本，提高利用率</p><hr><h4 id="频分复用-FDM-Frequency-Division-Multiplexing"><strong>频分复用 FDM (Frequency Division Multiplexing)</strong></h4><ul><li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中 <code>自始至终</code>都占用这个频带。</li><li><strong><code>频分复用</code></strong> 的所有用户在同样的时间 <strong><code>占用不同的带宽资源</code></strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）</li></ul><h4 id="时分复用TDM-Time-Division-Multiplexing"><strong>时分复用TDM (Time Division Multiplexing)</strong></h4><ul><li>时分复用则是将时间划分为一段段等长的 <strong><code>时分复用帧</code>（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是 <strong><code>周期性地出现</code></strong>（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为 <strong><code>等时</code></strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度</strong></li></ul><p><strong>时分复用可能会造成线路资源的浪费</strong></p><p>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</p><h4 id="统计时分复用-STDM-Statistic-TDM"><strong>统计时分复用 STDM (Statistic TDM)</strong></h4><p>解决信道利用率低的问题</p><h4 id="波分复用-WDM-Wavelength-Division-Multiplexing"><strong>波分复用 WDM(Wavelength Division Multiplexing)</strong></h4><p>波分复用就是光的频分复用。使用一根光纤来同时传输多个光载波信号</p><p>光信号传输一段距离后悔衰减，所以要用 掺铒光纤放大器 放大光信号</p><h4 id="码分复用-CDM-Code-Division-Multiplexing"><strong>码分复用 CDM (Code Division Multiplexing)</strong></h4><ul><li>码分复用CDM是另一种共享信道的方法。实际上，由于该技术主要用于多址接入，人们更常用的名词是<strong>码分多址CDMA</strong>(Code Division Multiple Access)。</li><li>同理，频分复用FDM和时分复用TDM同样可用于多址接入，相应的名词是<strong>频分多址FDMA</strong>(Frequency Division Multiple Access)和<strong>时分多址TDMA</strong>(Time Division Multiple Access).</li><li>在本课程中，我们不严格区分复用与多址的概念。可简单理解如下:<ul><li>复用是将单一媒体的频带资源划分成很多子信道，这些子信道之间相互独立，互不干扰。从媒体的整体频带资源上看，每个子信道只占用该媒体频带资源的一部分。</li><li>多址(更确切地应该称为多点接入)处理的是动态分配信道给用户。这在用户仅仅暂时性地占用信道的应用中是必须的，而所有的移动通信系统基本上都属于这种情况。相反，在信道永久性地分配给用户的应用中，多址是不需要的(对于无线广播或电视广播站就是这样)。</li><li>某种程度上，FDMA、TDMA、CDMA可以分别看成是FDM、TDM、CDM的应用</li></ul></li><li>与FDM和TDM不同，CDM的每一个用户可以<strong>在同样的时间使用同样的频带进行通信</strong></li><li>由于<strong>各用户使用经过特殊挑选的不同码型</strong>，因此<strong>各用户之间不会造成干扰</strong></li><li>CDM最初是用于军事通信的，因为这种系统所发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li><li>随着技术的进步，CDMA设备的价格和体积都大幅度下降，因而现在已广泛用于民用的移动通信中</li></ul><blockquote><p>频分：一条路同一时间走两种车；<br>时分：一条路一种车只能在属于他的时间经过；<br>码分：给两种车分别编号（编码），到了终点再根据编号区分</p></blockquote><div class="note danger no-icon flat"><p>⚠️ <strong>码片</strong></p></div><ul><li>在CDMA中，每一个比特时间再划分为m个短的间隔，称为<strong>码片</strong>(Chip)。通常m的值是64或128</li><li>为了简单起见，在后续的举例中，我们假设m为8。</li><li>使用CDMA的每一个站被指派一个唯一的<strong>m bit码片序列</strong>(Chip Sequence)</li><li>一个站如果要 <strong><code>发送比特1</code></strong> 则 <strong><code>发送它自己的m bit码片序列</code></strong></li><li>一个站如果要 <strong><code>发送比特0</code></strong> 则 <strong><code>发送它自己的m bit码片序列的二进制反码</code></strong></li><li>【举例】</li><li>指派给CDMA系统中某个站点的码片序列为 00011011</li><li>发送比特1：发送自己的码片序列 00011011</li><li>发送比特0：发送自己的码片序列的二进制反码 11100100</li><li>为了方便，我们按惯例将码片序列中的0写为-1，将1写为+1.</li><li>则该站点的码片序列是(-1-1-1 +1+1-1 +1 +1)</li><li>码片序列的挑选原则如下:</li></ul><ol><li>分配给每个站的<strong>码片序列必须各不相同</strong>，实际常采用伪随机码序列</li><li>分配给每个站的<strong>码片序列必须相互正交</strong>(规格化内积为0)。令向量S表示站S的码片序列，</li><li>令向量T表示其他任何站的码片序列</li><li>两个不同站S和T的码片序列正交，就是向量S和T的规格化内积为0</li></ol><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1600.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1601.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1602.png" alt="Untitled"></p><hr><h2 id="📚习题">📚习题</h2><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1700.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1701.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1702.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1703.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1704.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1705.png" alt="Untitled"></p>]]></content>
    
    
    <summary type="html">计网</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="计算机网络" scheme="https://agoni66.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="四大件" scheme="https://agoni66.github.io/tags/%E5%9B%9B%E5%A4%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（一）</title>
    <link href="https://agoni66.github.io/posts/1000101.html"/>
    <id>https://agoni66.github.io/posts/1000101.html</id>
    <published>2024-06-03T10:30:00.000Z</published>
    <updated>2024-09-10T01:16:48.885Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><p><font size="4"><b>计算机网络导航🚀🚀🚀</b></font></p><ol><li><p>🍕<a href="https://agoni66.github.io/posts/1000101.html">第一章 概述</a> ⇦ 当前位置🪂</p></li><li><p>🍔<a href="https://agoni66.github.io/posts/1000102.html">第二章 物理层</a></p></li><li><p>🍟<a href="https://agoni66.github.io/posts/1000103.html">第三章 数据链路层</a></p></li><li><p>🌭<a href="https://agoni66.github.io/posts/1000104.html">第四章 网际层</a></p></li><li><p>🍿<a href="https://agoni66.github.io/posts/1000105.html">第五章 运输层</a></p></li><li><p>🧂<a href="https://agoni66.github.io/posts/1000106.html">第六章 应用层</a></p></li></ol></div><div class="note warning modern"><p><b>图片加载较慢，请耐心等待！🌤️🌥️🌦️</b></p></div><p>参考资料：<a href="https://www.jianshu.com/p/541d4f0c0f1e">计算机网络第1章（概述） - 简书 (jianshu.com)</a></p><p>计算机网络应用（无用）</p><ol><li>信息浏览和发布</li><li>通信和交流</li><li>休闲和娱乐</li><li>资源共享</li><li>电子商务</li><li>远程协作</li><li>网络办公</li></ol><hr><h2 id="知识点一：网络、互联网与因特网的区别和关系"><strong>知识点一：网络、互联网与因特网的区别和关系</strong></h2><ol><li><strong><code>计算机网络</code></strong>（简称 <strong><code>网络</code></strong> ）由若干 <strong><code>节点</code></strong> 和连接这些节点的 <strong><code>链路</code></strong> 组成</li><li>互联网由多个网络通过 <strong><code>路由器</code></strong> 互相连接组成的覆盖范围更大的计算机网络，是“网络的网络”</li><li><strong>网络把许多计算机连接在一起，而互连网则把许多网络通过一些路由器连接在一起。与网络相连的计算机常称为主机。</strong></li><li><code>internet</code>（互联网）泛指由多个计算机网络互连而成的计算机网络</li><li><code>Internet</code>（因特网）指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，它采用 TCP/IP 协议族作为通信的规则</li></ol><hr><h2 id="知识点二：互联网发展的三个阶段"><strong>知识点二：互联网发展的三个阶段</strong></h2><ol><li><p>第一阶段是从单个网络ARPANET 向互连网发展的过程（1983年作为互联网的诞生时间）</p></li><li><p>第二阶段的特点是建成了三级结构的互联网（即国家科学基金网 <strong>NSFNET</strong>。它是一个三级计算机网络，分为<strong>主干网、地区网和校园网</strong></p></li><li><p>第三阶段的特点是逐渐形成了全球范围的<strong>多层次 ISP 结构的互联网</strong></p><p><strong><code>互联网服务提供者ISP</code></strong></p><ol><li>互联网上的主机都必须有IP地址才能上网</li><li>任何机构或个人只要向某个ISP交纳规定的费用，就可从该ISP获取所需IP地址的租用权，并可通过该ISP接入互联网</li><li>根据提供服务的覆盖面积大小以及所拥有的IP地址数目的不同，ISP也分为不同层次的ISP：主干ISP、地区ISP和本地ISP</li><li>比如中国移动、中国联通、中国电信</li></ol></li></ol><hr><h2 id="知识点三：互联网的标准化工作"><strong>知识点三：互联网的标准化工作</strong></h2><ul><li>官方机构</li><li>制定互联网的正式标准三个阶段:<ol><li>互联网草案</li><li>建议标准</li><li>互联网标准</li></ol></li><li>一大特点:面向公众</li></ul><p><strong>互联网的组成</strong><br><strong><code>边缘部分</code></strong> 由所有连接在互联网上的主机组成。这部分是用户直接使用的边缘部分<br><strong><code>核心部分</code></strong> 由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的(提供连通性和交换)</p><p><strong>国际组织</strong></p><ul><li>国际标准化组织(ISO)</li><li>国际电信联盟(ITY)</li><li>国际电气电子工程师协会(IEEE)</li></ul><hr><h2 id="✨知识点四：三大交换">✨知识点四：三大交换</h2><p>交换(switching)就是按照某种方式动态地分配传输线路的资源、</p><ol><li><strong>电路交换</strong>：必须经过“<strong>建立连接</strong>(占用通信资源)一<strong>通话</strong>(一直占用通信资源)一<strong>释放连接</strong>(归还通信资源)”三个步骤的交换方式（<strong>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源，线路的传输效率很低</strong>）</li><li><strong>报文交换</strong><ol><li><strong>发送方</strong> 构造分组、发送分组</li><li><strong>路由器</strong> 缓存分组、转发分组</li><li><strong>接收方</strong> 接收分组、还原报文</li></ol></li><li><strong>分组交换（存储转发）</strong><ol><li><strong>报文——</strong> 发送的整块数据</li><li><strong>首部——</strong> 每个数据段前面和加上的一些必要的控制信息</li><li><strong>分组——</strong> 报文划分的等长数据段+首部，也称包</li></ol></li></ol><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0401.png" alt="Untitled"></p><hr><h2 id="知识点五：计算机网络的定义"><strong>知识点五：计算机网络的定义</strong></h2><p>计算机网络的最简单的定义是：一些 <strong><code>互相连接</code></strong> 的、 <strong><code>自治</code></strong> 的计算机的 <strong><code>集合</code></strong></p><ul><li><strong>互连</strong>：是指计算机之间可以通过有线或无线的方式进行数据通信</li><li><strong>自治</strong>：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用</li><li><strong>集合</strong>：是指至少需要两台计算机</li></ul><hr><p>计算机网络的较好的定义是：计算机网络主要是由一些 <strong><code>通用的，可编程的</code><strong>硬件（一定包含有中央处理机CPU）互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来</strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的和日益增长的应用</strong></p><hr><h2 id="知识点六：计算机网络的分类">知识点六：计算机网络的分类</h2><p><strong>按交换技术分类：</strong></p><ul><li>电路交换网络</li><li>报文交换网络</li><li>分组交换网络</li></ul><p><strong>按使用者分类：</strong></p><ul><li>公用网</li><li>专用网</li></ul><p><strong>按传输介质分类：</strong></p><ul><li>有线网络</li><li>无线网络</li></ul><p><strong>按覆盖范围分类：</strong></p><ul><li>广域网WAN（Wide Area Network）</li><li>城域网MAN（Metropolitan Area Network）</li><li>局域网LAN（Local Area Network）</li><li>个域网PAN</li></ul><p><strong>按拓扑结构分类：</strong></p><ul><li>总线型网络</li><li>星型网络（中枢设备比较敏感，现在一般是交换机或路由器）</li><li>环形网络（环中信号是单向传输的）</li><li>网状型网络</li></ul><p><strong>按传输技术分类：</strong></p><ul><li>广播式网络</li><li>点对点网络</li></ul><hr><h2 id="✨知识点七：计算机网络的性能指标"><strong>✨知识点七：计算机网络的性能指标</strong></h2><div class="note danger no-icon flat"><p>🔥 <strong>速率</strong></p></div><p><strong><code>比特</code></strong> 计算机中数据量的单位，也是信息论中信息量的单位。一个比特就是二进制数字中的一个1或0</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0701.png" alt="Untitled"></p><p><strong>速率</strong>：连接在计算机网络上的主机在数字信道上传输比特的速率，也称为<strong>比特率</strong>或<strong>数据率</strong>（bit/s）</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0702.png" alt="Untitled"></p><p>例题：</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0703.png" alt="Untitled"></p><div class="note danger no-icon flat"><p>🔥 <strong>带宽</strong></p></div><ol><li><p>在 <code>模拟信号系统</code>中的意义：<strong>信号</strong>所包含的各种不同频率成分所占据的<strong>频率范围</strong></p><p><strong>单位：Hz（kHz、MHz、GHz）</strong></p></li><li><p>在 <code>计算机网络</code>中的意义：用来表示网络的<strong>通信线路</strong>所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的“<strong>最高数据率</strong>”</p><p><strong>单位：b/s</strong></p></li></ol><p><strong>个人理解：水管的预定或者最大流量</strong></p><div class="note danger no-icon flat"><p>🔥 <strong>吞吐量</strong></p></div><ul><li>吞吐量表示在<strong>单位时间内通过某个网络(或信道、接口)的数据量</strong></li><li>吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</li><li>吞吐量<strong>受网络的带宽或额定速率的限制</strong></li></ul><p><strong>个人理解：水管的实际流量，</strong> 普遍低于带宽</p><div class="note danger no-icon flat"><p>🔥 <strong>时延</strong></p></div><p>时延是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p><p>网络时延由几部分组成：</p><ul><li>发送时延<ol><li>主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间</li><li><strong>发送时延=分组长度（b） /  发送速率（b/s）</strong></li></ol></li><li>传播时延<ol><li>电磁波在信道中传播一定的距离需要花费的时间</li><li><strong>传播时延=信道长度（m） /  电磁波传播速率（m/s）2✖️10$^8$</strong></li></ol></li><li>处理时延：主机或路由器在收到分组时要花费一定时间进行处理</li><li>排队时延：分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理</li></ul><p>有时会把排队时延看成处理时延 一部分</p><p>总时延 = 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p><p>当处理时延忽略不计时（一般来说），<strong>发送时延 和 传播时延谁占主导</strong>，要<strong>具体情况具体分析</strong></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0704.png" alt="Untitled"></p><p><strong>现实中，传播时延比较大，因为传播到卫星距离比较长</strong></p><div class="note danger no-icon flat"><p>🔥 <strong>时延带宽积</strong></p></div><p><strong>时延带宽积 = 传播时延 ×</strong> <strong>带宽</strong></p><ul><li>若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特</li><li>链路的时延带宽积又称为<strong>以比特为单位的链路长度</strong></li></ul><p>这是长度</p><p><strong>往返时间RTT</strong>（Round-Trip Time）</p><p>互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道<strong>双向交互一次所需的时间</strong></p><div class="note danger no-icon flat"><p>🔥 <strong>利用率</strong></p></div><p><strong>利用率</strong></p><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0705.png" alt="Untitled"></p><p>就是傲娇，不能太高也不能太低</p><div class="note danger no-icon flat"><p>🔥 <strong>丢包率</strong></p></div><p><strong>丢包率</strong></p><ul><li>丢包率即分组丢失率，是指在一定的时间范围内，传输过程中<strong>丢失的分组数量与总分组数量的比率</strong></li><li>丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等</li><li>丢包率是网络运维人员非常关心的一个网络性能指标，但对于普通用户来说往往并不关心这个指标，因为他们通常意识不到网络丢包</li><li>分组丢失主要有两种情况:<ul><li>分组在传输过程中出现<strong>误码</strong>，被结点丢弃</li><li>分组到达一台队列已满的分组交换机时被丢弃;在通信量较大时就可能造成<strong>网络拥塞</strong></li></ul></li><li>因此，丢包率反映了网络的拥塞情况:<ul><li>无拥塞时路径丢包率为0</li><li>轻度拥塞时路径丢包率为1%~4%</li><li>严重拥寨时路径丢包率为5%~15%</li></ul></li></ul><p>计算机网络的非性能特征</p><ol><li>费用</li><li>质量</li><li>标准化</li><li>可靠性</li><li>可扩展性和可升级性</li><li>易于管理和维护</li></ol><h2 id="✨知识点八：计算机网络体系结构"><strong>✨知识点八：计算机网络体系结构</strong></h2><p><strong>常见的计算机网络体系结构：</strong></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0800.png" alt="Untitled"></p><ul><li>如今用的最多的是TCP/IP体系结构，现今规模最大的、覆盖全球的、基于TCP/IP的互联网并未使用OSI标准</li><li>TCP/IP体系结构相当于将OSI体系结构的<strong>物理层和数据链路层合并为了网络接口层</strong>，并<strong>去掉了会话层和表示层</strong>，网际层实际上就是网络层，只是因为是IP协议意思是网际而改名</li><li>TCP/IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此TCP/IP体系结构的网络层称为网际层</li><li>在用户主机的操作系统中，通常都带有符合TCP/IP体系结构标准的TCP/IP协议族</li><li>而用于网络互连的路由器中，也带有符合TCP/IP体系结构标准的TCP/IP协议族</li><li>只不过路由器一般只包含网络接口层和网际层</li></ul><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0801.png" alt="Untitled"></p><ul><li><p><strong><code>网络接口层</code></strong> 并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等</p></li><li><p><strong><code>网际层</code></strong> 它的核心协议是 <strong><code>IP协议</code></strong>（**IP协议（网际层）<strong>可以将</strong>不同的网络接口（网络接口层）<strong>进行互连，并向其上的</strong>TCP协议和UDP协议（运输层）**提供网络互连服务）</p></li><li><p><strong><code>运输层</code></strong>  **<code>TCP</code>**和 **<code>UDP</code>**是这层的两个重要协议</p></li><li><p>而TCP协议在享受IP协议提供的网络互连服务的基础上，可向应用层的相应协议提供可靠的传输服务</p></li><li><p>UDP协议在享受IP协议提供的网络互连服务的基础上，可向应用层的相应协议提供不可靠的传输服务</p></li><li><p><strong>应用层</strong>：这层包含了大量的应用层协议，如 <strong>HTTP SMTP DNS RTP</strong> 等</p></li><li><p>TCP/IP体系结构中最重要的是IP协议和TCP协议，因此用TCP和IP来表示整个协议大家族</p></li></ul><hr><p><strong>计算机网络体系结构分层的必要性</strong></p><ul><li>计算机网络是个非常复杂的系统</li><li>分层可以将庞大而复杂的问题，转换成若干较小的局部问题</li></ul><p><strong>总结</strong></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0806.png" alt="Untitled"></p><p>如何选物流车，如何运输，如何分拣，如何派件，如何售后服务</p><p>分层也可以降低问题的耦合度（课外知识）</p><p>耦合度：关联依赖程度</p><p><strong>计算机网络体系结构分层思想举例</strong></p><p>应用进程基于网络的通信</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0802.png" alt="Untitled"></p><p>发送方发送</p><ol><li><p><strong>应用层</strong>按照HTTP协议的规定构建一个<strong>HTTP请求报文</strong></p><p>应用层将<strong>HTTP请求报文</strong>交付给<strong>运输层</strong>处理</p></li><li><p><strong>运输层</strong>给<strong>HTTP请求报文</strong>添加一个<strong>TCP首部</strong>，使之成为<strong>TCP报文段</strong></p><p>TCP报文段的首部格式作用是区分应用进程以及实现可靠传输</p><p><strong>运输层</strong>将<strong>TCP报文段</strong>交付给<strong>网络层</strong>处理</p></li><li><p><strong>网络层</strong>给<strong>TCP报文段</strong>添加一个<strong>IP首部</strong>，使之成为IP数据报</p><p>IP数据报的首部格式作用是<strong>使IP数据报可以在互联网传输</strong>，也就是被路由器转发</p><p><strong>网络层</strong>将<strong>IP数据</strong>报交付给<strong>数据链路层</strong>处理</p></li><li><p><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong></p><p>该<strong>首部</strong>的作用主要是为了让<strong>帧</strong>能够在一段链路上或一个网络上传输，能够被相应的目的主机接收</p><p>该<strong>尾部</strong>的作用是让目的主机检查所接收到的<strong>帧是否有误码</strong></p><p><strong>数据链路层</strong>将<strong>帧</strong>交付给<strong>物理层</strong></p></li><li><p><strong>物理层</strong>先将<strong>帧</strong>看做是<strong>比特流</strong>，这里的网络N1假设是以太网，所以物理层还会给该比特流前面添加<strong>前导码</strong></p><p><strong>前导码</strong>的作用是为了让目的主机做好接收帧的准备</p><p><strong>物理层</strong>将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体</p></li><li><p><strong>信号</strong>通过<strong>传输媒体</strong>到达<strong>路由器</strong></p></li></ol><p>路由器转发</p><p><strong>1. 物理层将信号变为比特流，然后去掉前导码后，将其交付给数据链路层</strong></p><p>数据链路层将<strong>帧的首部和尾部</strong>去掉后，将其交付给<strong>网络层</strong>，这实际交付的是<strong>IP数据报</strong></p><p>网络层解析<strong>IP数据报的首部</strong>，从中提取<strong>目的网络地址</strong></p><ol><li><p>提取<strong>目的网络地址</strong>后查找<strong>自身路由表</strong>。确定<strong>转发端口</strong>， 以便进行转发</p><p>网络层将<strong>IP数据报</strong>交付给数据链路层</p><p>数据链路层给IP数据报添加一个首部和一个尾部，使之成为<strong>帧</strong></p><p>数据链路层将帧交付给<strong>物理层</strong></p><p>物理层先将帧看成<strong>比特流</strong>，这里的网络N2假设是以太网，所以物理层还会给该比特流前面添加前导码</p><p>物理层将<strong>装有前导码的比特流</strong>变换成相应的信号发送给传输媒体，信号通过传输媒体到达<strong>Web服务器</strong></p></li></ol><p>接收方接受</p><ul><li><strong>物理层</strong>将信号变换为比特流，然后<strong>去掉前导码</strong>后成为<strong>帧</strong>，交付给<strong>数据链路层</strong></li><li>数据链路层将<strong>帧的首部和尾部去掉</strong>后成为<strong>IP数据报</strong>，将其交付给<strong>网络层</strong></li><li>网络层将<strong>IP数据报的首部去掉</strong>后成为<strong>TCP报文段</strong>，将其交付给<strong>运输层</strong></li><li>运输层将<strong>TCP报文段的首部去掉</strong>后成为<strong>HTTP请求报文</strong>，将其交付给<strong>应用层</strong></li><li>应用层对<strong>HTTP请求报文</strong>进行解析，然后给主机发回<strong>响应报文</strong></li></ul><hr><p><strong>专业术语</strong></p><p><code>实体</code>  任何可发送或接收信息的<strong>硬件或软件进程</strong></p><p><code>对等实体</code>  收发双方<strong>相同层次中的实体</strong></p><p>例如，下图中有十个实体</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0803.png" alt="Untitled"></p><p>协议：控制两个<strong>对等实体</strong>进行逻辑通信的规则的<strong>集合</strong></p><p>协议<strong>三</strong>要素：</p><ul><li><code>语法</code> 定义所交换信息的格式</li><li><code>语义</code> 定义收发双方所要完成的操作</li><li><code>同步</code> 定义收发双发的时序关系</li></ul><h2 id="服务"><code>服务</code></h2><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0804.png" alt="Untitled"></p><p><strong><code>服务访问点</code></strong>  在同一系统中<strong>相邻两层的实体交换信息的逻辑接口</strong>，用于区分不同的服务类型</p><p><strong><code>服务原语</code></strong>  上层使用下层所提供的服务必须通过与下层<strong>交换一些命令</strong>，这些命令称为服务原语</p><p><strong><code>协议数据单元PDU</code>  对等层次之间传送的数据包</strong>称为该层的协议数据单元</p><p><strong><code>服务数据单元SDU</code>  同一系统内，层与层之间交换的数据包</strong>称为服务数据单元。</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0805.png" alt="Untitled"></p><hr><h2 id="📚习题">📚<strong>习题</strong></h2><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0901.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0902.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0903.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0904.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0905.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0906.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0907.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0908.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0909.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0910.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0911.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0912.jpeg" alt="IMG_1405.jpeg"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0913.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0914.png" alt="Untitled"></p><hr><h2 id="📚时延专项">📚<strong>时延专项</strong></h2><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1000.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1001.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1002.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1003.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1004.png" alt="Untitled"></p><p>n-1是转发次数，所以是链路数-1</p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1005.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1006.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1007.png" alt="Untitled"></p><p><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1008.png" alt="Untitled"></p>]]></content>
    
    
    <summary type="html">计网</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="计算机网络" scheme="https://agoni66.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="四大件" scheme="https://agoni66.github.io/tags/%E5%9B%9B%E5%A4%A7%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>金字塔原理</title>
    <link href="https://agoni66.github.io/posts/1000005.html"/>
    <id>https://agoni66.github.io/posts/1000005.html</id>
    <published>2024-06-02T10:30:00.000Z</published>
    <updated>2024-08-04T10:59:18.183Z</updated>
    
    <content type="html"><![CDATA[<p><strong>📘<span class='p blue'>每一段发言应该有且仅有一个中心思想且先要把这个中心思想告诉大家</span></strong></p><ul><li>引发疑问 提供回答</li><li><img src="https://pic.imge.cc/2024/08/04/66af5eeb4915d.jpg" alt="好处" style="width: 200px; height: 200px;" /></li><li>人的认知习惯于先听一个高大时思想，再去了解下面支持这个大思想下的小思想</li></ul><p><strong>📕<span class='p red'>最多就能记三四个东西人大脑的认知特点是每次这是人工作记忆的一种限制。所以我们要把这些东西归纳分组</span></strong></p><p><strong>📗<span class='p green'>要逻辑统一</span></strong></p><ul><li>顺序不能混用</li><li>平行顺序更加适用</li></ul><p><strong>📒<span class='p yellow'>不能只用流于表面的结论，最好要提炼出论点的共性或者逻辑关系</span></strong></p><ol><li>人的思考是推着自己不断地向上提炼图纲，这就是我们思考的过程</li><li>分组的时候要考虑组内的逻辑关系和组内原因以及它们的共性，把它们组成一种结构从而提炼出高一层的洞见</li></ol><p>💕<strong>总结</strong></p><img src="https://pic.imge.cc/2024/08/04/66af5eeb4df26.jpg" alt="技巧" style="width: 200px; height: 200px;" /><p><strong><span class='p center logo large'>语言是承载思想的</span></strong></p>]]></content>
    
    
    <summary type="html">发言的艺术</summary>
    
    
    
    <category term="读书笔记" scheme="https://agoni66.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="语言" scheme="https://agoni66.github.io/tags/%E8%AF%AD%E8%A8%80/"/>
    
    <category term="演讲" scheme="https://agoni66.github.io/tags/%E6%BC%94%E8%AE%B2/"/>
    
    <category term="理论" scheme="https://agoni66.github.io/tags/%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>穷爸爸富爸爸</title>
    <link href="https://agoni66.github.io/posts/1000004.html"/>
    <id>https://agoni66.github.io/posts/1000004.html</id>
    <published>2024-05-31T09:00:00.000Z</published>
    <updated>2024-06-03T09:06:33.520Z</updated>
    
    <content type="html"><![CDATA[<div class="tip warning"><p>当宣布裁员时，上市公司的股价通常会上涨，公司通过自动化或是整合人力资源减少了人工成本，市场喜欢这样的消息</p></div><div class="tip warning"><p>要让钱为我工作</p></div><div class="tip warning"><p>拥有好车和大房子不见得就意味着你很富有或你懂得如何赚钱💰</p></div><div class="tip warning"><p>教东西一定要说或讲吗?</p></div><div class="tip warning"><p>人们通常会做两件事，一些人在生活推着他转的同时，抓住生活赐予的每个机会;而另一些人则非常生气，去与生活抗争。 他们与老板抗争，与工作抗争，甚至与自己的配偶抗争，他们不知道生活同时也给了他们机会</p></div><div class="tip warning"><p>你终其一生希望有个大机会能够把你所有的钱的问题都解决</p></div><div class="tip warning"><p>大多数人认为世界上除了自己外，其他人都应该改变</p></div><div class="tip warning"><p>穷人和中产阶级为钱而工作</p></div><div class="tip warning"><p>真正的学习需要精力、激情和热切的愿望。愤怒是其中一个重要的组成部分，因为激情正是愤怒和热爱的 结合体</p></div><div class="tip warning"><p>正是出于恐惧的心理，人们才想找一份安稳的工作</p></div><div class="tip warning"><p>他们认为钱能买来快乐，可用钱买来的快乐往往是短暂的，所以不久他们就需要更多的钱来买更多的快乐、更多的开心、更多的舒适和更多的安全感</p></div><div class="tip warning"><p>我们在根本上都是雇员，只是层次不同而已</p></div><div class="tip warning"><p>对许多人来说，离开学校是学习的终点而不是起点</p></div><div class="tip warning"><p>从长远来看，重要的不是你挣了多少钱，而是你能留下多少钱，以及能够留住多久</p></div><div class="tip warning"><p>就是为了获得更多的选择机会</p></div><div class="tip warning"><p>你把金钱看得越重，你就会为金钱工作得越辛苦</p></div><div class="tip warning"><p>成功的办法都是运用你的技术知识、智慧以及对于这个游戏的热爱来减少意外、降低风险</p></div><div class="tip warning"><p>工人付出最 大努力以免于被解雇，而雇主提供最低工资以防止工人辞职</p></div><div class="tip warning"><p>因为我将终生只在这一行里学到一种有价值的技能，如果我被这一行业抛弃，我的技能对其他行业便毫无用处</p></div><div class="tip warning"><p>他们只将注意力集中 在提高做汉堡包的技能上，却不注意提高销售和配送汉堡包的技能。也许麦当劳不能做出最好的汉堡包，但他们能在做出一般水平的汉堡包的前提下，做到最好的销售和配送工作</p></div><div class="tip warning"><p>精通专业技能既是优势也是弱点</p></div><div class="tip warning"><p>但恐惧本身并不是问题之所在，关键在于你如何处 理恐惧心理，如何处理亏钱的问题</p></div><div class="tip warning"><p>对大多数人来说，他们在财务上不成功是因为对他们而言亏钱所造成的痛苦远远大于致富所带来的乐趣</p></div><div class="tip warning"><p>失败会激励胜利者，击垮失败者</p></div><div class="tip warning"><p>用资产进行投资却是一种高智商的游戏，需要胆量、耐心和对待失败的良好态度</p></div><div class="tip warning"><p>克服困难</p></div><div class="tip ban"><p>对可能亏钱的恐惧心理</p></div><div class="tip ban"><p>愤世嫉俗的随波逐流</p></div><div class="tip ban"><p>懒惰</p></div><div class="tip ban"><p>习惯</p></div><div class="tip ban"><p>傲慢，傲慢是自大和无知的结合体</p></div><div class="tip warning"><p>忙碌的人常常是最懒惰的人，忙碌是在逃避一些很重要的事情</p></div><div class="tip warning"><p>桑德斯上校在66岁时失去了所有的产业，开始靠社会保险金生活，而那点钱根本不够用。于是他走遍全国推 销他的炸鸡秘方，在最终有人肯买秘方之前，他被拒绝了1009次。然而通过不懈努力，他在大部分人都退休的年龄成为了千万富翁</p></div><div class="tip warning"><p>“我怎样才能付得起”则打开了充满可能性的快乐和梦想之门</p></div><div class="tip warning"><p>稍稍“贪 婪”一点，这是治愈懒惰的灵丹妙药</p></div><div class="tip warning"><p>我需要超现实的力量——想要和不想要的力量</p></div><div class="tip warning"><p>每天作出自己的选择</p></div><div class="tip warning"><p>有胆量不随大溜才能致富。你也许并不软弱，但一旦涉及金钱，往往会变得怯懦</p></div><div class="tip warning"><p>不要背上数额过大的债务包袱。要保持低支出。首先增加自己的资产，然后，再用资产项产生的现金流来买大房子或好车子</p></div><div class="tip warning"><p>金钱是一种强大的力量，但不幸的是，有的人让金钱的力量反过来对付自己</p></div><div class="tip warning"><p>没有试过怎么知道不可能呢</p></div><div class="tip warning"><p>买卖游戏简单得简直让人难以置信</p></div><div class="tip warning"><p>行动的人总会击败不行动的人</p></div><div class="tip warning"><p>上天赐予我们每个人两样伟大的礼物:思想和时间</p></div>]]></content>
    
    
    <summary type="html">高薪≠财务自由</summary>
    
    
    
    <category term="读书笔记" scheme="https://agoni66.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="赚钱" scheme="https://agoni66.github.io/tags/%E8%B5%9A%E9%92%B1/"/>
    
    <category term="成功" scheme="https://agoni66.github.io/tags/%E6%88%90%E5%8A%9F/"/>
    
    <category term="金钱观" scheme="https://agoni66.github.io/tags/%E9%87%91%E9%92%B1%E8%A7%82/"/>
    
  </entry>
  
  <entry>
    <title>山茶文具店</title>
    <link href="https://agoni66.github.io/posts/1000003.html"/>
    <id>https://agoni66.github.io/posts/1000003.html</id>
    <published>2024-05-31T08:00:00.000Z</published>
    <updated>2024-06-03T09:03:24.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>作为第十一代传人的宫雨鸠子接手了山茶文具店camellia，为来自天南地北的客人们传递藏在心中无法言说的话语。<br>抱着欣赏书信传承的匠心精神来阅读此书，没想到在一封封书信中看到了各种各样的人生。<br>如果以代笔写信揭开每个人的故事为主线，那么在其中更深一层的则是鸠子由于自己年少时的叛逆，来不及向逝去的祖母说声抱歉，沉浸在深深的自责中不愿走出来。<br>此书以夏季开篇，春季收尾。主人公的思想变化也从最初的自我封闭到慢慢打开，迎接新的生活。 人生总会遇到这样那样的事，季节在轮回，我们的心路历程也在轮回。从聒噪的夏日到冷噤的秋天，再到残酷的深冬，四季轮转后，在新的一年春天，一切又会充满生机。无论过去怎样艰难，多少遗憾无法排解，但总要面对新的生活。<br>读完此书，会有一种淡淡的温暖充满整个身体，这也许就是日本文学里最奇妙的地方。如今网络时代的快捷与粗暴，让我们对待每一份关系都显得那么随意。翻开此书，当看到这些人郑重其事的去写吊唁信、分手信、绝交信，会觉得他们的生命竟是如此可爱。<br>人与人之间，最温柔的瞬间不过就是当下的那份珍惜与爱意。</p><hr><h2 id="妙句">妙句</h2><div class="tip bolt"><p>天一亮，空气便开始流动</p></div><div class="tip bolt"><p>茶杯里飘出焙炒过的茶叶的香气</p></div><div class="tip bolt"><p>信笔挥洒</p></div><div class="tip bolt"><p>含饴弄孙</p></div><div class="tip bolt"><p>木屐（jī）</p></div><div class="tip bolt"><p>平假名和片假名的字数有限，但汉字无穷无尽，简直就像踏上了没有终点、永无止境的旅程</p></div><div class="tip bolt"><p>即使写得一手靓字，如果别人完全看不懂，就无法称得上是精粹，反而会变成一种庸俗</p></div><div class="tip bolt"><p>分道扬镳</p></div><div class="tip bolt"><p>甚至有年轻女性穿着应该是想用日文汉字来表达“自 由”(free)却写成了“免费”的T恤</p></div><div class="tip bolt"><p>出现在大海上方的星座感觉比平时更壮观，也更加悠闲自在</p></div><div class="tip bolt"><p>蒟蒻（jǔ ruò）</p></div><div class="tip bolt"><p>鹡鸰（jí líng）</p></div><div class="tip bolt"><p>Sakura</p></div><div class="tip bolt"><p>日文书信开头写的“拜启”这两个字，是“带着恭谦的态度向您报 告”的意思。以这两个字开头的信，要用“敬具”结尾，也就是代表“以恭谨的心向您报告以上这些事”。</p></div><div class="tip bolt"><p>如果要表达更恭敬的礼节，就要以“谨启”为开头，以“敬白”来结尾</p></div><div class="tip bolt"><p>“顿首”表示“顿首再拜”，也就是“行笔至此，恕我失礼”之意。</p></div><div class="tip bolt"><p>写回信时，“敬悉尊函”或是“欣悉惠书”，也能够发挥起首语的作用，通常也都用“顿首”或是“草草顿首”为结尾</p></div><div class="tip bolt"><p>女性写信时，无论使用什么起首语，都要用“顿首”或是“草草顿 首”为结尾</p></div><div class="tip bolt"><p>如果省略时令问候语，直接进入主题的话，则要写“前略”。如果是 女性写信，则可以用“恕我省略寒暄”“容我省略应酬语”等稍微温和的方 式表达，增加温柔的印象。以“前略”作为起首语时，要用“不一”为结尾，代表“言犹未尽”之意</p></div><div class="tip bolt"><p>写信就像人际往来，只要尊敬对方、体贴对方、注重礼节，就会自然而然呈现这样的结果。就结论来说，书信没有所谓的正确或错误</p></div><div class="tip bolt"><p>信笺（jiān）</p></div><div class="tip bolt"><p>高座（曲艺舞台）</p></div><div class="tip bolt"><p>音色隐约流入夜晚的寂静中</p></div><div class="tip bolt"><p>雪莉酒</p></div><div class="tip bolt"><p>火腿的油脂就像雪花般在舌尖上融化</p></div><div class="tip bolt"><p>炸丁香鱼</p></div><div class="tip bolt"><p>满嘴都是海洋的味道</p></div><div class="tip bolt"><p>久违的鳗鱼让全身细胞都发出欢喜的呐喊</p></div><div class="tip bolt"><p>借钱给别人 的时候，必须当作送给对方。如果没有这种心理准备，千万不要借钱给 别人</p></div><div class="tip bolt"><p>桑布卡莫斯卡托。在桑布卡茴香酒中加入几颗咖啡豆，然后在酒上点火后，送到客人面前</p></div><div class="tip bolt"><p>立如芍药，坐如牡丹，行如百合</p></div><div class="tip bolt"><p>年终的沉静感淡淡地笼罩了整个镰仓</p></div><div class="tip bolt"><p>星星在叶子已落尽的枯树后方闪烁着</p></div><div class="tip bolt"><p>我品尝着浓醇的神酒在舌尖上打转的滋味</p></div><div class="tip bolt"><p>卡进心灵缝隙</p></div><div class="tip bolt"><p>带着一丝暖意的风就像透明的输送带，只带来美好的事物</p></div><div class="tip bolt"><p>文字的轨迹里，至今仍然镌刻着她的呼吸</p></div><div class="tip bolt"><p>宛若在空中飘浮的飞碟般轻轻提起毛笔</p></div><div class="tip bolt"><p>天空好像铺了一块蓝布，看不到一片云</p></div><div class="tip bolt"><p>浓郁的泥土芳香猛然震撼着平时沉睡的大脑的某个部分</p></div><div class="tip bolt"><p>京番茶🍵</p></div><div class="tip bolt"><p>淡淡的甜蜜芳香流入身体深处</p></div><div class="tip bolt"><p>把天堂想象成美丽的花田</p></div><div class="tip bolt"><p>感情溃堤</p></div><div class="tip bolt"><p>简直就像送自己的分身出门旅行似的</p></div><div class="tip bolt"><p>一朵樱花在茶杯中舒服地摇晃</p></div><div class="tip bolt"><p>小舞一边嗅闻着风的味道，一边小声低语着。樱花可能快开了，天空🌌带着淡淡的粉红色，露出了微笑</p></div><div class="tip bolt"><p>蓝天中有一条好像用尺画出来的笔直飞机云</p></div><div class="tip bolt"><p>魩仔鱼（mòzǎiyú）</p></div><div class="tip bolt"><p>这种平淡无奇的事令我感到幸福</p></div><div class="tip bolt"><p>天空中的粉红色和深蓝色形成渐层，宛如顶级鸡尾酒才有的色彩</p></div><div class="tip bolt"><p>晚霞仿佛在燃烧殆尽后，就这样变成了灰</p></div><div class="tip bolt"><p>樱花皆已凋谢，展现一整片夜樱之美</p></div><div class="tip bolt"><p>枝头刚抽芽的新绿宛如无数点亮的蜡烛，这些新生不久的树叶照亮了暗夜</p></div><div class="tip bolt"><p>与其苦苦追寻失去的东西，还不如好好珍惜自己眼前拥有的东西</p></div><div class="tip bolt"><p>磬（qìng）：打击乐器</p></div><div class="tip bolt"><p>鸟儿热闹地叽叽喳喳，似乎啄着夜晚的余韵</p></div>]]></content>
    
    
    <summary type="html">camellia 山茶花 理想的爱</summary>
    
    
    
    <category term="读书笔记" scheme="https://agoni66.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="文学" scheme="https://agoni66.github.io/tags/%E6%96%87%E5%AD%A6/"/>
    
    <category term="随记" scheme="https://agoni66.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
    <category term="治愈" scheme="https://agoni66.github.io/tags/%E6%B2%BB%E6%84%88/"/>
    
  </entry>
  
</feed>
