<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小黄鸭的窝窝✨</title>
  
  
  <link href="https://agoni66.github.io/atom.xml" rel="self"/>
  
  <link href="https://agoni66.github.io/"/>
  <updated>2024-11-15T00:48:04.176Z</updated>
  <id>https://agoni66.github.io/</id>
  
  <author>
    <name>小黄鸭的窝窝✨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第三章 数据结构</title>
    <link href="https://agoni66.github.io/posts/1000123.html"/>
    <id>https://agoni66.github.io/posts/1000123.html</id>
    <published>2024-11-15T14:00:00.000Z</published>
    <updated>2024-11-15T00:48:04.176Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.hello-algo.com/assets/covers/chapter_data_structure.jpg" alt="JPEG image.jpeg"></p><div class="note blue no-icon flat"><p><font size="4"><b>数据库系统概念导航🚀🚀🚀</b></font></p><ol><li><p>🐻‍❄️ <a href="https://agoni66.github.io/posts/1000121.html">第一章 初始算法</a> </p></li><li><p>🦝 <a href="https://agoni66.github.io/posts/1000122.html">第二章 复杂度分析</a> </p></li><li><p>🐳 <a href="https://agoni66.github.io/posts/1000123.html">第三章 数据结构</a> ⇦ 当前位置🪂</p></li></ol></div><h2 id="数组、链表、栈、队列、哈希表、树、堆、图"><a href="#数组、链表、栈、队列、哈希表、树、堆、图" class="headerlink" title="数组、链表、栈、队列、哈希表、树、堆、图"></a>数组、链表、栈、队列、哈希表、树、堆、图</h2><p>按逻辑结构分为：线性与非线性</p><ul><li>线性数据结构 <font color='gold'><strong>（一对一）</strong></font><ul><li>数组</li><li>链表</li><li>栈</li><li>队列</li><li>哈希表</li></ul></li><li>非线性数据结构 <font color='gold'><strong>（树状结构，一对多，除了图）</strong></font><ul><li>树</li><li>堆</li><li>图 <font color='gold'><strong>（网状结构，多对多）</strong></font></li><li>哈希表</li></ul></li></ul><p>按物理结构分为：连续与分散</p><hr><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><strong>基本数据类型是 CPU 可以直接进行运算的类型</strong>，在算法中直接被使用，主要包括以下几种：</p><ul><li>整数类型 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>浮点数类型 <code>float</code>、<code>double</code> ，用于表示小数</li><li>字符类型 <code>char</code> ，用于表示各种语言的字母、标点符号甚至表情符号等</li><li>布尔类型 <code>bool</code> ，用于表示“是”与“否”判断</li></ul><hr><h2 id="数字编码"><a href="#数字编码" class="headerlink" title="数字编码"></a>数字编码</h2><h3 id="原码、反码与补码"><a href="#原码、反码与补码" class="headerlink" title="原码、反码与补码"></a>原码、反码与补码</h3><p><img src="../img/算法/0023.png" alt="Untitled"></p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><img src="../img/算法/0024.png" alt="Untitled"></p>]]></content>
    
    
    <summary type="html">第三章 数据结构</summary>
    
    
    
    <category term="编程学习" scheme="https://agoni66.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="算法" scheme="https://agoni66.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第二章 复杂度分析</title>
    <link href="https://agoni66.github.io/posts/1000122.html"/>
    <id>https://agoni66.github.io/posts/1000122.html</id>
    <published>2024-11-14T14:00:00.000Z</published>
    <updated>2024-11-15T00:45:02.621Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../img/算法/0018.jpeg" alt="JPEG image.jpeg"></p><div class="note blue no-icon flat"><p><font size="4"><b>数据库系统概念导航🚀🚀🚀</b></font></p><ol><li><p>🐻‍❄️ <a href="https://agoni66.github.io/posts/1000121.html">第一章 初始算法</a> </p></li><li><p>🦝 <a href="https://agoni66.github.io/posts/1000122.html">第二章 复杂度分析</a> ⇦ 当前位置🪂</p></li><li><p>🐳 <a href="https://agoni66.github.io/posts/1000123.html">第三章 数据结构</a> </p></li></ol></div><h2 id="迭代与递归"><a href="#迭代与递归" class="headerlink" title="迭代与递归"></a>迭代与递归</h2><p>「迭代 iteration」是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足</p><blockquote><p><strong>for 循环的代码更加紧凑，while 循环更加灵活</strong></p></blockquote><p>每一次嵌套都是一次“升维”，有关时间复杂度</p><p>「递归 recursion」是一种算法策略，通过函数调用自身来解决问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recur</span>(<span class="params">n:<span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot; 递归，1+2+3+……+n &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 终止条件</span></span><br><span class="line"><span class="keyword">if</span> n = <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 递:递归调用</span></span><br><span class="line">  res = recur(n - <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 归:返回结果 </span></span><br><span class="line"><span class="keyword">return</span> n + res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hanoi</span>(<span class="params">n, source, target, auxiliary</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 汉诺塔 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;source&#125;</span> -&gt; <span class="subst">&#123;target&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    hanoi(n - <span class="number">1</span>, source, auxiliary, target)</span><br><span class="line">    hanoi(<span class="number">1</span>, source, target, auxiliary)</span><br><span class="line">    hanoi(n - <span class="number">1</span>, auxiliary, target, source)</span><br></pre></td></tr></table></figure><p>迭代：自下而上，不断重复</p><p>递归：自上而下，划分为更小的子问题</p><p><img src="../img/算法/0019.png" alt="Untitled"></p><hr><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><img src="../img/算法/0020.png" alt="Untitled"></p><p><img src="../img/算法/0021.png" alt="Untitled"></p>]]></content>
    
    
    <summary type="html">第二章 复杂度分析</summary>
    
    
    
    <category term="编程学习" scheme="https://agoni66.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="算法" scheme="https://agoni66.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第一章 初始算法</title>
    <link href="https://agoni66.github.io/posts/1000121.html"/>
    <id>https://agoni66.github.io/posts/1000121.html</id>
    <published>2024-11-13T14:00:00.000Z</published>
    <updated>2024-11-15T00:45:09.725Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../img/算法/0016.jpeg" alt="JPEG image.jpeg"></p><div class="note blue no-icon flat"><p><font size="4"><b>数据库系统概念导航🚀🚀🚀</b></font></p><ol><li><p>🐻‍❄️ <a href="https://agoni66.github.io/posts/1000121.html">第一章 初始算法</a> ⇦ 当前位置🪂</p></li><li><p>🦝 <a href="https://agoni66.github.io/posts/1000122.html">第二章 复杂度分析</a> </p></li><li><p>🐳 <a href="https://agoni66.github.io/posts/1000123.html">第三章 数据结构</a> </p></li></ol></div><p>「算法 algorithm」是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性。</p><ul><li>问题是明确的，包含清晰的<strong>输入</strong>和<strong>输出</strong>定义。</li><li>具有可行性，能够在有限步骤、时间和内存空间下完成。</li><li>各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。</li></ul><p>「数据结构 data structure」是计算机中组织和存储数据的方式，具有以下设计目标。</p><ul><li>空间占用尽量少，以节省计算机内存。</li><li>数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。</li><li>提供简洁的数据表示和逻辑信息，以便算法高效运行。</li></ul><p><strong><font color="blue">数据结构与算法的关系</font></strong></p><ul><li>数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。</li><li>算法是数据结构发挥作用的舞台。数据结构本身仅存储数据信息，结合算法才能解决特定问题。</li><li>算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。</li></ul><div class="table-container"><table><thead><tr><th><strong>数据结构与算法</strong></th><th><strong>拼装积木</strong></th></tr></thead><tbody><tr><td>输入数据</td><td>未拼装的积木</td></tr><tr><td>数据结构</td><td>积木组织形式，包括形状、大小、连接方式等</td></tr><tr><td>算法</td><td>把积木拼成目标形态的一系列操作步骤</td></tr><tr><td>输出数据</td><td>积木模型</td></tr></tbody></table></div><p><img src="../img/算法/0017.png" alt=""></p>]]></content>
    
    
    <summary type="html">第一章 初始算法</summary>
    
    
    
    <category term="编程学习" scheme="https://agoni66.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="算法" scheme="https://agoni66.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Git基本操作</title>
    <link href="https://agoni66.github.io/posts/1000013.html"/>
    <id>https://agoni66.github.io/posts/1000013.html</id>
    <published>2024-11-12T07:00:00.000Z</published>
    <updated>2024-11-12T07:08:37.078Z</updated>
    
    <content type="html"><![CDATA[<h3 id="克隆下仓库"><a href="#克隆下仓库" class="headerlink" title="克隆下仓库"></a>克隆下仓库</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:&#123;username&#125;/&#123;repository&#125;.git</span><br></pre></td></tr></table></figure><p><img src="../img/看漫画学Python/12.png" alt="image.png"></p><h3 id="显示工作目录状态"><a href="#显示工作目录状态" class="headerlink" title="显示工作目录状态"></a>显示工作目录状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status </span><br></pre></td></tr></table></figure><ol><li>当前分支是哪个</li><li>自上次提交以来，哪些文件被修改了（modified）</li><li>哪些文件是新的（untracked），即还没有加入到 Git 版本控制中</li><li>哪些文件当前被暂存（staged），即将被提交</li></ol><p><img src="../img/看漫画学Python/13.png" alt="image.png"></p><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add hello_world.php</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;Add hello world script by php&quot;</span></span><br></pre></td></tr></table></figure><ol><li>git add 加入暂存区</li><li>git commit 提交</li></ol><p><img src="../img/看漫画学Python/14.png" alt="image.png"></p><h3 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p><img src="../img/看漫画学Python/15.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=<span class="type">short</span></span><br></pre></td></tr></table></figure><ul><li>只显示提交的第一行</li></ul><p><img src="../img/看漫画学Python/16.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> README.md</span><br></pre></td></tr></table></figure><ul><li>只显示指定目录、文件的日志</li></ul><p><img src="../img/看漫画学Python/17.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -p</span><br></pre></td></tr></table></figure><ul><li>显示文件的改动</li></ul><p><img src="../img/看漫画学Python/18.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><ul><li>查看操作日志</li></ul><p><img src="../img/看漫画学Python/19.png" alt="image.png"></p><h3 id="进行PUSH更新仓库"><a href="#进行PUSH更新仓库" class="headerlink" title="进行PUSH更新仓库"></a>进行PUSH更新仓库</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br></pre></td></tr></table></figure><p><img src="../img/看漫画学Python/20.png" alt="image.png"></p><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p><img src="../img/看漫画学Python/21.png" alt="image.png"></p><h3 id="提交保存仓库的历史记录"><a href="#提交保存仓库的历史记录" class="headerlink" title="提交保存仓库的历史记录"></a>提交保存仓库的历史记录</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;First commit&quot;</span></span><br></pre></td></tr></table></figure><ul><li>-m 后面的是提交信息，用于概述本次提交</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure><ul><li>提交详细信息</li><li>第一行：用一行文字简述提交的更改内容</li><li>第二行：空行</li><li>第三行以后：记述更改的原因和详细内容</li><li><h1 id="（井号）标为注释的内容，不需要更改和删除"><a href="#（井号）标为注释的内容，不需要更改和删除" class="headerlink" title="（井号）标为注释的内容，不需要更改和删除"></a>（井号）标为注释的内容，不需要更改和删除</h1></li><li><code>:qa</code>  编辑器终止提交</li></ul><p><img src="../img/看漫画学Python/22.png" alt="image.png"></p><h3 id="查看工作树和暂存区的差别"><a href="#查看工作树和暂存区的差别" class="headerlink" title="查看工作树和暂存区的差别"></a>查看工作树和暂存区的差别</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure><ul><li>查看工作区（还没有add和commit）与暂存区的差别（<strong>没有差别不显示</strong>）</li></ul><p><img src="../img/看漫画学Python/23.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD</span><br></pre></td></tr></table></figure><ul><li>查看与最新提交的区别</li></ul><p><img src="../img/看漫画学Python/24.png" alt="image.png"></p><h3 id="显示分支一览表"><a href="#显示分支一览表" class="headerlink" title="显示分支一览表"></a>显示分支一览表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure><p><img src="../img/看漫画学Python/25.png" alt="image.png"></p><ul><li><code>*</code> 为当前分支</li></ul><h3 id="创建、切换分支"><a href="#创建、切换分支" class="headerlink" title="创建、切换分支"></a>创建、切换分支</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-A</span><br></pre></td></tr></table></figure><ul><li>创建名为feature-A的分支</li></ul><p><img src="../img/看漫画学Python/26.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout main</span><br></pre></td></tr></table></figure><ul><li>切换分支</li></ul><p><img src="../img/看漫画学Python/27.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -</span><br></pre></td></tr></table></figure><ul><li>切换回上一个分支</li></ul><p><img src="../img/看漫画学Python/28.png" alt="image.png"></p><h3 id="分支类型"><a href="#分支类型" class="headerlink" title="分支类型"></a>分支类型</h3><ol><li><strong>特性（Topic）分支</strong><ol><li>集中实现单一特性（主题）</li><li>除此之外不进行任何作业的分支</li></ol></li><li><strong>主干分支</strong><ol><li>通常是master分支为主干分支</li><li>特性分支的原点，也是合并的终点</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff feature-A</span><br></pre></td></tr></table></figure><ul><li>合并分支</li></ul><p><img src="../img/看漫画学Python/29.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph</span><br></pre></td></tr></table></figure><ul><li>以图表形式查看分支</li></ul><p><img src="../img/看漫画学Python/30.png" alt="image.png"></p><h3 id="更改提交"><a href="#更改提交" class="headerlink" title="更改提交"></a>更改提交</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard &#123;目标时间点的哈希值&#125;</span><br></pre></td></tr></table></figure><ul><li>回溯到目标时间点（哈希值，通过<code>git log</code>取得）</li></ul><p><img src="../img/看漫画学Python/31.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff fix-C</span><br></pre></td></tr></table></figure><ul><li>推进历史</li><li>发生了冲突，不解决冲突就无法完成合并</li><li>做出修改即可</li></ul><p><img src="../img/看漫画学Python/32.png" alt="image.png"></p><p><img src="../img/看漫画学Python/33.png" alt="image.png"></p><p><img src="../img/看漫画学Python/34.png" alt="image.png"></p><h3 id="修改提交信息"><a href="#修改提交信息" class="headerlink" title="修改提交信息"></a>修改提交信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><ul><li>进入编辑器修改提交信息</li></ul><p><img src="../img/看漫画学Python/35.png" alt="image.png"></p><h3 id="压缩历史"><a href="#压缩历史" class="headerlink" title="压缩历史"></a>压缩历史</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am</span><br></pre></td></tr></table></figure><ul><li>add命令和commit命令的结合</li></ul><ol><li>创建feature-C分支<code>$ git checkout -b feature-C</code></li><li>提交文件<code>$ git commit -am &quot;Add feature-C”</code></li><li>修改错误（使用<code>$ git diff</code>进行修正）（错误漏字等失误统称<code>typo</code>）</li></ol><p><img src="../img/看漫画学Python/36.png" alt="image.png"></p><ol><li>不希望在历史记录中看到失误类的提交，更改历史</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~<span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>选定当前分支中包含HEAD（最新提交）在内的两个最新历史记录为对象，进入编辑器修改</li></ul><p><img src="../img/看漫画学Python/37.png" alt="image.png"></p><p>可以看到没有Fix Typo（这个已经合并到Add feature-D，而且Add feature-D的哈希值已经被修改）</p><p><img src="../img/看漫画学Python/38.png" alt="image.png"></p><h3 id="获取远程仓库"><a href="#获取远程仓库" class="headerlink" title="获取远程仓库"></a>获取远程仓库</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:github-book/git-tutorial.git</span><br></pre></td></tr></table></figure><p><img src="../img/看漫画学Python/39.png" alt="image.png"></p><p>默认是master分支</p><p><code>remotes/origin/feature-D</code> 证明我们的远程仓库中已经有了feature-D 分支</p><p><img src="../img/看漫画学Python/40.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-D origin/feature-D</span><br></pre></td></tr></table></figure><ul><li>获取远程的feature-D分支</li><li><code>-b</code> 本地仓库中新建分支的名称</li></ul><p><img src="../img/看漫画学Python/41.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br></pre></td></tr></table></figure><ul><li>推送回远程仓库（现在是推送D分支）</li></ul><p><img src="../img/看漫画学Python/42.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin feature-D</span><br></pre></td></tr></table></figure><ul><li>将本地的feature-D分支更新到最新状态</li></ul><p><img src="../img/看漫画学Python/43.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">呜呼起飞</summary>
    
    
    
    <category term="读书笔记" scheme="https://agoni66.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="工具" scheme="https://agoni66.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="科普" scheme="https://agoni66.github.io/tags/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>看漫画学Python</title>
    <link href="https://agoni66.github.io/posts/1000012.html"/>
    <id>https://agoni66.github.io/posts/1000012.html</id>
    <published>2024-11-08T03:00:00.000Z</published>
    <updated>2024-11-08T02:50:35.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><ul><li>容器类可以存储任意类型的数据</li><li>方法属于类；函数可以直接调用</li><li><code>break</code>语句强行退出循环体，不再执行循环体中剩余的语句</li><li>短路设计<ul><li>与 一False全False</li><li>或 一True全True</li><li>会不计算后面的表达式</li></ul></li><li>set 集合<ul><li>add(elem)</li><li>remove(elem)</li><li>clear()</li></ul></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>string 字符串<ul><li>普通字符串</li><li>原始字符串 <code>r</code></li><li>长字符串（还是需要转义）</li></ul></li><li>转义符<ul><li>\t 水平制表符</li><li>\n 换行</li><li>\r 回车</li></ul></li><li>默认下，int()函数将字符串参数当作<strong>十进制</strong>数字进行转换</li><li>format() 格式化字符串<ul><li><code>s</code> 字符串</li><li><code>d</code> 十进制整数</li><li><code>f</code> 十进制浮点数</li><li><code>g</code> 十进制整数或浮点数</li><li><code>o</code> 八进制整数</li><li><code>x</code> 十六进制整数</li></ul></li><li>字符串查找 <code>find()</code> 返回索引</li><li>字符串替换 <code>replace(old, new[, count])</code></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>函数的可变参数</p><ul><li><p>*可变参数在函数中被组装成一个元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">*numbers</span>):</span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">        total += number</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="number">100.0</span>, <span class="number">20.0</span>, <span class="number">30.0</span>)) <span class="comment"># 150.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="number">30.0</span>, <span class="number">80.0</span>))        <span class="comment"># 110.0</span></span><br></pre></td></tr></table></figure></li><li><p>**可变参数在函数中被组装成一个字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show_info</span>(<span class="params">**info</span>):</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> info.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span> -- <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">show_info(name= <span class="string">&quot;Ben&quot;</span>, age = <span class="number">18</span>, sex = <span class="literal">True</span>)</span><br><span class="line">show_info(student_name = <span class="string">&quot;Ben&quot;</span>, student_no = <span class="number">1</span>)</span><br><span class="line"><span class="comment"># name -- Ben</span></span><br><span class="line"><span class="comment"># age -- 18</span></span><br><span class="line"><span class="comment"># sex -- True</span></span><br><span class="line"><span class="comment"># student_name -- Ben</span></span><br><span class="line"><span class="comment"># student_no -- 1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>global x</code> 修改成全局变量</p></li><li><strong>过滤函数</strong><ul><li><code>filter(function, iterable)</code></li><li>返回值不是列表，需要用<code>list()</code></li><li><strong>条件判断</strong></li></ul></li><li><strong>映射函数</strong><ul><li><code>map(function, iterable)</code></li><li>返回值不是列表，需要用<code>list()</code></li><li><strong>操作变换</strong></li></ul></li><li><p><strong>匿名函数</strong></p><ul><li><p><code>lambda 参数列表: lambda体</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">lamdba函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">opr</span>):</span><br><span class="line">    <span class="keyword">if</span> opr == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> a, b: (a + b)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> a, b: (a - b)</span><br><span class="line"></span><br><span class="line">f1 = calc(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">f2 = calc(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;10 + 5 = <span class="subst">&#123;f1(<span class="number">10</span>, <span class="number">5</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;10 - 5 = <span class="subst">&#123;f2(<span class="number">10</span>, <span class="number">5</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">data1 = [<span class="number">66</span>, <span class="number">15</span>, <span class="number">91</span>, <span class="number">28</span>, <span class="number">98</span>, <span class="number">50</span>, <span class="number">7</span>, <span class="number">80</span>, <span class="number">99</span>]</span><br><span class="line"></span><br><span class="line">filtered = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: (x &gt; <span class="number">50</span>), data1)</span><br><span class="line">data2 = <span class="built_in">list</span>(filtered)</span><br><span class="line"><span class="built_in">print</span>(data2)</span><br><span class="line"></span><br><span class="line">mapped = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: (x * <span class="number">2</span>), data1)</span><br><span class="line">data3 = <span class="built_in">list</span>(mapped)</span><br><span class="line"><span class="built_in">print</span>(data3)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><ul><li><p>类</p><ul><li><p>成员变量</p><ul><li><p>实例变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self···</span>):</span><br></pre></td></tr></table></figure></li><li><p>类变量 理解为通用数据即可</p></li></ul></li><li><p>成员方法</p><ul><li><p>实例方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">self···</span>):</span><br></pre></td></tr></table></figure></li><li><p>类方法</p><ul><li>@修饰函数、方法和类</li><li><code>def function(cls,···):</code></li></ul></li></ul></li><li>构造方法 <code>__init__()</code></li><li>属性</li></ul></li><li>私有变量<ul><li>前面加上 <code>__</code> 双下划线</li><li>默认类的变量是公有的，可以在类的外部访问</li></ul></li><li>私有方法 前面加上 <code>__</code> 双下划线</li><li>get（取值）和set（赋值）函数来访问私有变量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get（取值）和set（赋值）函数来访问私有变量</span></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">property</span>(<span class="params">self</span>)</span><br><span class="line"><span class="comment"># get() property</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@属性.setter()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">property</span>(<span class="params">self, <span class="built_in">property</span></span>):</span><br><span class="line">self.__<span class="built_in">property</span>= <span class="built_in">property</span></span><br><span class="line"><span class="comment"># set() property</span></span><br></pre></td></tr></table></figure><ul><li>继承 父类 <strong>只有公有的成员变量和方法才可以被继承</strong></li><li><strong><code>super().__init__()</code></strong> 初始化父类成员变量</li><li>多继承 继承多个父类</li><li>方法重写 子类的方法会重写Override父类的同名方法</li><li><p><strong>封装 继承 多态</strong></p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2></li><li><p><code>try-except</code> try代码块发生异常执行except代码块</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Error <span class="keyword">as</span> e:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;异常是<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 多重异常捕获</span></span><br><span class="line"><span class="keyword">except</span> (Error1, Error) <span class="keyword">as</span> e:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;异常是<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>无论try代码块执不执行，<strong>finally代码块都会执行</strong></li><li><code>raise</code> 引发异常</li></ul><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><ul><li><strong>datetime库</strong><ul><li><strong>datetime类</strong><ul><li><code>datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None)</code> 构造datetime类</li><li><code>datetime.today()</code> 返回当前的本地日期和时间</li><li><code>datetime.now(tz=None)</code> 返回指定时区的当前日期和时间（tz设置时区）</li><li><code>datetime.fromtimestamp(timestamp, tz=None)</code> 返回与UNIX时间戳对应的本地日期和时间（单位是秒）</li></ul></li><li><strong>date类</strong><ul><li><code>datetime.date(year, month, day)</code> 构造date类</li><li><code>date.today()</code> 返回当前的本地日期</li><li><code>date.fromtimestamp(timestamp)</code> 返回与UNIX时间戳对应的本地日期</li></ul></li><li><strong>time类</strong><ul><li><code>datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None)</code> 构造time类</li></ul></li><li><strong>timedelta</strong><ul><li>计算时间跨度</li><li><code>datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)</code> 构造timedelta类</li></ul></li><li><code>strftime(format)</code> <strong>日期时间对象转字符串</strong><ul><li>%m 两位月份表示</li><li>%y 两位年份表示</li><li>%Y 四位年份表示</li><li>%d 两位表示月中的一天</li><li>%H 两位小时表示（24小时制）</li><li>%I 两位小时表示（12小时制）</li><li>%p AM或PM区域性设置</li><li>%M 两位分钟表示</li><li>%S 两位秒表示</li><li>%f 以六位数表示微秒</li><li>%z +HHMM或-HHMM形式的UTC偏移</li><li>%Z 时区名称</li></ul></li><li><code>strptime(format)</code> <strong>字符串转日期时间对象</strong></li></ul></li><li><strong>re正则表达式</strong><ul><li><code>re.match(p, text)</code> 返回一个·Match匹配对象，否则返回None</li><li><code>re.search(p, text)</code> 返回第一个匹配对象，否则返回None</li><li><code>re.findall(p, text)</code> 返回所有匹配字符串列表，，否则返回None</li><li><code>re.sub(pattern, repl, string, count=0)</code> 字符串替换<ul><li>pattern 正则表达式</li><li>repl 替换的新字符串</li><li>string 被替换的旧字符串</li><li>count 替换的最大数量，默认为零</li></ul></li><li><code>re.split(pattern, string, maxsplit=0)</code> 字符串分割<ul><li>pattern 正则表达式</li><li>string 分割的字符串</li><li>maxsplit最大分割次数，默认为零</li></ul></li></ul></li><li><code>open(file, mode=‘r’, encoding=None, errors=None)</code> 打开文件<ul><li>file 要打开的文件</li><li>mode 文件打开模式<ul><li>t 文本文件模式</li><li>b 二进制文件模式</li><li>r 只读模式</li><li>w 只写模式</li><li>x 独占创建模式（文件不存在则创建；文件存在则FileExistsError异常）</li><li>a 追加模式（文件不存在则创建，文件存在则末尾追加）</li><li><ul><li>更新读写模式（必须与r、w或a组合使用）</li></ul></li></ul></li><li>encoding 打开文件的文件编码，默认是UTF编码</li><li>errors 指定文本文件发生编码错误时如何处理</li></ul></li><li><code>close()</code> 关闭文件</li><li><code>with open(filename) as file:</code> 自动释放资源（关闭文件）<ul><li>filename 文件名</li><li>file 打开的文件对象</li></ul></li><li>读写文本文件（或二进制文件）<ul><li><code>read(size=-1)</code> size限制读取的字符数，size=-1对读取的字符数没有限制</li><li><code>readline(size=-1)</code> 返回单行字符串，size限制读取的字符数</li><li><code>readlines()</code> 读取文件到一个字符串列表，每一行数据都是列表的一个元素</li><li><code>write(s)</code> 将字符串s写入文件并返回写入的字符数</li><li><code>writelines(lines)</code> 向文件中写入一个字符串列表（每一行末尾都提供分隔符）</li><li><code>flush()</code> 刷新写缓冲区，在文件没关闭的情况下将数据写入文件</li></ul></li></ul><h2 id="⭐⭐图形用户界面"><a href="#⭐⭐图形用户界面" class="headerlink" title="⭐⭐图形用户界面"></a>⭐⭐图形用户界面</h2><ul><li>应用程序</li><li>窗口</li><li>面板</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">the first wxPython program</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wx</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a app object</span></span><br><span class="line">app = wx.App()</span><br><span class="line"></span><br><span class="line"><span class="comment"># create window object(pos=position)</span></span><br><span class="line">frm = wx.Frame(<span class="literal">None</span>, title=<span class="string">&#x27;the first wxPython program&#x27;</span>, size=(<span class="number">400</span>, <span class="number">300</span>), pos=(<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line"><span class="comment"># show window(hide by default)</span></span><br><span class="line">frm.Show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># get into the main event loop</span></span><br><span class="line">app.MainLoop()</span><br></pre></td></tr></table></figure><ul><li>事件循环是一种事件或消息分发处理机制，大部分GUI在界面的现实及相应用户事件的处理都是通过主事件循环实现的</li><li>自定义窗口类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wx</span><br><span class="line"></span><br><span class="line"><span class="comment"># user-defined windows MyFrame</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFrame</span>(wx.Frame):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">super</span>().__init__(<span class="literal">None</span>, title=<span class="string">&#x27;the first wxPython program&#x27;</span>, size=(<span class="number">400</span>, <span class="number">300</span>), pos=(<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line"><span class="comment"># your own code</span></span><br><span class="line"></span><br><span class="line">app = wx.App()</span><br><span class="line"></span><br><span class="line">frm = MyFrame()</span><br><span class="line">frm.Show()</span><br><span class="line">app.MainLoop()</span><br></pre></td></tr></table></figure><ul><li>在窗口中添加控件（面板Panel和静态文本StaticText）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wx</span><br><span class="line"></span><br><span class="line"><span class="comment"># user-defined windows MyFrame</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFrame</span>(wx.Frame):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">super</span>().__init__(<span class="literal">None</span>, title=<span class="string">&#x27;the first wxPython program&#x27;</span>, size=(<span class="number">400</span>, <span class="number">300</span>), pos=(<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line"><span class="comment"># create panel object</span></span><br><span class="line">panel = wx.Panel(parent=self)</span><br><span class="line"><span class="comment"># create statictext object</span></span><br><span class="line">statictext = wx.StaticText(parent=panel, label=<span class="string">&quot;Hello World&quot;</span>, pos=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">app = wx.App()</span><br><span class="line"></span><br><span class="line">frm = MyFrame()</span><br><span class="line">frm.Show()</span><br><span class="line">app.MainLoop()</span><br></pre></td></tr></table></figure><ul><li>事件处理<ul><li>事件源（控件）</li><li>事件</li><li>事件处理程序</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wx</span><br><span class="line"></span><br><span class="line"><span class="comment"># user-defined windows MyFrame</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFrame</span>(wx.Frame):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">super</span>().__init__(<span class="literal">None</span>, title=<span class="string">&#x27;event handing&#x27;</span>, size=(<span class="number">400</span>, <span class="number">300</span>), pos=(<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line"><span class="comment"># create panel object</span></span><br><span class="line">panel = wx.Panel(parent=self)</span><br><span class="line"><span class="comment"># create statictext object</span></span><br><span class="line">self.statictext = wx.StaticText(parent=panel, label=<span class="string">&quot;please click ok button&quot;</span>, pos=(<span class="number">110</span>,<span class="number">20</span>))</span><br><span class="line">b = wx.Button(parent=panel, label=<span class="string">&#x27;OK&#x27;</span>, pos=(<span class="number">100</span>, <span class="number">50</span>))</span><br><span class="line"><span class="comment"># bind event，wx.EVT_BUTTON is the kind of event(按钮单击事件), on_click is event handing </span></span><br><span class="line">self.Bind(wx.EVT_BUTTON, self.on_click, b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_click</span>(<span class="params">self, event</span>):</span><br><span class="line">self.statictext.SetLableText(<span class="string">&quot;Hello, World.&quot;</span>)</span><br><span class="line"></span><br><span class="line">app = wx.App()</span><br><span class="line"></span><br><span class="line">frm = MyFrame()</span><br><span class="line">frm.Show()</span><br><span class="line">app.MainLoop()</span><br></pre></td></tr></table></figure><ul><li><p>布局管理</p><ul><li><strong>创建对象</strong><ul><li><code>wx.BoxSizer(wx.HORIZONTAL)</code> 创建水平方向盒子对象</li><li><code>wx.BoxSizer(wx.VERTICAL)</code> 创建垂直方向盒子对象</li><li>默认是水平方向</li></ul></li><li><p><strong>添加到父窗口</strong></p><ul><li><code>Add(window, proportion=0, flag=0, border=0)</code> 添加到父窗口</li><li>proportion 设置当前占父窗口的空间比例</li><li><p>flag 布局标志（对齐、边框、调整尺寸）</p><p><img src="../img/看漫画学Python/1.png" alt="image.png"></p><p><img src="../img/看漫画学Python/2.png" alt="image.png"></p><p><img src="../img/看漫画学Python/3.png" alt="image.png"></p></li><li><p>border 边框宽度</p></li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wx</span><br><span class="line"></span><br><span class="line"><span class="comment"># user-defined windows MyFrame</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFrame</span>(wx.Frame):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="literal">None</span>, title=<span class="string">&#x27;event handing&#x27;</span>, size=(<span class="number">400</span>, <span class="number">300</span>), pos=(<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line">        <span class="comment"># create panel object</span></span><br><span class="line">        panel = wx.Panel(parent=self)</span><br><span class="line">        <span class="comment"># create statictext object</span></span><br><span class="line">        self.statictext = wx.StaticText(parent=panel, label=<span class="string">&quot;please click ok button&quot;</span>, pos=(<span class="number">110</span>,<span class="number">20</span>))</span><br><span class="line">        b = wx.Button(parent=panel, label=<span class="string">&#x27;OK&#x27;</span>, pos=(<span class="number">100</span>, <span class="number">50</span>))</span><br><span class="line">        <span class="comment"># bind event，wx.EVT_BUTTON is the kind of event(按钮单击事件), on_click is event handing </span></span><br><span class="line">        self.Bind(wx.EVT_BUTTON, self.on_click, b)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># create a layout manager box vbox </span></span><br><span class="line">        vbox = wx.BoxSizer(wx.VERTICAL)</span><br><span class="line">        <span class="comment"># add statictext into vbox</span></span><br><span class="line">        vbox.Add(self.statictext, proportion=<span class="number">1</span>, flag=wx.ALIGN_CENTER_HORIZONTAL|wx.FIXED_MINSIZE|wx.TOP, border=<span class="number">30</span>)</span><br><span class="line">        <span class="comment"># add button b into vbox</span></span><br><span class="line">        vbox.Add(b, proportion=<span class="number">1</span>, flag=wx.EXPAND|wx.BOTTOM, border=<span class="number">10</span>)</span><br><span class="line">        panel.SetSizer(vbox)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_click</span>(<span class="params">self, event</span>):</span><br><span class="line">        self.statictext.SetLabelText(<span class="string">&quot;Hello, World.&quot;</span>)</span><br><span class="line"></span><br><span class="line">app = wx.App()</span><br><span class="line"></span><br><span class="line">frm = MyFrame()</span><br><span class="line">frm.Show()</span><br><span class="line">app.MainLoop()</span><br></pre></td></tr></table></figure><p><img src="../img/看漫画学Python/4.png" alt="image.png"></p><ul><li>控件<ul><li><strong>wx.TextCtrl() 文本输入控件</strong></li><li><code>wx.TextCtrl(panel)</code></li><li><code>wx.TextCtrl(panel, style=wx.TE_PASSWORD)</code></li><li><code>wx.TextCtrl(panel, style=wx.TE_MULTILINE)</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wx</span><br><span class="line"></span><br><span class="line"><span class="comment"># user-defined windows MyFrame</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFrame</span>(wx.Frame):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="literal">None</span>, title=<span class="string">&#x27;文本输入控件&#x27;</span>, size=(<span class="number">400</span>, <span class="number">300</span>), pos=(<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line">        panel = wx.Panel(parent=self)</span><br><span class="line">        tc1 = wx.TextCtrl(panel)</span><br><span class="line">        tc2 = wx.TextCtrl(panel, style=wx.TE_PASSWORD)</span><br><span class="line">        tc3 = wx.TextCtrl(panel, style=wx.TE_MULTILINE)</span><br><span class="line"></span><br><span class="line">        userid = wx.StaticText(panel, label=<span class="string">&quot;用户ID:&quot;</span>)</span><br><span class="line">        pwd = wx.StaticText(panel, label=<span class="string">&quot;密码:&quot;</span>)</span><br><span class="line">        content = wx.StaticText(panel, label=<span class="string">&quot;多行文本:&quot;</span>)</span><br><span class="line"></span><br><span class="line">        vbox = wx.BoxSizer(wx.VERTICAL)</span><br><span class="line">        vbox.Add(userid, flag=wx.EXPAND|wx.LEFT, border=<span class="number">10</span>)</span><br><span class="line">        vbox.Add(tc1, flag=wx.EXPAND|wx.ALL, border=<span class="number">10</span>)</span><br><span class="line">        vbox.Add(pwd, flag=wx.EXPAND|wx.LEFT, border=<span class="number">10</span>)</span><br><span class="line">        vbox.Add(tc2, flag=wx.EXPAND|wx.ALL, border=<span class="number">10</span>)</span><br><span class="line">        vbox.Add(content, flag=wx.EXPAND|wx.LEFT, border=<span class="number">10</span>)</span><br><span class="line">        vbox.Add(tc3, flag=wx.EXPAND|wx.ALL, border=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># set panel</span></span><br><span class="line">        panel.SetSizer(vbox)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_click</span>(<span class="params">self, event</span>):</span><br><span class="line">        self.statictext.SetLabelText(<span class="string">&quot;Hello, World.&quot;</span>)</span><br><span class="line"></span><br><span class="line">app = wx.App()</span><br><span class="line"></span><br><span class="line">frm = MyFrame()</span><br><span class="line">frm.Show()</span><br><span class="line">app.MainLoop()</span><br></pre></td></tr></table></figure><p><img src="../img/看漫画学Python/5.png" alt="image.png"></p><ul><li>复选框和单选按钮</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wx</span><br><span class="line"></span><br><span class="line"><span class="comment"># user-defined windows MyFrame</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFrame</span>(wx.Frame):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="literal">None</span>, title=<span class="string">&#x27;复选框和单选按钮&#x27;</span>, size=(<span class="number">400</span>, <span class="number">300</span>), pos=(<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line">        panel = wx.Panel(parent=self)</span><br><span class="line"></span><br><span class="line">        st1 = wx.StaticText(panel, label=<span class="string">&quot;select one your favorite language&quot;</span>)</span><br><span class="line">        cb1 = wx.CheckBox(panel, <span class="built_in">id</span>=<span class="number">1</span>, label=<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">        cb2 = wx.CheckBox(panel, <span class="built_in">id</span>=<span class="number">2</span>, label=<span class="string">&quot;Java&quot;</span>)</span><br><span class="line">        cb2.SetValue(<span class="literal">True</span>) <span class="comment"># 设置cb2初始状态为选中</span></span><br><span class="line">        cb3 = wx.CheckBox(panel, <span class="built_in">id</span>=<span class="number">3</span>, label=<span class="string">&quot;C++&quot;</span>)</span><br><span class="line">        self.Bind(wx.EVT_CHECKBOX, self.on_checkbox_click, <span class="built_in">id</span>=<span class="number">1</span>, id2=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        st2 = wx.StaticText(panel, label=<span class="string">&quot;选择性别:&quot;</span>)</span><br><span class="line">        radio1 = wx.RadioButton(panel, <span class="built_in">id</span>=<span class="number">4</span>, label=<span class="string">&quot;男&quot;</span>, style=wx.RB_GROUP)</span><br><span class="line">        radio2 = wx.RadioButton(panel, <span class="built_in">id</span>=<span class="number">5</span>, label=<span class="string">&quot;女&quot;</span>)</span><br><span class="line">        self.Bind(wx.EVT_CHECKBOX, self.on_radio1_click, <span class="built_in">id</span>=<span class="number">4</span>, id2=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        hbox1 = wx.BoxSizer()</span><br><span class="line">        hbox1.Add(st1, flag=wx.Left|wx.Right, border=<span class="number">5</span>)</span><br><span class="line">        hbox1.Add(cb1)</span><br><span class="line">        hbox1.Add(cb2)</span><br><span class="line">        hbox1.Add(cb3)</span><br><span class="line"></span><br><span class="line">        hbox2 = wx.BoxSizer()</span><br><span class="line">        hbox2.Add(st2, flag=wx.Left|wx.Right, border=<span class="number">5</span>)</span><br><span class="line">        hbox2.Add(radio1)</span><br><span class="line">        hbox2.Add(radio2)</span><br><span class="line"></span><br><span class="line">        vbox = wx.BoxSizer(wx.VERTICAL)</span><br><span class="line">        vbox.Add(hbox1, flag=wx.ALL, border=<span class="number">10</span>)</span><br><span class="line">        vbox.Add(hbox2, flag=wx.ALL, border=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># set panel</span></span><br><span class="line">        panel.SetSizer(vbox)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_checkbox_click</span>(<span class="params">self, event</span>):</span><br><span class="line">        cb = event.GetEventObject()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;选择<span class="subst">&#123;cb.GetLabel()&#125;</span>，状态<span class="subst">&#123;event.IsChecked()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_radio1_click</span>(<span class="params">self, event</span>):</span><br><span class="line">        rb = event.GetEventObject()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;第一组<span class="subst">&#123;rb.GetLabel()&#125;</span>被选中&quot;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">app = wx.App()</span><br><span class="line"></span><br><span class="line">frm = MyFrame()</span><br><span class="line">frm.Show()</span><br><span class="line">app.MainLoop()</span><br></pre></td></tr></table></figure><p><img src="../img/看漫画学Python/6.png" alt="image.png"></p><ul><li>列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wx</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFrame</span>(wx.Frame):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="literal">None</span>, title=<span class="string">&quot;列表&quot;</span>, size=(<span class="number">350</span>, <span class="number">175</span>))</span><br><span class="line">        panel = wx.Panel(parent=self)</span><br><span class="line"></span><br><span class="line">        st1 = wx.StaticText(panel, label=<span class="string">&quot;选择你喜欢的编程语言：&quot;</span>)</span><br><span class="line">        list1 = [<span class="string">&#x27;Python&#x27;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Java&quot;</span>]</span><br><span class="line">        lb1 = wx.ListBox(panel, choices=list1, style=wx.LB_SINGLE)</span><br><span class="line">        self.Bind(wx.EVT_LISTBOX, self.on_listbox1, lb1)</span><br><span class="line"></span><br><span class="line">        st2 = wx.StaticText(panel, label=<span class="string">&quot;选择你喜欢吃的水果：&quot;</span>)</span><br><span class="line">        list2 = [<span class="string">&quot;苹果&quot;</span>, <span class="string">&quot;橘子&quot;</span>, <span class="string">&quot;香蕉&quot;</span>]</span><br><span class="line">        lb2 = wx.ListBox(panel, choices=list2, style=wx.LB_EXTENDED)</span><br><span class="line">        self.Bind(wx.EVT_LISTBOX, self.on_listbox2, lb2)</span><br><span class="line"></span><br><span class="line">        hbox1 = wx.BoxSizer()</span><br><span class="line">        hbox1.Add(st1, proportion=<span class="number">1</span>, flag=wx.LEFT|wx.RIGHT, border=<span class="number">5</span>)</span><br><span class="line">        hbox1.Add(lb1, proportion=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        hbox2 = wx.BoxSizer()</span><br><span class="line">        hbox2.Add(st2, proportion=<span class="number">1</span>, flag=wx.LEFT|wx.RIGHT, border=<span class="number">5</span>)</span><br><span class="line">        hbox2.Add(lb2, proportion=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        vbox = wx.BoxSizer(wx.VERTICAL)</span><br><span class="line">        vbox.Add(hbox1, flag=wx.ALL|wx.EXPAND, border=<span class="number">5</span>)</span><br><span class="line">        vbox.Add(hbox2, flag=wx.ALL|wx.EXPAND, border=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        panel.SetSizer(vbox)   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_listbox1</span>(<span class="params">self, event</span>):</span><br><span class="line">        listbox = event.GetEventObject()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;选择（0)&quot;</span>.<span class="built_in">format</span>(listbox.GetSelection()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_listbox2</span>(<span class="params">self, event</span>):</span><br><span class="line">        listbox = event.GetEventObject()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;选择（0)&quot;</span>.<span class="built_in">format</span>(listbox.GetSelections()))   </span><br><span class="line"></span><br><span class="line">app = wx.App()</span><br><span class="line"></span><br><span class="line">frm = MyFrame()</span><br><span class="line">frm.Show()</span><br><span class="line">app.MainLoop()</span><br></pre></td></tr></table></figure><p><img src="../img/看漫画学Python/7.png" alt="image.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wx</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFrame</span>(wx.Frame):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="literal">None</span>, title=<span class="string">&#x27;静态图片控件&#x27;</span>, size=(<span class="number">1000</span>, <span class="number">1000</span>))</span><br><span class="line">        self.panel = wx.Panel(parent=self)</span><br><span class="line"></span><br><span class="line">        self.bmps = [</span><br><span class="line">            wx.Bitmap(<span class="string">&#x27;T:/MY WORLD/chasing stars/一起走花路吧.png&#x27;</span>, wx.BITMAP_TYPE_ANY),</span><br><span class="line">            wx.Bitmap(<span class="string">&#x27;T:/MY WORLD/chasing stars/海源1.png&#x27;</span>, wx.BITMAP_TYPE_ANY),</span><br><span class="line">            wx.Bitmap(<span class="string">&#x27;T:/MY WORLD/chasing stars/一起走花路吧.png&#x27;</span>, wx.BITMAP_TYPE_ANY)</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        b1 = wx.Button(self.panel, <span class="built_in">id</span>=<span class="number">1</span>, label=<span class="string">&#x27;Button1&#x27;</span>)</span><br><span class="line">        b2 = wx.Button(self.panel, <span class="built_in">id</span>=<span class="number">2</span>, label=<span class="string">&#x27;Button2&#x27;</span>)</span><br><span class="line">        self.Bind(wx.EVT_BUTTON, self.on_click, <span class="built_in">id</span>=<span class="number">1</span>, id2=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.image = wx.StaticBitmap(self.panel, bitmap=self.bmps[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        vbox = wx.BoxSizer(wx.VERTICAL)</span><br><span class="line">        vbox.Add(b1, proportion=<span class="number">1</span>, flag=wx.EXPAND)</span><br><span class="line">        vbox.Add(b2, proportion=<span class="number">1</span>, flag=wx.EXPAND)</span><br><span class="line">        vbox.Add(self.image, proportion=<span class="number">3</span>, flag=wx.EXPAND)</span><br><span class="line"></span><br><span class="line">        self.panel.SetSizer(vbox)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_click</span>(<span class="params">self, event</span>):</span><br><span class="line">        event_id = event.GetId()</span><br><span class="line">        <span class="keyword">if</span> event_id == <span class="number">1</span>:</span><br><span class="line">            self.image.SetBitmap(self.bmps[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.image.SetBitmap(self.bmps[<span class="number">2</span>])</span><br><span class="line">        self.panel.Layout()</span><br><span class="line"></span><br><span class="line">app = wx.App()</span><br><span class="line"></span><br><span class="line">frm = MyFrame()</span><br><span class="line">frm.Show()</span><br><span class="line">app.MainLoop()</span><br></pre></td></tr></table></figure><p><img src="../img/看漫画学Python/8.png" alt="image.png"></p><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;发送GET请求&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://agoni66.github.io/&#x27;</span></span><br><span class="line"></span><br><span class="line">req = urllib.request.Request(url)</span><br><span class="line"><span class="keyword">with</span> urllib.request.urlopen(req) <span class="keyword">as</span> response:</span><br><span class="line">    data = response.read()</span><br><span class="line">    json_data = data.decode()</span><br><span class="line">    <span class="built_in">print</span>(json_data)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;发送POST请求&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://agoni66.github.io/&#x27;</span></span><br><span class="line"></span><br><span class="line">params_dict = &#123;<span class="string">&#x27;action&#x27;</span>:<span class="string">&#x27;query&#x27;</span>, <span class="string">&#x27;ID&#x27;</span>:<span class="string">&#x27;10&#x27;</span>&#125;</span><br><span class="line">params_str = urllib.parse.urlencode(params_dict)</span><br><span class="line"><span class="built_in">print</span>(params_str)</span><br><span class="line"></span><br><span class="line">params_bytes = params_str.encode()</span><br><span class="line"></span><br><span class="line">req = urllib.request.Request(url)</span><br><span class="line"><span class="keyword">with</span> urllib.request.urlopen(req) <span class="keyword">as</span> response:</span><br><span class="line">    data = response.read()</span><br><span class="line">    json_data = data.decode()</span><br><span class="line">    <span class="built_in">print</span>(json_data)</span><br></pre></td></tr></table></figure><ul><li>JSON(JavaScript Object Notation)</li><li>JSON文档<ul><li>JSON对象</li><li>JSON数组</li></ul></li><li>下载文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;下载文件&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://wkphoto.cdn.bcebos.com/37d3d539b6003af3156af430252ac65c1138b689.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line">req = urllib.request.Request(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> urllib.request.urlopen(req) <span class="keyword">as</span> response:</span><br><span class="line">    data = response.read()</span><br><span class="line">    f_name = <span class="string">&#x27;download.jpg&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(f_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(data)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;下载文件成功&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>JSON对象解码——字典</li><li>JSON数组解码——列表</li></ul><h2 id="访问数据库"><a href="#访问数据库" class="headerlink" title="访问数据库"></a>访问数据库</h2><ul><li>数据类型<ul><li>INTEGER 有符号的整数类型</li><li>REAL 浮点类型</li><li>TEXT 字符串类型（UTF-8、UTF-16）</li><li>BLOB 二进制大对象类型，能够存放任意二进制数据</li></ul></li><li>Python数据类型与SQLite数据类型的映射</li></ul><div class="table-container"><table><thead><tr><th>Python数据类型</th><th>SQLite数据类型</th></tr></thead><tbody><tr><td>None</td><td>NULL</td></tr><tr><td>int</td><td>INTEGER</td></tr><tr><td>float</td><td>REAL</td></tr><tr><td>str</td><td>TEXT</td></tr><tr><td>bytes</td><td>BLOB</td></tr></tbody></table></div><ul><li>数据库连接对象Connection<ul><li>connect(database) 打开数据库连接，database是数据库的文件路径</li><li>close() 关闭数据库连接</li><li>commit() 提交数据库事务</li><li>rollback() 回滚数据库事务</li><li>cursor() 获得Cursor游标对象</li></ul></li><li>游标cursor操作<ul><li>execute(sql[, parameters]) 执行一条SQL语句</li><li>execute(sql[, seq_of_params]) 执行批量SQL语句</li><li>fetchone() 从结果中返回只有一条记录的序列</li><li>fetchmany(size=cursor.arraysize) 从结果中返回小于等于size记录数的序列</li><li>fetchall() 从结果集中返回所有数据</li></ul></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li><p>线程模块——threading</p><ul><li><code>active_count()</code> 返回当前处于活动状态的线程个数</li><li><code>current_thread()</code> 返回当前的线程对象</li><li><code>main_thread()</code> 返回主线程对象</li><li><code>Thread(target=None, name=None,args=())</code> 创建线程Thread对象<ul><li>target参数指向线程体函数</li><li>name参数可以设置线程名</li><li>args是为线程体函数提供的参数</li></ul></li><li><p><strong>有休眠和没有休眠的区别</strong></p><p><img src="../img/看漫画学Python/9.png" alt="image.png"></p></li></ul></li><li><p>自定义线程函数</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程体函数，该函数可以使得当前线程休眠两秒。只有当前线程休眠,其他线程才有机会执行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_body</span>():</span><br><span class="line">    <span class="comment"># 当前线程对象</span></span><br><span class="line">    t = threading.current_thread()</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="comment"># 当前线程名</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;第&#123;0&#125;次执行线程&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(n, t.name))</span><br><span class="line">        <span class="comment"># 线程休眠</span></span><br><span class="line">        <span class="comment"># time.sleep(2)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;线程&#123;0&#125;执行完成!&#x27;</span>.<span class="built_in">format</span>(t.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程</span></span><br><span class="line"><span class="comment"># 创建线程对象t1</span></span><br><span class="line">t1 = threading.Thread(target=thread_body)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程对象t2</span></span><br><span class="line">t2 = threading.Thread(target=thread_body, name=<span class="string">&#x27;MyThread&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动线程t1</span></span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动线程t2</span></span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><ul><li>自定义线程类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义线程类的构造方法, name参数是线程名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name=name)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 线程体函数，重写父类Thread的run()方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 当前线程对象</span></span><br><span class="line">        t = threading.current_thread()</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="comment"># 当前线程名</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;第&#123;0&#125;次执行线程&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(n, t.name))</span><br><span class="line">            <span class="comment"># 线程休眠</span></span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;线程&#123;0&#125;执行完成!&#x27;</span>.<span class="built_in">format</span>(t.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程</span></span><br><span class="line"><span class="comment"># 通过自定义线程类，创建线程对象</span></span><br><span class="line"><span class="comment"># 创建线程对象t1</span></span><br><span class="line">t1 = SmallThread()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程对象t2</span></span><br><span class="line">t2 = SmallThread(name=<span class="string">&#x27;MyThread&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动线程t1</span></span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动线程t2</span></span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><ul><li>线程管理<ul><li>线程创建</li><li>线程启动</li><li>线程休眠</li><li>等待线程结束</li><li>线程停止</li></ul></li><li>等待线程结束</li></ul><p><code>join(timeout=None)</code> timeout用于设置超时时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 共享变量</span></span><br><span class="line">value = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程体函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_body</span>():</span><br><span class="line">    <span class="comment"># 在子线程体中修改变量value的内容</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;t1子线程开始...&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;t1子线程执行...&#x27;</span>)</span><br><span class="line">        value.append(n)</span><br><span class="line">        <span class="comment"># 线程休眠</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;t1子线程结束。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程开始执行...</span></span><br><span class="line"><span class="comment"># 创建线程对象t1</span></span><br><span class="line">t1 = threading.Thread(target=thread_body)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动线程t1</span></span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程被阻塞，等待t1线程结束</span></span><br><span class="line">t1.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># t1线程结束，继续执行，访问并输出变量value</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;value=&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(value))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;主线程继续执行...&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="../img/看漫画学Python/10.png" alt="image.png"></p><ul><li>线程停止</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程停止变量</span></span><br><span class="line">isrunning = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作线程体函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">workthread_body</span>():</span><br><span class="line">    <span class="keyword">global</span> isrunning</span><br><span class="line">    <span class="keyword">while</span> isrunning:</span><br><span class="line">        <span class="comment"># 线程开始工作</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;工作线程执行中...&#x27;</span>)</span><br><span class="line">        <span class="comment"># 线程休眠</span></span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;工作线程结束。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制线程体函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">controlthread_body</span>():</span><br><span class="line">    <span class="keyword">global</span> isrunning</span><br><span class="line">    <span class="keyword">while</span> isrunning:</span><br><span class="line">        <span class="comment"># 从键盘输入停止指令exit</span></span><br><span class="line">        command = <span class="built_in">input</span>(<span class="string">&#x27;请输入停止指令:&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> command == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">            isrunning = <span class="literal">False</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;控制线程结束。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程</span></span><br><span class="line"><span class="comment"># 创建工作线程对象workthread</span></span><br><span class="line">workthread = threading.Thread(target=workthread_body)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动线程workthread</span></span><br><span class="line">workthread.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建控制线程对象controlthread</span></span><br><span class="line">controlthread = threading.Thread(target=controlthread_body)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动线程controlthread</span></span><br><span class="line">controlthread.start()</span><br></pre></td></tr></table></figure><p><img src="../img/看漫画学Python/11.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">再次启航</summary>
    
    
    
    <category term="读书笔记" scheme="https://agoni66.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="工具" scheme="https://agoni66.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="科普" scheme="https://agoni66.github.io/tags/%E7%A7%91%E6%99%AE/"/>
    
    <category term="漫画" scheme="https://agoni66.github.io/tags/%E6%BC%AB%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>趣话计算机底层技术</title>
    <link href="https://agoni66.github.io/posts/1000011.html"/>
    <id>https://agoni66.github.io/posts/1000011.html</id>
    <published>2024-10-31T17:00:00.000Z</published>
    <updated>2024-11-01T16:57:47.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-中央处理器CPU"><a href="#第一章-中央处理器CPU" class="headerlink" title="第一章 中央处理器CPU"></a>第一章 中央处理器CPU</h1><h3 id="1-1-1-逻辑门"><a href="#1-1-1-逻辑门" class="headerlink" title="1.1.1 逻辑门"></a>1.1.1 逻辑门</h3><p><img src="../img/趣话计算机底层技术/0001.png" alt=""></p><h3 id="1-1-2-加法器"><a href="#1-1-2-加法器" class="headerlink" title="1.1.2 加法器"></a>1.1.2 加法器</h3><p><img src="../img/趣话计算机底层技术/0002.png" alt=""></p><h3 id="1-1-3-算术逻辑单元ALU"><a href="#1-1-3-算术逻辑单元ALU" class="headerlink" title="1.1.3 算术逻辑单元ALU"></a>1.1.3 算术逻辑单元ALU</h3><ul><li>既可以<strong>算术运算</strong>，也可以<strong>逻辑运算</strong></li><li>本质都是通过输入控制的<strong>开关</strong></li><li>乘法转换成加法</li><li>除法转换成减法</li><li>减法转换成加法</li></ul><h3 id="1-2-1-指令集"><a href="#1-2-1-指令集" class="headerlink" title="1.2.1 指令集"></a>1.2.1 指令集</h3><ul><li><strong>指令机器码</strong> CPU支持的所有指令的编码（比特流）</li><li><strong>CPU的指令集</strong> 所有的指令</li><li><strong>RISC</strong> 一条指令只完成一个基本操作的精简指令集，指令长度基本固定</li><li><strong>CISC</strong> 一个指令可以完成一个复杂功能的复杂指令集，指令长度基本不固定</li></ul><h3 id="1-2-2-寄存器"><a href="#1-2-2-寄存器" class="headerlink" title="1.2.2 寄存器"></a>1.2.2 寄存器</h3><ul><li><strong>原因</strong> 存储在内存不安全，读写效率慢</li><li><strong>寄存器</strong> CPU内部保存数据的存储电路</li><li>有指令操作寄存器</li></ul><h3 id="1-2-3-汇编语言"><a href="#1-2-3-汇编语言" class="headerlink" title="1.2.3 汇编语言"></a>1.2.3 汇编语言</h3><ul><li><strong>汇编语言</strong> 用<strong>助记符</strong>来编程的语言</li></ul><h3 id="1-2-4-高级语言"><a href="#1-2-4-高级语言" class="headerlink" title="1.2.4 高级语言"></a>1.2.4 高级语言</h3><ul><li><strong>高级语言</strong> 接近人类的自然语言来编程的语言</li><li><strong>编译器</strong></li><li><strong>编译</strong> 高级语言转换成机器指令</li></ul><h3 id="1-2-5-指令执行过程"><a href="#1-2-5-指令执行过程" class="headerlink" title="1.2.5 指令执行过程"></a>1.2.5 指令执行过程</h3><ol><li>读取指令</li><li>指令译码</li><li>指令执行</li><li>数据会写</li></ol><h3 id="1-3-1-指令流水集"><a href="#1-3-1-指令流水集" class="headerlink" title="1.3.1 指令流水集"></a>1.3.1 指令流水集</h3><ul><li>改进执行指令的流程，提升性能</li></ul><p><img src="../img/趣话计算机底层技术/0003.png" alt=""></p><h3 id="1-3-2-流水线的级数"><a href="#1-3-2-流水线的级数" class="headerlink" title="1.3.2 流水线的级数"></a>1.3.2 流水线的级数</h3><ul><li>将指令执行过程拆分更细</li><li>进一步减少CPU电路资源的浪费</li><li>但是级数过多会增加额外的电路设备，产生额外的功耗，造成额外的时间开销</li></ul><h3 id="1-3-3-流水线里的冒险"><a href="#1-3-3-流水线里的冒险" class="headerlink" title="1.3.3 流水线里的冒险"></a>1.3.3 流水线里的冒险</h3><ul><li><strong>原因</strong><ul><li>访问同一电路（内存、输出）导致流水线停顿</li><li>指令所需数据来自前一指令</li></ul></li><li><strong>结构冒险</strong> 流水线中出现硬件资源竞争</li><li><strong>数据冒险</strong> 流水线中后面的指令需要等待前面指令完成数据的读写</li><li><strong>控制冒险</strong> 流水线需要根据前面的指令的执行结果来决定下一步去哪里执行</li></ul><h3 id="1-4-缓存"><a href="#1-4-缓存" class="headerlink" title="1.4 缓存"></a>1.4 缓存</h3><ul><li><strong>缓存</strong> 保存从内存的数据和指令</li><li><strong>缓存行</strong> 管理内存的单元</li><li><strong>取模映射</strong> 内存中的数据只能存在缓存中的固定位置，方便存储和访问</li><li><strong>二路组相联</strong> 每个cache分成两组，即两个缓存行<ul><li>降低冲突——允许多个具有相同索引但不同标记的数据同时被缓存</li><li>提高命中率——每个组有两个缓存行，它可以存储更多的数据</li></ul></li><li><strong>指令缓存</strong> 存储指令</li><li><strong>数据缓存</strong> 存储数据</li><li><strong>三级缓存技术</strong><ul><li>一级缓存</li><li>二级缓存</li><li>三级缓存（<strong>CPU多核共用</strong>）</li></ul></li></ul><h3 id="1-5-多核缓存不一致问题"><a href="#1-5-多核缓存不一致问题" class="headerlink" title="1.5 多核缓存不一致问题"></a>1.5 多核缓存不一致问题</h3><ul><li><strong>原子操作</strong> 不可切分的动作</li><li><strong>片内总线</strong> 多核之间进行信息沟通</li><li><strong>缓存一致性协议（缓存行的四种状态）</strong><ul><li>已修改(Modified, M)</li><li>独占(Exclusive, E)</li><li>共享(Shared, S)</li><li>无效(Invalid, I)</li></ul></li></ul><p><img src="../img/趣话计算机底层技术/0004.png" alt=""></p><ul><li>规定一个内存被多个核缓存，不允许多个核同时修改缓存❎</li></ul><h3 id="1-6-指令乱序执行"><a href="#1-6-指令乱序执行" class="headerlink" title="1.6 指令乱序执行"></a>1.6 指令乱序执行</h3><ul><li>数据冒险与流水线停顿</li><li><strong>数据冒险</strong> 流水线中后面的指令需要等待前面指令完成数据的读写</li><li><strong>乱序执行</strong> 先执行不需要依赖前面数据的指令，打乱指令执行的顺序</li><li><strong>保留站</strong> 一个缓冲区登记指令是否有数据依赖、具体依赖什么数据、需要用到的执行部件有哪些、当前是否繁忙、以及需要读写的寄存器</li></ul><p><img src="../img/趣话计算机底层技术/0005.png" alt=""></p><h3 id="1-7-控制冒险与跳转指令"><a href="#1-7-控制冒险与跳转指令" class="headerlink" title="1.7 控制冒险与跳转指令"></a>1.7 控制冒险与跳转指令</h3><ul><li><strong>静态预测</strong> 不管前面结果，直接<strong>假定分支不会跳转</strong>继续把后续的指令载入流水线处理</li><li><strong>分支预测</strong> 记录最近跳转的次数，根据最近多次跳转的结果再来预测</li></ul><h3 id="1-8-一条指令同时处理多个数据"><a href="#1-8-一条指令同时处理多个数据" class="headerlink" title="1.8 一条指令同时处理多个数据"></a>1.8 一条指令同时处理多个数据</h3><ul><li><strong>MMO〜MM7</strong> 64位寄存器，同时存储两个32位的整数和8个8位的整数（借用用浮点数运算单元FPU的寄存器）</li><li><strong>XMMO〜XMM7</strong> 128位寄存器</li><li><strong>单指令多数据流SIMD</strong> 在一条指令中同时处理多个数据的技术</li></ul><h3 id="1-9-一个核同时执行两个线程"><a href="#1-9-一个核同时执行两个线程" class="headerlink" title="1.9 一个核同时执行两个线程"></a>1.9 一个核同时执行两个线程</h3><ul><li><strong>资源闲置</strong> 比如整数运算时浮点数运算电路会闲置</li><li><strong>超线程</strong> 单线程改多线程，效率不能翻倍但有提升</li></ul><p><img src="../img/趣话计算机底层技术/0006.png" alt=""></p><h3 id="1-10-管理内存"><a href="#1-10-管理内存" class="headerlink" title="1.10 管理内存"></a>1.10 管理内存</h3><ul><li><strong>分段式存储管理</strong> 寄存器16位，最大64KB的段</li><li><strong>访问内存</strong> 段地址+段内偏移地址</li><li><strong>OS划分时间片</strong></li><li><strong>虚拟内存</strong></li><li><strong>分页交换</strong> 把暂时不用的页面放到硬盘，使用页错误中断换回页面</li></ul><h3 id="1-11-地址翻译"><a href="#1-11-地址翻译" class="headerlink" title="1.11 地址翻译"></a>1.11 地址翻译</h3><ul><li><strong>内存管理单元MMU</strong></li><li><strong>页目录索引</strong></li><li><strong>页表索引</strong></li><li><strong>页内偏移</strong></li><li><strong>地址翻译</strong> 从CR3寄存器中取出页目录地址，根据页目录索引找到页表，再根据页表索引找到物理内存页面，最后根据页内偏移，完成寻址</li><li><strong>地址翻译缓存</strong> 把翻译的虚拟地址和物理地址的映射关系放入缓存（局部性原理）</li><li><strong>地址转换后援缓冲器（快表）TLB</strong></li></ul><h3 id="1-12-GPU"><a href="#1-12-GPU" class="headerlink" title="1.12 GPU"></a>1.12 GPU</h3><ul><li><strong>多计算电路，少逻辑控制电路</strong></li><li><strong>SIMT并行计算</strong> （批量计算算法固定）</li></ul><p><img src="../img/趣话计算机底层技术/0007.png" alt=""></p><ul><li><strong>多ALU and 多执行上下文</strong> （充分利用计算资源，不让ALU闲置）</li></ul><h1 id="第二章-存储设备"><a href="#第二章-存储设备" class="headerlink" title="第二章 存储设备"></a>第二章 存储设备</h1><h3 id="2-1-缓存为什么快"><a href="#2-1-缓存为什么快" class="headerlink" title="2.1 缓存为什么快"></a>2.1 缓存为什么快</h3><ul><li><strong>内存</strong> 动态随机存储器DRAM（1个DRAM单元——一个MOS晶体管和一个电容，可以存储1比特的信息）</li><li><strong>缓存</strong> 静态随机存储器SRAM</li><li>缓存因为为没有依靠电容充放电，全都是晶体管的导通与断开，比起内存的DRAM速度要快得多</li><li>缺点 成本高、占用空间大</li></ul><h3 id="2-2-内存条"><a href="#2-2-内存条" class="headerlink" title="2.2 内存条"></a>2.2 内存条</h3><ul><li><strong>存储芯片</strong> 黑乎乎的东西8～16个</li><li><strong>PCB电路板</strong></li><li><strong>金手指</strong> 连接主板插槽的接触点</li><li><strong>RAM</strong> 随机存储器</li><li><strong>动态数据刷新</strong> DRAM“漏电”电容的电荷消失，需要周期性充电刷新来维持数据的稳定</li><li><strong>内存控制器</strong></li><li>指定芯片、分片、格子的行地址和列地址来访问比特位</li><li><strong>读写单元</strong> 一字节8个比特位</li></ul><h3 id="2-3-多个CPU共同访问内存"><a href="#2-3-多个CPU共同访问内存" class="headerlink" title="2.3 多个CPU共同访问内存"></a>2.3 多个CPU共同访问内存</h3><ul><li>非一致性内存访问NUMA（Non Uniform Memory Access）<ul><li>16核拆分成两个CPU，组成两个NUMA节点Node</li><li>每个节点直接连接一部分内存</li><li><strong>内连接（inter-connect）通道</strong> 两个CPU之间的通道</li><li><strong>本地访问</strong></li><li><strong>远程访问</strong></li><li>远程访问效率高于页面置换，内存不够时优先远程访问</li></ul></li></ul><h3 id="2-4-硬盘"><a href="#2-4-硬盘" class="headerlink" title="2.4 硬盘"></a>2.4 硬盘</h3><ul><li><strong>金属磁粒</strong> 机械硬盘盘面存储数据的东西</li></ul><p><img src="../img/趣话计算机底层技术/0008.png" alt=""></p><ul><li><strong>读磁头</strong> 通过电磁检测磁粒的极性分辨0和1</li><li><strong>写磁头</strong> 通过磁场改变单元格中金属磁粒的极性，设定成0或1</li></ul><p><img src="../img/趣话计算机底层技术/0009.png" alt=""></p><h3 id="2-5-磁盘管理"><a href="#2-5-磁盘管理" class="headerlink" title="2.5 磁盘管理"></a>2.5 磁盘管理</h3><ul><li><strong>块block</strong> 读写的基本单位，把连续的扇区当成一个整体</li><li><strong>块位图</strong> 记录哪些块是空闲的，哪些块是被占用的（记录在第一个块）</li><li><strong>inode</strong> 记录每一个文件的大小、位置、权限、时间等，每一个都是128字节，并且每一个都有一个专属号码在<strong>inode表</strong></li></ul><p><img src="../img/趣话计算机底层技术/0010.png" alt=""></p><ul><li><strong>目录</strong></li><li><strong>根目录</strong></li><li><strong>描述符</strong> 记录inode表、块位图、inode位图的位置信息</li><li><strong>超级块</strong> 记录硬盘总共用了多少块，还剩多少块</li></ul><p><img src="../img/趣话计算机底层技术/0011.png" alt=""></p><ul><li><strong>启动扇区DBR</strong> 装载引导程序</li><li><strong>主引导扇区MBR</strong> 记录所有的分区信息，位于硬盘的第一个扇区</li></ul><p><img src="../img/趣话计算机底层技术/0012.png" alt=""></p><h1 id="第三章-数据的输入与输出"><a href="#第三章-数据的输入与输出" class="headerlink" title="第三章 数据的输入与输出"></a>第三章 数据的输入与输出</h1><h3 id="3-1-总线"><a href="#3-1-总线" class="headerlink" title="3.1 总线"></a>3.1 总线</h3><ul><li><strong>总线</strong> 包含传输数据的数据总线、传输地址的地址总线和进行控制管理的控制总线</li><li><strong>总线控制器</strong> 统一管理总线</li><li><strong>北桥芯片</strong> 集成内存控制器、总线控制器、图像控制器（访问内存和显卡）高速设备</li><li><strong>南桥芯片</strong> 集成各种IO外部设备的控制器（低速设备）</li><li>一条总线 → 多个层级总线组成的总线系统</li><li>NOW CPU集成内存控制器和图像控制器 重新变回一条总线</li></ul><p><img src="../img/趣话计算机底层技术/0013.png" alt=""></p><h3 id="3-2-中断"><a href="#3-2-中断" class="headerlink" title="3.2 中断"></a><strong>3.2 中断</strong></h3><ul><li><strong>eflags寄存器</strong> 存储当前CPU是否可以被中断的值</li><li><strong>不可屏蔽的中断NMI</strong></li><li><strong>可编程中断控制器PIC</strong><ul><li>中断向量</li><li><strong>中断描述符表IDT</strong> 记录处理中断对应的函数地址</li><li><strong>idtr寄存器</strong> 指向中断描述符表IDT的内存地址</li><li><strong>异常处理</strong> 也是这个表，但异常需要立即处理</li><li>异常是同步的，中断是异步的</li></ul></li><li><strong>高级可编程中断控制器APIC</strong><ul><li>IO APIC</li><li>Local APIC</li><li><strong>处理器间中断Inter-Processor Interrupt IPI</strong></li></ul></li><li><strong>中断亲和性</strong></li><li><strong>亲和寄存器</strong></li></ul><h3 id="3-3-计算机启动"><a href="#3-3-计算机启动" class="headerlink" title="3.3 计算机启动"></a>3.3 计算机启动</h3><ul><li><strong>自检工作</strong> 所有寄存器全部重置，如有错误记录到EAX寄存器</li><li><strong>引导处理器BSP</strong></li><li><strong>主引导记录MBR</strong> 512字节，检测最后两个合法字节是0x55和0xAA</li></ul><h3 id="3-4-数据搬运"><a href="#3-4-数据搬运" class="headerlink" title="3.4 数据搬运"></a>3.4 数据搬运</h3><ul><li><strong>可编程输入输出模式PIO</strong> 执行in和out两条指令对外部设备读写数据</li><li><strong>直接存储器访问DMA</strong> 设置寄存器传输哪里的数据，从哪里到哪里，长度是多少</li><li><strong>DMA控制器DMAC</strong></li></ul><h3 id="3-5-零拷贝技术"><a href="#3-5-零拷贝技术" class="headerlink" title="3.5 零拷贝技术"></a>3.5 零拷贝技术</h3><p><img src="../img/趣话计算机底层技术/0014.png" alt=""></p><ul><li>零拷贝技术 把从硬盘读取的数据缓冲区地址和长度给网络socket描述符</li></ul><p><img src="../img/趣话计算机底层技术/0015.png" alt=""></p><h3 id="3-6-网卡"><a href="#3-6-网卡" class="headerlink" title="3.6 网卡"></a>3.6 网卡</h3><ul><li><strong>集线器Hub</strong> 收到的信号做一个增强处理后发送给所有端口</li><li><strong>CSMA/CD 载波侦听多路访问/冲突检测</strong></li><li>以太网帧长度不能低于64字节，这样就算在最远两端发生的碰撞冲突都能及时传递回去被检测到</li></ul><p><img src="../img/趣话计算机底层技术/0016.png" alt=""></p><ul><li><strong>ARP 地址解析协议</strong> 发送目的地址是FF:FF:FE:FF:FF:FF的广播，匹配的发送回去</li><li>ARP欺骗</li><li>网卡的<strong>混杂模式</strong> 把总线的全部数据帧抓取交给CPU处理</li><li><strong>交换机</strong> 记录对应的MAC地址和端口号，精准发送</li><li>全双工通信</li><li>冲突域</li><li><strong>数据帧校验</strong> 对帧检验序列FCS进行循环冗余码校验<strong>CRC</strong></li><li><strong>RX FIFO队列</strong> 网卡内部的接收队列缓冲区</li><li><strong>DMA控制器</strong> 传输网卡的数据</li><li><strong>硬中断</strong> 硬中断需要快速完成</li><li><strong>软中断</strong> 硬中断无法快速完成的调用软中断处理函数进行处理</li><li><strong>NAPI</strong> 数据包过多采用中断＋轮询<ul><li>第一部分 硬中断通知，关中断，但不处理数据包</li><li>第二部分 软中断轮询处理，不需要关中断</li></ul></li><li><strong>Netfilter</strong> Linux内核的一个子系统，允许实现各种与网络相关的操作</li><li><strong>协议栈</strong></li></ul><p><img src="../img/趣话计算机底层技术/0017.png" alt=""></p><h3 id="3-7-直接收发数据包"><a href="#3-7-直接收发数据包" class="headerlink" title="3.7 直接收发数据包"></a>3.7 直接收发数据包</h3><ul><li>每次中断都要保存上下文，从用户态切换到内核态</li><li>线程亲和性 网络监控软件的工作线程独占CPU核心，解决缓存失效问题</li><li><strong>DPDK</strong><ul><li>通过操作系统的用户态模式驱动UIO，在用户态通过轮询的方式读取网卡的数据包</li><li>直接在用户态读取，不用把数据包在内核态空间和用户态空间搬来搬去</li><li>读取后直接分析，不用走系统协议栈和netfilter</li></ul></li></ul><p><img src="../img/趣话计算机底层技术/0018.png" alt=""></p><ul><li>大页内存技术 支持2MB和1GB管理内存页面</li><li><strong>Interrupt DPDK</strong><ul><li>没有数据包处理时就进入睡眠，改为中断通知</li><li>共享CPU核，不独占CPU</li><li>DPDK线程有更高的调度优先级</li><li>数据包多后变轮询模式，灵活切换</li></ul></li></ul><h1 id="第四章-操作系统"><a href="#第四章-操作系统" class="headerlink" title="第四章 操作系统"></a>第四章 操作系统</h1><h3 id="4-1-控制程序"><a href="#4-1-控制程序" class="headerlink" title="4.1 控制程序"></a>4.1 控制程序</h3><ul><li><strong>多道程序处理</strong></li><li><strong>时间分片</strong></li><li><strong>时钟中断</strong></li><li><strong>任务状态</strong><ul><li><strong>创建</strong></li><li><strong>就绪</strong></li><li><strong>执行</strong></li><li><strong>阻塞</strong></li><li><strong>终止</strong></li></ul></li></ul><p><img src="../img/趣话计算机底层技术/0019.png" alt=""></p><ul><li><strong>优先级</strong></li><li><strong>抢占</strong> 高优先级程序出现时，低优先级的程序未完成被剥夺执行机会</li><li><strong>多核时代 → 操作系统</strong></li></ul><h3 id="4-2-进程"><a href="#4-2-进程" class="headerlink" title="4.2 进程"></a>4.2 进程</h3><ul><li>1号进程init</li><li><strong>PID</strong> 进程的身份证</li><li><strong>访问越界</strong></li><li><strong>内核地址空间</strong> 操作系统内核运行的空间</li><li><strong>进程调度</strong></li><li>一个进程里可以同时存在多个执行流，也就是多个线程，每一个线程都有自己的执行上下文和堆栈，互不影响</li><li><strong>线程</strong> 操作系统调度执行的单位</li><li><strong>并发执行</strong> 运行多个不同的线程</li></ul><h3 id="4-3-线程"><a href="#4-3-线程" class="headerlink" title="4.3 线程"></a>4.3 线程</h3><ul><li><strong>完全公平调度算法CFS</strong> 红黑树管理线程</li><li>只要进程的其中一个线程挂掉，所有线程都会被结束掉</li><li><strong>权重</strong> 权重越高的线程越优先被运行</li><li><strong>等待队列</strong></li></ul><h3 id="4-4-系统调用"><a href="#4-4-系统调用" class="headerlink" title="4.4 系统调用"></a>4.4 系统调用</h3><ul><li><strong>内核地址空间</strong> 操作系统内核所在的内存区域</li><li><strong>用户地址空间</strong> 应用程序访问的内存区域</li><li><strong>系统调用表</strong> sys_call_table</li></ul><p><img src="../img/趣话计算机底层技术/0020.png" alt=""></p><ul><li><strong>系统调用</strong> 操作系统将管理文件、内存、进程、线程、网络、硬件等的在内核地址空间操作封装成函数接口方便应用程序调用</li><li><strong>内核栈</strong> 线程有两个栈，一个在用户态地址空间，一个在内核态地址空间，内核栈会小很多</li><li><strong>syscall sysret 一对的</strong></li></ul><h3 id="4-5-异常处理"><a href="#4-5-异常处理" class="headerlink" title="4.5 异常处理"></a>4.5 异常处理</h3><ul><li><strong>中断描述符IDT</strong> 记录所有中断和异常需要处理的地方</li><li><strong>异常</strong> CPU在执行线程的代码指令时出现了错误</li><li>idtr寄存器记录中断描述符IDT</li><li><strong>信号投递</strong></li><li>触发异常时，CPU自动保存的现场（返回地址和一些其他关键寄存器的值）</li><li><strong>iret</strong>(interrept return) 专门用于被中断或异常打断的线程处理完毕后返回用户态地址空间</li></ul><h3 id="4-6-信号处理"><a href="#4-6-信号处理" class="headerlink" title="4.6 信号处理"></a>4.6 信号处理</h3><ul><li><strong>可靠信号和不可靠信号</strong></li><li><strong>进程的描述符task_struct</strong></li><li>进程不能直接调用这些信号处理函数</li></ul><p><img src="../img/趣话计算机底层技术/0021.png" alt=""></p><ul><li>调用<strong>sigprocmask函数</strong>屏蔽信号</li><li><strong>SIGKILL和SIGSTOP无法屏蔽</strong></li><li>一个进程实际就是一个线程组</li><li>task struct中原来的信号等待队列只存放各个线程自己的信号，另外再单独设置一个队列来存放进程的信号，让所有的线程共享</li><li>给线程投递信号（group=0 ）</li><li>给进程投递信号（group=1 ）</li><li>处理信号处理函数的表格是<strong>整个进程共享的</strong></li></ul><h3 id="4-7-锁"><a href="#4-7-锁" class="headerlink" title="4.7 锁"></a>4.7 锁</h3><ul><li><strong>原子操作</strong></li><li><strong>自旋锁</strong> 获取锁的时候线程会一直循环检查状态</li></ul><p><img src="../img/趣话计算机底层技术/0022.png" alt=""></p><ul><li><strong>互斥锁</strong> 获取锁的时候线程进入锁的等待队列，交出CPU执行权限进入睡眠，等待唤醒</li><li><strong>条件变量</strong>  等待条件变量的线程平时阻塞着，别的线程发现条件满足之后，就将条件变量激活</li><li><strong>信号量</strong> 升级版互斥锁，有计数器指定最多允许多少个线程同时获得它</li></ul><h3 id="4-8-Linux的权限管理"><a href="#4-8-Linux的权限管理" class="headerlink" title="4.8 Linux的权限管理"></a>4.8 Linux的权限管理</h3><ul><li><strong>文件打开的过程</strong></li></ul><p><img src="../img/趣话计算机底层技术/0023.png" alt=""></p><ul><li><strong>常规DAC检查</strong> genenric_permission函数</li><li>文件的归属用户id保存在文件索引inode</li><li>进程的用户id保存在进程的task_struct（task_struct-&gt;cred的fsuid）</li><li>Linux操作系统为所有文件针对所属的用户、所属的用户组和其他用户分别设置了访问权限</li><li><strong>读（Read ）、写（Write ）、可执行（Execute ）三种权限</strong></li><li><strong>UGO权限管理方式</strong> 权限信息和文件的归属信息记录在索引信息inode</li><li><strong>ACL访问控制列表</strong> 单独记录一些细粒度的权限信息（校验完进程所属用户和文件所属用户后，就会进入ACL的检查）</li><li><strong>Cgroup检查</strong> 是否有权访问对应的设备</li></ul><h3 id="4-9-Docker"><a href="#4-9-Docker" class="headerlink" title="4.9 Docker"></a>4.9 Docker</h3><ul><li><strong>轻量级的虚拟容器</strong> 只提供一个运行环境，不用运行一个操作系统，所有容器的系统内核与宿主机共用</li><li><strong>chroot和pivot_root</strong> 可以将进程看到的根目录修改为一个新位置（“伪造一个文件系统欺骗容器的进程”）</li><li>操作系统镜像文件和进程依赖的目录和文件通过联合挂载的方式，挂载到容器进程的根目录下，变成容器的rootfs，和真实系统目录一模一样</li><li><strong>命名空间namespace</strong> 划定一个个的命名空间，把进程划分到这些命名空间中，每个命名空间都是独立存在的，命名空间里的进程都无法看到空间之外的进程、用户、网络等信息</li><li><strong>Cgroup</strong> 划定一个个分组，然后限制每个分组能够使用的资源，比如内存的上限值、CPU的使用率、硬盘空间总量等（系统内核会自动检查和限制这些分组中的进程资源使用量）</li></ul><h1 id="第五章-系统编程"><a href="#第五章-系统编程" class="headerlink" title="第五章 系统编程"></a>第五章 系统编程</h1><h3 id="5-1-进程"><a href="#5-1-进程" class="headerlink" title="5.1 进程"></a>5.1 进程</h3><ul><li><strong>Linux 一切皆文件</strong></li><li><strong>fork函数</strong> 创建进程<ul><li>一次调用会返回两次</li><li>父进程返回进程号</li><li>子进程返回0</li><li>子进程和父进程共享内存空间</li></ul></li></ul><p><img src="../img/趣话计算机底层技术/0024.png" alt=""></p><ul><li><strong>写时拷贝（COW）机制</strong> 允许只读，写入会触发异常分配新页面</li><li>fork创建子进程只拷贝当前线程，不拷贝其他线程</li></ul><h3 id="5-2-线程的栈"><a href="#5-2-线程的栈" class="headerlink" title="5.2 线程的栈"></a>5.2 线程的栈</h3><ul><li><strong>后进先出LIFO</strong></li><li><strong>push和pop指令</strong> 压入数据和弹出数据</li><li><strong>call指令</strong> 调用函数（把call指令后面的那条指令地址保存到栈里面,等调用完函数后才能回来继续往后执行）</li><li><strong>ret指令</strong>  函数执行完后用来返回到调用它的地方的指令，CPU在执行ret指令的时候，就会把之前保存在这里的地址取出来，跳转过去</li><li>使用寄存器传参比使用线程栈传参快很多</li><li><code>ulimit -a</code> 查看线程栈的大小</li><li><strong>自动增长</strong> 缺页异常处理时发现是线程栈会分配新内存页面</li><li>但是如果超出上限的话会杀死进程</li><li><strong>内核栈</strong> 页面小（4KB～8KB）小心使用递归调用</li><li><strong>栈溢出攻击</strong> 将栈里保存的返回地址覆盖为恶意代码的地址</li></ul><h3 id="5-3-进程通信"><a href="#5-3-进程通信" class="headerlink" title="5.3 进程通信"></a>5.3 进程通信</h3><ul><li><strong>信号</strong> Linux的一种软中断通信机制，总共64种信号，只能通知不能传输数据</li><li><code>kill -l</code> 查看所有信号</li><li><strong>socket套接字</strong></li><li><strong>127.0.0.1</strong> 本地回环地址，数据在协议栈转发，可以在虚拟的回环网卡lo抓取数字</li></ul><p><img src="../img/趣话计算机底层技术/0025.png" alt=""></p><ul><li><strong>匿名管道</strong> 内核的一段缓冲区，提供读写两个端口，单向</li></ul><p><img src="../img/趣话计算机底层技术/0026.png" alt=""></p><ul><li>消息队列 内核的一个消息链表，可以指定类型</li><li><strong>命名管道</strong> 有名字就不限制进程通道，只要使用名字都可以打开管道通信</li></ul><p><img src="../img/趣话计算机底层技术/0027.png" alt=""></p><ul><li>共享内存</li></ul><h3 id="5-4-IO多路复用"><a href="#5-4-IO多路复用" class="headerlink" title="5.4 IO多路复用"></a>5.4 IO多路复用</h3><ul><li><strong>select函数</strong> 遍历所有文件描述符，挂入相关联设备的等待队列后进入阻塞，如果设备有消息提供回调函数通知Web服务进程</li><li>select使用位图数组，最多同时处理1024个文件描述符</li><li><strong>poll模型</strong> 使用链表存储，可容纳更多文件描述符</li><li><strong>epoll模型</strong><ul><li>采用红黑树管理监听的文件描述符方便查找</li><li>采用双向链表管理队列，不需要遍历所有的文件描述符</li></ul></li></ul><h3 id="5-5-读写文件"><a href="#5-5-读写文件" class="headerlink" title="5.5 读写文件"></a>5.5 读写文件</h3><ul><li><strong>数据结构</strong> 缓存文件数据块信息存到内存</li></ul><p><img src="../img/趣话计算机底层技术/0028.png" alt=""></p><ul><li><strong>fsync函数</strong> 进行同步将缓存写入硬盘</li><li><strong>内存映射文件</strong> 将文件的数据缓存页映射到进程的用户台地址空间</li><li>把整个文件或者文件的一部分直接映射到应用程序的地址空间</li></ul><p><img src="../img/趣话计算机底层技术/0029.png" alt=""></p><h3 id="5-6-协程"><a href="#5-6-协程" class="headerlink" title="5.6 协程"></a>5.6 协程</h3><ul><li>线程可以在执行函数遇到阻塞后，保存执行的上下文，转而执行别处的代码。待阻塞的请求完成后，再回去继续执行</li></ul><p><img src="../img/趣话计算机底层技术/0030.png" alt=""></p><ul><li><strong>协程</strong> 在一个线程中，可以抽象出多个执行流协程，由线程来统一调度管理</li><li>操作系统可以通过<strong>时钟中断</strong>和<strong>系统调用（抢占式调度）</strong>进入内核来剥夺线程的执行权</li><li>Golang 设计为支持协程，封装好系统调用方便协程调度器管理</li></ul><p><img src="../img/趣话计算机底层技术/0031.png" alt=""></p><h3 id="5-7-调试器GDB"><a href="#5-7-调试器GDB" class="headerlink" title="5.7 调试器GDB"></a>5.7 调试器GDB</h3><ul><li>ptrace函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ptrace</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="keyword">enum</span> __ptrace_requeset request, <span class="comment">// 第一个参数是一个枚举型的变量,表示要执行的操作</span></span></span><br><span class="line"><span class="params"><span class="type">pid_t</span> pid,</span></span><br><span class="line"><span class="params"><span class="type">void</span> *addr,</span></span><br><span class="line"><span class="params"><span class="type">void</span> *data</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>break</code> <strong>设置断点</strong><ul><li>把被调试进程中那个位置的指令修改为0xCC</li><li>CPU执行这条特殊的指令会陷入内核态，然后取出中断描述符表IDT的3号表项中的处理函数来执行</li><li>系统内核拿到CPU的执行权，会发送一个SIGTRAP信号给被调试的进程</li><li>GDB截获信号，检查是不是设置的断点，显示断点触发</li><li>在没有下一步指示之前，被调试的进程都不会进入就绪队列被调度执行</li></ul></li><li><strong>单步执行</strong><ul><li><strong>eflags标志寄存器</strong> 包含了程序运行的一些状态和一些工作模式的设定</li><li><strong>TF标记</strong> 告诉CPU进入单步执行模式</li></ul></li><li><strong>内存断点</strong><ul><li><code>watch</code> 监视被调试进程中某个内存地址的数据变化</li><li><strong>调试寄存器</strong> DR0到DR7总共8个，在DRO〜DR3中设置要监控的内存地址，在DR7中设置要监控的模式（读或写）</li></ul></li></ul><h3 id="5-8-可执行文件ELF"><a href="#5-8-可执行文件ELF" class="headerlink" title="5.8 可执行文件ELF"></a>5.8 可执行文件ELF</h3><ul><li><strong>do_execve_commo函数</strong> 启动可执行文件的函数</li><li><strong>prepare_binprm函数</strong> 读取文件头部的128字节数据，放入内存缓冲区</li><li><strong>search_binary_handler函数</strong> 在可执行文件处理节点的链表中寻找处理可执行文件的模块</li><li><strong>load_script函数</strong> 脚本类型程序的加载函数</li><li><strong>程序头表</strong> 结构数组，每一个结构都记录一个段（segment）的信息</li><li><strong>段</strong> 进程地址空间中的一块区域，由一个节（section ）或者多个节构成</li><li><strong>节</strong> 存放ELF文件的数据，比如静态数据、代码指令、调试信息</li></ul><p><img src="../img/趣话计算机底层技术/0032.png" alt=""></p><ul><li>加载过程<ul><li><strong>load_elf_binary函数</strong></li><li>引用动态链接库需要解释器加载</li><li>静态编译则不需要</li><li>检查可执行栈</li><li>加上随机偏移 难以推算数据和函数的内存地址</li></ul></li></ul><h1 id="第六章-计算机攻击与安全"><a href="#第六章-计算机攻击与安全" class="headerlink" title="第六章 计算机攻击与安全"></a>第六章 计算机攻击与安全</h1><h3 id="6-1-TCP序列号"><a href="#6-1-TCP序列号" class="headerlink" title="6.1 TCP序列号"></a>6.1 TCP序列号</h3><p><img src="../img/趣话计算机底层技术/0033.png" alt=""></p><ul><li><strong>中间人攻击</strong> 监听网络通信拿到通信的序列号和确认号，伪造进行通信</li></ul><p><img src="../img/趣话计算机底层技术/0034.png" alt=""></p><ul><li><strong>初始序列号INS</strong> 计数器，每4ms加1（不能直接发送，会被别人算出新的ISN）</li><li><strong>ISN = M + F(localhost, localport, remotehost, remoteport)</strong><ul><li>M 计数器</li><li>F MD5算法</li><li>F参数 通信双方的IP和端口</li></ul></li><li><strong>ISN = M + F(localhost, localport, remotehost, remoteport, secretkey)</strong></li><li>同名计数器 因为CPU为8核防止多个线程之间竞争</li><li><strong>TCP定时器</strong></li><li><strong>TCP计数器</strong> DelayedACKLost</li></ul><h3 id="6-2-TCP-SYN-Flood"><a href="#6-2-TCP-SYN-Flood" class="headerlink" title="6.2 TCP SYN Flood"></a>6.2 TCP SYN Flood</h3><ul><li><strong>SYN洪水攻击</strong> 收到SYN数据包后，需要准备一个数据块来存储客户端的信息，发送大量SYN数据包需要分配大量数据块直到空间耗尽</li><li><strong>SYN Cookie</strong> 第二次发给客户端的序列号是一个哈希值，第三次握手时计算哈<code>希值+1=ACK</code> 为正常数据包，错误数据包直接丢弃</li></ul><p><img src="../img/趣话计算机底层技术/0035.png" alt=""></p><h3 id="6-3-HHTPS"><a href="#6-3-HHTPS" class="headerlink" title="6.3 HHTPS"></a>6.3 HHTPS</h3><ul><li>对称加密</li><li>非对称加密</li><li>非对称与对称加密结合 使用非对称加密算法传输加密内容的密钥</li><li>密钥计算</li></ul><p><img src="../img/趣话计算机底层技术/0036.png" alt=""></p><ul><li><strong>中间人攻击</strong> 冒充服务器和客户端通信，冒充客户端和服务器通信</li><li><strong>数字证书</strong></li><li><strong>根证书</strong> 验证最终的签发者是否在根证书列表中</li></ul><h3 id="6-4-漏洞攻击"><a href="#6-4-漏洞攻击" class="headerlink" title="6.4 漏洞攻击"></a>6.4 漏洞攻击</h3><ul><li><strong>栈金丝雀Stack Canary</strong>  抵御栈溢出攻击</li><li>虚函数攻击 覆盖虚函数表指针，指向一个假的虚函数表，表格写入恶意代码地址</li><li>虚函数表指针一般都是在对象的头部（最前面8个字节）</li><li><strong>KPTI内核页表隔离</strong> 线程运行在用户态和内核态时使用不同的页表</li><li><strong>侧信道</strong> 通过判断内存的访问速度来获知是否有被缓存</li></ul><h3 id="6-5-SGX"><a href="#6-5-SGX" class="headerlink" title="6.5 SGX"></a>6.5 SGX</h3><ul><li><strong>安全访问级别</strong> Ring0-Ring3</li></ul><p><img src="../img/趣话计算机底层技术/0037.png" alt=""></p><ul><li><strong>Enclave安全空间</strong><ul><li><strong>创建</strong> 通过执行ECREATE指令创建一个安全空间</li><li><strong>初始化</strong> 通过执行EINIT指令对安全空间进行初始化</li><li><strong>进入&amp;退出</strong> 通过执行EENTER/EEXIT指令进入和退出安全空间</li><li><strong>中断&amp;异常</strong> 通过执行AEX指令退出，将在安全空间执行的上下文保存起来</li><li><strong>系统调用</strong> 通过执行AEX指令退出，执行完系统调用再进来</li><li><strong>函数调用</strong> 安全空间和外部可以互相调用函数，普通空间调用安全空间函数叫ECALL,安全空间调用外部空间函数叫OCALL</li><li><strong>销毁</strong> 通过执行EREMOVE指令销毁一个安全空间</li></ul></li><li><strong>内存加密</strong>  内存加密引擎MEE(memory encryption engine)电路，对安全空间的数据进行透明的加解密，数据写入内存时加密，读取CPU内部时解密</li></ul><h3 id="6-6-挖矿病毒"><a href="#6-6-挖矿病毒" class="headerlink" title="6.6 挖矿病毒"></a>6.6 挖矿病毒</h3><ul><li><strong>top命令</strong> 常用的实时系统监控工具，提供了一个动态的、交互式的实时视图，显示系统的整体性能信息以及正在运行的进程的相关信息</li><li><strong>ps命令</strong> 显示当前进程的状态</li><li><strong>netstat命令</strong> 打印所有的网络连接信息</li><li><strong>unhide</strong> 网络取证工具，能够发现那些借助 rootkit、LKM 及其它技术隐藏的进程和TCP/UDP 端口</li><li><strong>Redis持久化存储</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET <span class="built_in">dir</span> /root/.ssh <span class="comment"># 指定保存地址</span></span><br><span class="line">CONFIG SET dbfilename authorized_keys <span class="comment"># 指定保存的文件名</span></span><br><span class="line">SAVE <span class="comment"># 将数据保存到文件</span></span><br></pre></td></tr></table></figure><ul><li>原因 Redis默认没有密码，可以使用命令行或直接修改redis.conf文件设置密码</li></ul><h3 id="6-7-整数-1引发的内核攻击"><a href="#6-7-整数-1引发的内核攻击" class="headerlink" title="6.7 整数+1引发的内核攻击"></a>6.7 整数+1引发的内核攻击</h3><ul><li><strong>IDT表项的结构图</strong></li></ul><p><img src="../img/趣话计算机底层技术/0038.png" alt=""></p><ul><li>无符号整数与有符号整数的切换</li></ul><ol><li>精心设计一个config值，从应用层传入内核空间的perf_swevent_init函数</li><li>利用内核漏洞，把一个64位无符号数赋值给一个int型变量，导致变量溢出为一个负数</li><li>禾ij用溢出的event_id越界访问perf_swevent_enabled,指向IDT的表项、将第四项中断处理函数的高32位进行+1 </li><li>修改后的中断处理函数指向了用户空间，提前在此安排恶意代码。</li><li>应用层执行int 4汇编指令，触发4号中断，线程将进入内核空间，以内检权限执行提前安排的恶意代码</li></ol><h3 id="6-8-从虚拟机逃脱"><a href="#6-8-从虚拟机逃脱" class="headerlink" title="6.8 从虚拟机逃脱"></a>6.8 从虚拟机逃脱</h3><ul><li>虚拟化技术</li><li>硬件辅助虚拟化 操作系统和程序的指令都是在真实的CPU上执行的，不再用软件来解释模拟</li><li>虚拟机监控程序HyperVisor</li><li><strong>虚拟机逃逸技术</strong> 虚拟机会和外面的真实计算机通信，抓住通信过程中的漏洞，把指令代码掺杂在通信数据中可以逃逸出去</li></ul><p><img src="../img/趣话计算机底层技术/0039.png" alt=""></p><ul><li><strong>漏洞编号CVE</strong> Common Vulnerabilities and Exposures 显示年份和具体漏洞编号</li></ul>]]></content>
    
    
    <summary type="html">Interesting story Underlying computer technology</summary>
    
    
    
    <category term="编程学习" scheme="https://agoni66.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机" scheme="https://agoni66.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>活着</title>
    <link href="https://agoni66.github.io/posts/1000010.html"/>
    <id>https://agoni66.github.io/posts/1000010.html</id>
    <published>2024-10-30T17:00:00.000Z</published>
    <updated>2024-10-31T15:40:58.766Z</updated>
    
    <content type="html"><![CDATA[<div class="note danger flat"><p><strong>“活着”在我们中国的语言里充满了力量，它的力量不是来自于喊叫，也不是来自于进攻，而是忍受，去忍受生命赋予我们的责任，去忍受现实给予我们的幸福和苦难、无聊和平庸</strong></p></div><ul><li>当我望着到处都充满绿色的土地时，我就进一步明白庄稼为何长得如此旺盛</li><li>两个垂暮的生命将那块古板的田地耕得哗哗翻动，犹如水面上掀起的波浪</li><li>做人呵，一旦嫖上以后，也就免不了要去赌。这个嫖和赌，就像是胳膊和肩膀连在一起，怎么都分不开</li><li>女人看上去各不相同，到下面都是一样的</li><li>男人都是馋嘴的猫🐈</li><li>做人不能忘记四条，话不要说错，床不要睡错，门槛不要踏错，口袋不要摸错</li></ul><hr><ul><li>第一章 福贵赌没全家爹掉了</li><li>第二章 家珍被老丈人接回家</li><li>第三章 进城请郎中被送上战场</li><li>第四章 回到家乡，凤霞聋哑，娘掉了，送子上学，送女又回来</li><li>第五章 人民公社化运动和大炼钢 家珍软骨病</li><li>第六章 有庆因抽血掉了</li><li>第七章 凤霞嫁掉</li><li>第八章 文革时期 春生上吊</li><li>第九章 凤霞生娃大出血掉了 家珍隔三个月掉了</li><li>第十章 二喜掉了 故事结束了</li></ul>]]></content>
    
    
    <summary type="html">活着</summary>
    
    
    
    <category term="读书笔记" scheme="https://agoni66.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="活着" scheme="https://agoni66.github.io/tags/%E6%B4%BB%E7%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>抱住棒棒的自己</title>
    <link href="https://agoni66.github.io/posts/1000009.html"/>
    <id>https://agoni66.github.io/posts/1000009.html</id>
    <published>2024-10-24T15:00:00.000Z</published>
    <updated>2024-10-24T11:17:54.111Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p><strong>不久前的综艺你也是这样抱抱棒棒的haewon小白熊，这就是缘分吧</strong></p></div><h3 id="情绪"><a href="#情绪" class="headerlink" title="情绪"></a>情绪</h3><div class="note default simple"><p>我们有意识地压抑消极情绪、自我批判，只会让情绪更加强化</p></div><div class="note primary simple"><p>自我批判的人更容易认输放弃</p></div><div class="note success simple"><p>改变分第一序列和第二序列。问题，是第一序列；而应对问题的方式，是第二序列</p></div><div class="note info simple"><p>比起和问题硬碰硬，有什么不躲避、更容易接纳的应对方式</p></div><div class="note warning simple"><p>用一种怜悯的心态，理解和照顾情绪</p></div><div class="note danger simple"><p>每个人都是解决自己问题的唯一人选</p></div><div class="note default simple"><p>遇到困难，回过头看看，自己曾经做了什么，怎么做的</p></div><div class="note primary simple"><p>唯有心流带来的快乐，是自己塑造所得，对个人意识的拓展于成长才有助益</p></div><div class="note success simple"><p>当沉浸到某个事物里面时，我们不仅能感受到愉悦、成就感，还能和自己好好相处，对内在的感受也会有更深刻的认识</p></div><div class="note info simple"><p>改变就好像多米诺骨牌，最重要的是找到第一个小小的改变，再一个接一个地推动</p></div><div class="note warning simple"><p>人生不是一条线，是一连串的刹那（连续的向上螺旋线也不错）</p></div><div class="note danger simple"><p>人生不如意十有八九，但就算是这样的人生，也会有闪闪发亮的东西</p></div><div class="note default simple"><p>拼命守护自己珍视的东西，谁敢碰我的最后一块奶油蛋糕，我怎么能不跟他们玩命？</p></div><div class="note primary simple"><p>别忘了，漆黑的夜，你的星星口袋发着光</p></div><div class="note success simple"><p>我们讲述的故事，揭示了我们自己，构建了我们自己，在人生的旅途中支撑着我们</p></div><h3 id="自我成长"><a href="#自我成长" class="headerlink" title="自我成长"></a>自我成长</h3><div class="note info simple"><p>个体为了回避自己的不佳表现所带来的负面影响，可能会采取一些行为，增大将失败原因外化的机会</p></div><div class="note warning simple"><p>失败，歧视没有那么可怕，它只是人生千百万种体验的一种</p></div><div class="note danger simple"><p>当我们不再把“失败”和“我很差劲”紧密捆绑在一起时，或许会发掘出自己未知的潜能</p></div><div class="note default simple"><p>停下自我指责，问问自己：我期待自己变成什么样子</p></div><div class="note primary simple"><p>终其一生，我们不会因为“保持正确”而被爱，我们只会因为我是我而被喜欢</p></div><div class="note success simple"><p>少一点向外界标准寻求答案，多一点向内心问问自己的想法</p></div><div class="note info simple"><p>我到底应该怎么做才能变得更好？其实你可以带着问题生活</p></div><div class="note warning simple"><p><strong>自律不是约束自己，而是提升自己，表现为更爱自己</strong></p></div><div class="note danger simple"><p>自律，是一种怀揣着变好的期待、主动施行的、更健康的生活方式</p></div><h3 id="亲密关系"><a href="#亲密关系" class="headerlink" title="亲密关系"></a>亲密关系</h3><div class="note default simple"><p>亲密关系中，更多的自我决定，会带来更少的负面情绪和更多的积极行为，提升关系的整体幸福感</p></div><div class="note primary simple"><p>坚持发出自己的声音，坚持优先看见、尊重和照顾自己的感受</p></div><div class="note success simple"><p>舒服的关系可以留下，不舒服的关系可以尝试沟通和解决，但没必要勉强和委屈自己去苦苦维持</p></div><div class="note info simple"><p>应该思维：头脑中已有一套规则，试图让全世界和他人都按照这套规则运转（对应控制欲）</p></div><h3 id="亲子关系"><a href="#亲子关系" class="headerlink" title="亲子关系"></a>亲子关系</h3><div class="note warning simple"><p>没有回应的话，家也是绝境</p></div><div class="note danger simple"><p>父母：我不想强制你，我给你自由；但我又希望你跟我一条心，自觉地如我所愿</p></div><div class="note default simple"><p>在理解孩子，也在理解自己的基础上，父母和孩子才能真诚地沟通，满足彼此的需求</p></div><div class="note primary simple"><p>在一段两人关系里，当他们无法处理问题和矛盾时，会很自然地利用第三方，来缓解双方的情绪冲击</p></div><div class="note success simple"><p>敏感是一种性格特点，不是什么需要修正的毛病。对于养育者来说，接纳、适应、顺其自然就是最好的办法</p></div>]]></content>
    
    
    <summary type="html">haewon欧尼，你是最棒的</summary>
    
    
    
    <category term="读书笔记" scheme="https://agoni66.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="温情" scheme="https://agoni66.github.io/tags/%E6%B8%A9%E6%83%85/"/>
    
    <category term="漫画" scheme="https://agoni66.github.io/tags/%E6%BC%AB%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>你也走了很远的路吧</title>
    <link href="https://agoni66.github.io/posts/1000008.html"/>
    <id>https://agoni66.github.io/posts/1000008.html</id>
    <published>2024-10-22T15:00:00.000Z</published>
    <updated>2024-10-22T14:48:29.793Z</updated>
    
    <content type="html"><![CDATA[<div class="tip warning faa-horizontal animated-hover"><p>你要忍，忍到春暖花开；你要走，走到灯火通明；你要看过世界辽阔，再评判是好是坏</p></div><div class="tip warning faa-horizontal animated-hover"><p>我们不停告别，又不停重新出发，有些话还来不及讲，就已经分道扬镳</p></div><div class="tip warning faa-horizontal animated-hover"><p>只有在最深的夜里，你才能够允许自己难过</p></div><div class="tip warning faa-horizontal animated-hover"><p>孤独是，某天突然下雨，你走在街上，只有你一个人没有带伞；加班到深夜的你饥饿难耐，却发现周边所有便利店都关门；期待很多年的电影今天上映，怎么也找不到人陪你去看；深夜想要找一个人聊天，翻遍通讯录却找不到人说话。走过了那么远的路，再也找不到人分享风景</p></div><div class="tip warning faa-horizontal animated-hover"><p>我们成长，我们遗忘，我们弄丢回忆，我们无能为力。可日升日落，潮退潮涨，永远有前路，等待前行的人。</p></div><div class="tip warning faa-horizontal animated-hover"><p>我的所有坚持，都是因为热爱。没办法三分钟热度，做不到对自己敷衍</p></div><div class="tip warning faa-horizontal animated-hover"><p>我张开了手，却只能抱住风</p></div><div class="tip warning faa-horizontal animated-hover"><p>当你很喜欢一个人的时候，你会希望他能参与你的生活，你会希望你的所有情绪他都能有回应</p></div><div class="tip warning faa-horizontal animated-hover"><p>告别就是看到所有美好的东西，也不会再和你说了</p></div><div class="tip warning faa-horizontal animated-hover"><p>生活的本质就是这样，希望和失望共存，美好与丑恶共生。而我们能做的，是从失望中看到希望</p></div><div class="tip warning faa-horizontal animated-hover"><p>那时的我自然不明白，生活的本质就是这样，希望和失望共存，美好与丑恶共生。有多少好的，就有多少坏的，付出从来不等于回报，不公平就是生活本身。而我们能做的，是从失望中看到希望。真正的乐观，不是因为没见过世界的黑暗，恰恰是因为见过之后，才懂得生活的珍贵</p></div><div class="tip warning faa-horizontal animated-hover"><p>永远年轻，永远热泪盈眶</p></div><div class="tip warning faa-horizontal animated-hover"><p>我的朋友就这么多，不多不少，每一个都很重要，每一个都要幸福。一个都不能少</p></div><div class="tip warning faa-horizontal animated-hover"><p>友情更像是一种不需要常常惦记，但都保持着关心，不需要时常保持联系，但聊起天来感觉时间就像没走，不需要陪伴在身边，但有困难时可以第一时间到你身边的感情</p></div><div class="tip warning faa-horizontal animated-hover"><p>我早就不是那个相信友谊天长地久的少年，也知道这世上更多的是分道扬镳</p></div><div class="tip warning faa-horizontal animated-hover"><p>因为半山腰总是最挤的，你得到山顶看看</p></div><div class="tip warning faa-horizontal animated-hover"><p>让你难过的事情太多了，你只是想要调整好自己给别人一个好状态，可有人偏僻抓住你的痛脚，说你是没心没肺</p></div><div class="tip warning faa-horizontal animated-hover"><p>你想要去得地方你真的在认真打算，可有人偏偏要冷嘲热讽</p></div><div class="tip warning faa-horizontal animated-hover"><p>你的所有成绩所有努力无法得到认可，当然不甘心</p></div><div class="tip warning faa-horizontal animated-hover"><p>可我怕你久而久之习惯了，你开始怀疑真诚，你开始怀疑热血，你开始怀疑努力，你开始怀疑所有美好的意义</p></div><div class="tip warning faa-horizontal animated-hover"><p>是因为我们都太了解自己了，了解自己内心那团火一直燃着，带着你一路披荆斩棘，去一个你必须要去的地方</p></div><div class="tip warning faa-horizontal animated-hover"><p>去喜欢一个让你有动力的人吧，每天起来都觉得阳光万里</p></div><div class="tip warning faa-horizontal animated-hover"><p>要每天过得充实，不管别人是否认同，也不管他们是否在意，这世上有那么多人，余生还长，总有人懂得欣赏</p></div><div class="tip warning faa-horizontal animated-hover"><p>还有爬起来的力气，就不要让自己躺在地上太久。路的尽头不见得跟想象中一样，但你得走过去看看</p></div><div class="tip warning faa-horizontal animated-hover"><p>我们都不是为了别人准备的，我们是为了自己准备的</p></div><div class="tip warning faa-horizontal animated-hover"><p>我们有自己要走的路，要去的地方，陪伴在身旁的，是跟我们同行的那一个</p></div><div class="tip warning faa-horizontal animated-hover"><p>其实不是的，人变老不是从心开始的，是从你觉得累开始的。一次力不从心，两次力不从心，于是你的心也跟着放弃了。世上那么多放弃，其实都是一句“我累了”</p></div><div class="tip warning faa-horizontal animated-hover"><p>因为生活还是那样，它只是静静地在这儿看着你，等着你走出改变的第一步。那么，你有没有改变的勇气？</p></div><div class="tip warning faa-horizontal animated-hover"><p>不要改变你的热血，你的真诚，你的努力。亲爱的，成长不是变得面目全非，而是保留住重要的东西奋力前行</p></div><div class="tip warning faa-horizontal animated-hover"><p>如果自由的代价是孤独，那便接受它。因为你还有两件事可以做：变优秀，和等那个人出现</p></div><div class="tip warning faa-horizontal animated-hover"><p>如果没有时差就好了，我喜欢你的时候，你恰好喜欢我</p></div><div class="tip warning faa-horizontal animated-hover"><p>我们寻找过去的味道、气味，我们再走过那些街道、风景，只不过为了心里的执念。执念的事做完了，想不通的也就过去了</p></div><div class="tip warning faa-horizontal animated-hover"><p>他用尽全部力气安慰她，却没有办法说那句，我喜欢你。喜欢是一种多么贵重的东西，贵重到所有人面对自己喜欢的人，都说不出口</p></div><div class="tip warning faa-horizontal animated-hover"><p>人们想要的从来不是真相。他们只要绘声绘色，他们只要故事好听</p></div><div class="tip warning faa-horizontal animated-hover"><p>都说两个人相处，只有两种可能性，要么成为朋友，要么成为恋人</p></div><div class="tip warning faa-horizontal animated-hover"><p>我们的心事都像一封永远不会寄出去的信，写的是寻人启事，却没有收件人</p></div><div class="tip warning faa-horizontal animated-hover"><p>“有些人觉得爱就是性，是婚姻，是清晨六点的吻和一堆孩子，或许爱就是这样，莱斯特小姐，但你知道我怎么想吗？我觉得爱是想要触碰却又收回手”</p></div><div class="tip warning faa-horizontal animated-hover"><p>你不知道在什么时候，你也成为过别人的力量</p></div><div class="tip warning faa-horizontal animated-hover"><p>冷漠毫无成本，显得善良多么脆弱</p></div><div class="tip warning faa-horizontal animated-hover"><p>等天亮，等释怀，等安慰，等晴天，这世上几乎人人都在等</p></div><div class="tip warning faa-horizontal animated-hover"><p>有些事大可一个人做，只是我们缺少一个人做的勇气</p></div><div class="tip warning faa-horizontal animated-hover"><p>而等待也没什么难过的，如果你等的是日出，那它早晚会来；如果你等一个你也说不好什么时候会来的人和事，也没什么可怕，至少你可以边等边做自己喜欢的事。如果你知道你等的永远也不会来，那你会学会死心的。至于偶尔冒上心头的想念，就想念吧</p></div><div class="tip warning faa-horizontal animated-hover"><p>我不信成为别人喜欢的样子，我只想成为我自己</p></div>]]></content>
    
    
    <summary type="html">抱抱自己吧，谁不是宝宝呢</summary>
    
    
    
    <category term="读书笔记" scheme="https://agoni66.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="人文" scheme="https://agoni66.github.io/tags/%E4%BA%BA%E6%96%87/"/>
    
    <category term="温情" scheme="https://agoni66.github.io/tags/%E6%B8%A9%E6%83%85/"/>
    
    <category term="热学" scheme="https://agoni66.github.io/tags/%E7%83%AD%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>闪闪发光的人生</title>
    <link href="https://agoni66.github.io/posts/1000007.html"/>
    <id>https://agoni66.github.io/posts/1000007.html</id>
    <published>2024-09-12T08:00:00.000Z</published>
    <updated>2024-09-12T15:17:32.757Z</updated>
    
    <content type="html"><![CDATA[<h3 id="艾草团子🍡"><a href="#艾草团子🍡" class="headerlink" title="艾草团子🍡"></a>艾草团子🍡</h3><div class="tip home"><p>这种喜悦，就好像气泡酒中的泡泡一样，从我的胸腔中一涌而上，化作泪水溢出</p></div><div class="tip home"><p>气泡果汁里真的装了许多时令水果，就像只豪华的宝石盒子</p></div><div class="tip home"><p>她那么柔软、那么温暖，又散发着淡淡的甘甜气味，就好像刚出锅的寿甘团子</p></div><div class="tip home"><p>在土锅里煮上红豆，又在旁边的小炉子里用滚水焯艾草叶。眼见着滚水染上深深的绿色，仿佛把春天都凝聚在一锅之中。舒爽的香味弥漫开来，就好像置身于森林中</p></div><div class="tip home"><p>艾草团子厚墩墩的，呈现出复杂的风味——强劲且带着大地气息</p></div><h3 id="意式冰淇淋🍦"><a href="#意式冰淇淋🍦" class="headerlink" title="意式冰淇淋🍦"></a>意式冰淇淋🍦</h3><div class="tip home"><p>生命也是一样，一旦死去，就再也无法恢复原状</p></div><div class="tip home"><p>也许走上不同的人生路才是最好的</p></div><div class="tip home"><p>只要闭上眼睛，在心中默念“闪闪发光，闪闪发光”，心灵的晦暗之处就会出现星星，照亮四周</p></div><h3 id="珠芽饭🌱"><a href="#珠芽饭🌱" class="headerlink" title="珠芽饭🌱"></a>珠芽饭🌱</h3><div class="tip home"><p>寄居蟹小姐心中所萌生的好感，就如同植物从大地中抽出枝芽一样，毫不虚伪。自然不会说谎，也不会欺骗自己，会坦率地生，坦率地死</p></div><div class="tip home"><p>我们两个都是背着重壳行走的人，我们的天空也不总是那么晴朗，而我已经被你的温柔拯救了不知多少次</p></div><div class="tip home"><p>与其去追求已经失去的东西，不如好好珍惜现在掌心中拥有的东西</p></div><h3 id="蜂斗菜味噌"><a href="#蜂斗菜味噌" class="headerlink" title="蜂斗菜味噌"></a>蜂斗菜味噌</h3>]]></content>
    
    
    <summary type="html">闪闪发光 日本妻子</summary>
    
    
    
    <category term="读书笔记" scheme="https://agoni66.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="文学" scheme="https://agoni66.github.io/tags/%E6%96%87%E5%AD%A6/"/>
    
    <category term="日文" scheme="https://agoni66.github.io/tags/%E6%97%A5%E6%96%87/"/>
    
    <category term="烂尾" scheme="https://agoni66.github.io/tags/%E7%83%82%E5%B0%BE/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter10 Storage and File Structure</title>
    <link href="https://agoni66.github.io/posts/1000115.html"/>
    <id>https://agoni66.github.io/posts/1000115.html</id>
    <published>2024-08-04T09:30:00.000Z</published>
    <updated>2024-10-05T02:09:16.531Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><p><font size="4"><b>数据库系统概念导航🚀🚀🚀</b></font></p><ol><li><p>🐻‍❄️<a href="https://agoni66.github.io/posts/1000111.html">Chapter1 Introduction</a></p></li><li><p>🦝<a href="https://agoni66.github.io/posts/1000112.html">Chapter2 Introduction to Relational Model</a></p></li><li><p>🐯<a href="https://agoni66.github.io/posts/1000113.html">Chapter3 Introduction to SQL</a></p></li><li><p>🐱<a href="https://agoni66.github.io/posts/1000114.html">Chapter4 Intermediate SQL</a></p></li><li><p>🐷<a href="https://agoni66.github.io/posts/1000116.html">Chapter6 Formal Relational Query Languages</a></p></li><li><p>🐼<a href="https://agoni66.github.io/posts/1000117.html">Chapter7 Entity-Relationship Model</a> </p></li><li><p>🐨<a href="https://agoni66.github.io/posts/1000118.html">Chapter8 Relational Database Design</a></p></li><li><p>🐻<a href="https://agoni66.github.io/posts/1000115.html">Chapter10 Storage and File Structure</a> ⇦ 当前位置🪂</p></li></ol></div><h3 id="物理存储介质概述"><a href="#物理存储介质概述" class="headerlink" title="物理存储介质概述"></a>物理存储介质概述</h3><ul><li>高速缓冲存储器</li><li>主存储器</li><li>快闪存储器 电源关闭也可以保存数据</li><li>磁盘存储器</li><li>光学存储器</li><li>磁带存储器</li></ul><p><img src="../img/数据库系统概念/2.png" alt="2.png"></p><ul><li>基本存储 最快的存储介质（cache和主存）</li><li>辅助存储 基本存储的下一层介质</li><li>三级存储or脱机存储 最底层的介质</li><li>易失性存储 设备断电后将丢失所有内容</li><li>非易失性存储 设备断电后将不会丢失所有内容</li></ul><h3 id="磁盘和快闪存储器"><a href="#磁盘和快闪存储器" class="headerlink" title="磁盘和快闪存储器"></a>磁盘和快闪存储器</h3><p><img src="../img/数据库系统概念/3.png" alt="Untitled"></p><ul><li><strong>磁盘的物理特性</strong><ul><li>盘片</li><li>磁道</li><li>扇区 磁道写入和读出信息的最小单位</li><li>读写头 将信息磁化存储到扇区中</li><li>磁盘臂 所有读写头安装在上面一起移动</li><li>柱面 所有盘片的第几条磁道</li><li>磁盘控制器 计算机系统和实际的磁盘驱动器硬件之间的接口</li><li>坏扇区的重映射</li><li>存储区域网</li><li>独立磁盘冗余阵列</li><li>网络附加存储NAS</li></ul></li><li><strong>磁盘性能的度量</strong><ul><li>访问时间</li><li>寻道时间 平均寻道时间</li><li>旋转等待时间</li><li>数据传输率</li><li>平均故障时间</li></ul></li><li><strong>磁盘块访问的优化</strong><ul><li>虚拟地址≈快号</li><li>一个块是一个逻辑单元，包含固定数目的连续扇区</li><li>顺序访问</li><li>随机访问</li><li>缓冲(buffering)：从磁盘读取的块暂时存储在内存缓冲区</li><li>预读(read-ahead)：当一个磁盘块被访问时，相同磁道的连续块也读入内存缓冲区</li><li>调度(scheduling)：电梯算法</li><li>文件组织(file organization)</li><li>非易失性写缓冲区(nonvolatile write buffer)</li><li>日志磁盘：用于写顺序日志的磁盘，可以减少写等待时间</li></ul></li><li><strong>快闪存储</strong><ul><li>NOR快闪 允许随机访问内存中的单个字</li><li>NAND快闪 需要将整个数据页读取到主存储器</li><li>NAND快闪便宜，存储容量高，使用更广泛</li><li>闪存的写入：不能直接覆盖，先擦除再重写，擦除块</li><li>转换表：逻辑到物理的页面映射存储到内存的转换表</li><li>损耗均衡：在物理块中均匀分布擦除操作的原则，因为物理页可能擦除过多而损坏</li><li>混合硬盘驱动器：结合了小容量闪存存储器的硬盘系统</li></ul></li><li><p><strong>RAID</strong></p><ul><li>目的：存储需求增长，为了提高性能和可靠性，易于管理和操作</li><li>独立磁盘冗余阵列</li><li>冗余<ul><li>存储正常情况下不需要的额外信息，这些信息可用于故障时重建恢复</li><li>镜像：复制每一张磁盘</li></ul></li><li>并行<ul><li>数据拆分：提高传输速率的手段</li><li>比特级拆分：每个字节按比特分开，存储到多个磁盘上</li><li>块级拆分：将块拆分到多个磁盘上</li></ul></li><li>RAID级别</li></ul></li><li><p><img src="../img/数据库系统概念/4.png" alt="Untitled"></p><ul><li>RAID级别的选择<ul><li>所需的额外磁盘存储带来的花费</li><li>在I/O操作数量方面的性能需求</li><li>磁盘故障时的性能</li><li>数据重建过程中的性能</li></ul></li><li>软件RAID：不改变硬件层 只修改软件的RAID</li><li>硬件RAID：具有硬件支持的RAID</li></ul></li></ul><h3 id="第三级存储"><a href="#第三级存储" class="headerlink" title="第三级存储"></a>第三级存储</h3><ul><li>光盘</li><li>磁带<ul><li>数字音频磁带DAT：几个GB</li><li>字线性磁带DLT：10~40GB</li><li>Ultrium：100GB</li><li>Amp螺旋扫描磁带：330GB</li><li>数据传输率在每秒几到几十MB</li><li>自动磁带机：存放大量磁道，并有少量可用于安装磁带的动器</li></ul></li></ul><h3 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h3><ul><li>一个文件在逻辑上组织成为记录的一个序列</li><li>块：每个文件分成定长的存储单元，是存储分配和数据传输的基本单位</li><li>文件头：分配有一定数量的字节，包含有关文件的各种信息</li><li>定长记录<ul><li>假设记录大小是固定的。</li><li>每个文件只包含一种特定类型的记录。</li><li>不同的文件用于不同的关系</li><li>用空闲链表来存储空余空间</li></ul></li><li>变长记录<ul><li>插槽页头(Slotted page header)包含以下内容：<ul><li>记录条目的数量</li><li>块中空闲空间的结束位置</li><li>每个记录的位置和大小</li></ul></li><li>可以在页面内部移动记录，以保持它们的连续性，中间没有空白空间；页头中的条目必须更新</li><li>指针不应直接指向记录，而应指向页头中记录对应的条目</li></ul></li><li>文件的记录组织<ul><li>堆文件组织：一条记录可以放在文件中的有空间的任何地方（记录无顺序）</li><li>顺序文件组织：记录根据其搜索码的值顺序存储<ul><li>搜索码是任何一个属性或者属性的集合</li><li>重组：使记录在物流上顺序存放</li></ul></li><li>散列文件组织<ul><li>多表聚簇文件组织：在每一块中存储两个或者更多个关系的相关记录的文件结构</li></ul></li></ul></li></ul><h3 id="数据字典存储"><a href="#数据字典存储" class="headerlink" title="数据字典存储"></a>数据字典存储</h3><ul><li>元数据：关于数据的数据</li><li>数据字典：存储关系的关系模式和其他元数据</li><li>系统必须存储的信息类型<ul><li>关系的名字</li><li>每个关系中属性的名字</li><li>属性的域和长度</li><li>在数据库上定义的视图的名字和定义</li><li>完整性约束</li></ul></li></ul><h3 id="数据库缓冲区"><a href="#数据库缓冲区" class="headerlink" title="数据库缓冲区"></a>数据库缓冲区</h3><ul><li>缓冲区：主存储器中用于存储磁盘块拷贝的部分</li><li>缓冲区管理器：负责缓冲区空间分配的子系统<ul><li>为了使数据库系统能够从系统崩溃中恢复，限制一个块写回磁盘的时间是必要的</li><li>被钉住的块：不允许写回磁盘的块</li><li>块的强制写出</li></ul></li><li>缓冲区替换策略<ul><li>最近最少使用LRU</li><li>最近最常使用MRU</li></ul></li></ul>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter10 Storage and File Structure</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter8 Relational Database Design</title>
    <link href="https://agoni66.github.io/posts/1000118.html"/>
    <id>https://agoni66.github.io/posts/1000118.html</id>
    <published>2024-08-03T14:30:00.000Z</published>
    <updated>2024-10-05T02:09:18.642Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><p><font size="4"><b>数据库系统概念导航🚀🚀🚀</b></font></p><ol><li><p>🐻‍❄️<a href="https://agoni66.github.io/posts/1000111.html">Chapter1 Introduction</a></p></li><li><p>🦝<a href="https://agoni66.github.io/posts/1000112.html">Chapter2 Introduction to Relational Model</a></p></li><li><p>🐯<a href="https://agoni66.github.io/posts/1000113.html">Chapter3 Introduction to SQL</a></p></li><li><p>🐱<a href="https://agoni66.github.io/posts/1000114.html">Chapter4 Intermediate SQL</a></p></li><li><p>🐷<a href="https://agoni66.github.io/posts/1000116.html">Chapter6 Formal Relational Query Languages</a></p></li><li><p>🐼<a href="https://agoni66.github.io/posts/1000117.html">Chapter7 Entity-Relationship Model</a> </p></li><li><p>🐨<a href="https://agoni66.github.io/posts/1000118.html">Chapter8 Relational Database Design</a> ⇦ 当前位置🪂</p></li><li><p>🐻<a href="https://agoni66.github.io/posts/1000115.html">Chapter10 Storage and File Structure</a></p></li></ol></div><h3 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h3><p>如果分解后无法重建原始信息，那么就是有损分解(Lossy Decomposition)，反之则为无损分解(Lossless-Join Decomposition)</p><blockquote><p>好的分解要做到无损分解和依赖保存</p><p>BCNF 分解可以保证无损，3NF 可以保证依赖保存，但是 3NF 无法保证没有冗余，因此需要在 BCNF 和 3NF 间权衡</p></blockquote><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><ul><li>如果一个域的元素都是不可分的单位，这个域是<strong>原子的</strong></li><li>一个关系模式R的所有属性的域都是原子的，这个关系模式属于<strong>第一范式(First Normal Form, 1NF)</strong></li><li>原子性实际上是与域的元素如何使用相关的属性，就是说我们怎么看待这个属性</li></ul><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><ul><li>函数依赖是对合法关系集合的约束条件</li><li>要求某个属性集合的值唯一确定另一个属性集合的值</li><li>定义为：$A\rightarrow B$<ul><li>$A$是模式$(A,B)$的超码</li><li>属性$A$的取值决定$B$的取值</li></ul></li><li>平凡函数依赖：$A\subseteq B$</li><li>完全函数依赖：$A$的任意真子集都推不出$B$</li><li>部分函数依赖：$A$的任意一个真子集可以推出$B$</li><li>非主码都完全函数依赖于主码的，这个关系模式属于<strong>第二范式(Second Normal Form, 2NF)</strong></li></ul><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><ul><li>闭包<ul><li>$F^{+}$表示所有能从函数依赖$F$中推出的函数依赖闭包</li><li>如果两个函数依赖集的闭包相等，那么我们就说这两个函数依赖集是等价的</li><li>性质<ul><li>自反性</li><li>扩充性</li><li>传递性</li></ul></li><li>附加规则<ul><li>并集规则</li><li>分解规则</li><li>伪传递规则</li></ul></li></ul></li><li>$A\rightarrow B~and~B\rightarrow C\Rightarrow A\rightarrow C$ 成为传递依赖</li><li>没有传递依赖的第二范式，这个关系模式属于<strong>第三范式(Third Normal Form, 3NF)</strong></li></ul><h3 id="BCNF范式"><a href="#BCNF范式" class="headerlink" title="BCNF范式"></a>BCNF范式</h3><ul><li>要验证一个属性$x$对于给定的$Ax\rightarrow B$是否冗余，如果$A\rightarrow B$成立，$x$就是冗余的</li><li>关系模式 $R$ 在 BCNF（Boyce-Codd 范式）中，如果对于$R$中的存在的所有函数依赖关系$F$，形式为$A\rightarrow B$，其中$A\subseteq R$且$B\subseteq R$，至少满足以下条件之一<ul><li>$A\subseteq B$</li><li>$A$是$R$的超键</li></ul></li><li>检查BCNF<ul><li>计算函数依赖的闭包$A^{+}$</li><li>验证是否满足$R\subseteq A^{+}$</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><div class="note info no-icon flat"><p>🧡 <strong>范式之间的关系：</strong><br>第一范式(1NF)<br>非码的非平凡<br>↓ 消除非主属性对码的部分函数依赖<br>第二范式(2NF)<br>↓ 消除非主属性对码的传递函数依赖<br>第三范式(3NF)<br>↓ 消除主属性对码的部分和传递函数依赖<br>BC 范式(BCNF)<br>↓ 消除非平凡且非函数依赖的多值依赖<br>第四范式(4NF)<br>↓ 消除不是由候选码所蕴含的连接依赖<br>第五范式(5NF)</p></div>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter8 Relational Database Design</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter7 Entity-Relationship Model</title>
    <link href="https://agoni66.github.io/posts/1000117.html"/>
    <id>https://agoni66.github.io/posts/1000117.html</id>
    <published>2024-08-02T14:30:00.000Z</published>
    <updated>2024-10-05T02:09:20.776Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><p><font size="4"><b>数据库系统概念导航🚀🚀🚀</b></font></p><ol><li><p>🐻‍❄️<a href="https://agoni66.github.io/posts/1000111.html">Chapter1 Introduction</a></p></li><li><p>🦝<a href="https://agoni66.github.io/posts/1000112.html">Chapter2 Introduction to Relational Model</a></p></li><li><p>🐯<a href="https://agoni66.github.io/posts/1000113.html">Chapter3 Introduction to SQL</a></p></li><li><p>🐱<a href="https://agoni66.github.io/posts/1000114.html">Chapter4 Intermediate SQL</a></p></li><li><p>🐷<a href="https://agoni66.github.io/posts/1000116.html">Chapter6 Formal Relational Query Languages</a></p></li><li><p>🐼<a href="https://agoni66.github.io/posts/1000117.html">Chapter7 Entity-Relationship Model</a> ⇦ 当前位置🪂</p></li><li><p>🐨<a href="https://agoni66.github.io/posts/1000118.html">Chapter8 Relational Database Design</a></p></li><li><p>🐻<a href="https://agoni66.github.io/posts/1000115.html">Chapter10 Storage and File Structure</a></p></li></ol></div><h3 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h3><p><strong>实体</strong> 是现实世界中可区别于所有其他对象的一个事务，例如大学中的每个人</p><p><strong>实体集</strong> 是相同类型即具有相同属性的一个实体集合，例如大学中的所有人</p><p><strong>属性</strong> 每个实体的每个属性都有一个值</p><p><strong>联系</strong> 是指多个实体间的相互关联</p><p><strong>联系集</strong> 是相同类型联系的集合，是n≥2个实体集上的数学关系</p><p><strong>参与</strong> 实体集之间的关联，实体集$E_1,E_2,…,E_n$参与联系集$R$</p><p><strong>度</strong> 参与联系集的实体集的数目</p><p><strong>域</strong> 每个属性的可取值的集合</p><h3 id="属性分类"><a href="#属性分类" class="headerlink" title="属性分类"></a>属性分类</h3><ul><li>简单和复合<ul><li>简单不能划分为更小饿部分</li><li>复合比如说姓名可以划分为姓和名</li></ul></li><li>单值和多值</li><li>派生 这类属性的值可以从相关属性得出</li></ul><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p><strong>映射基数</strong> 标识一个实体通过联系集能关联的实体的个数</p><ul><li>一对一</li><li>一对多</li><li>多对一</li><li>多对多</li></ul><p><strong>参与约束</strong></p><ul><li>全部 实体集E对的每个实体都参与到联系集R的至少一个联系</li><li>部分 实体集E只有部分实体参与到联系集R的联系</li></ul><p><strong>码</strong> 唯一标识该实体</p><p><strong>基线约束</strong></p><p>→ 箭头指向 <strong><code>一</code></strong></p><p>— 横线指向 <strong><code>多</code></strong></p><blockquote><p>对于三元（或更高度）关系，我们最多允许从关系中有一个箭头出去，以表示基数约束</p></blockquote><h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h3><ul><li><strong>矩形</strong>表示实体集<ul><li>复合属性跟在简单属性下面，统一缩进格式</li></ul></li><li>菱形表示关系集</li><li><strong>实体矩形</strong>内列出属性</li><li><strong>下划线</strong>表示主键属性</li><li>非二次的联系集用多条线连接</li><li><strong>弱实体集</strong> 没有主码的实体集</li><li><strong>强实体集</strong> 有主码的实体集</li><li>弱实体集必须与<strong>标识实体集</strong>关联</li></ul><h3 id="关系模式的转化"><a href="#关系模式的转化" class="headerlink" title="关系模式的转化"></a>关系模式的转化</h3><ul><li>E-R图转化为一些关系模式的集合</li><li>强实体集：$(A_1,A_2,…,A_n)$，其中$A_1,A_2,…,A_n$是实体集内的属性</li><li>弱实体集：$(A_1,A_2,…,A_n,p)$，其中$A_1,A_2,…,A_n$是实体集内的属性,$p$是识别强实体集的主码</li><li>联系集：参与的所有实体集的主码的集合 + 自己的属性<ul><li>多对多 双方主码的并集为联系集的主码</li><li>一对多 多的主码为联系集的主码</li><li>一对一 任意的都可以</li></ul></li></ul><h3 id="设计问题"><a href="#设计问题" class="headerlink" title="设计问题"></a>设计问题</h3><span class='p blue'>用实体集还是用属性？</span><ul><li>用实体集比较灵活，可存储额外信息</li></ul><span class='p blue'>用实体集还是用联系集？</span><ul><li>不好说，更多的是用联系集表示实体之间的操作</li></ul><span class='p blue'>用二元关系集还是用n元关系集？</span><ul><li>可以用多个二元关系集表示n元关系集，但n元关系集清楚一些</li></ul><h3 id="扩展的E-R特性"><a href="#扩展的E-R特性" class="headerlink" title="扩展的E-R特性"></a>扩展的E-R特性</h3><p><strong>特化</strong></p><ul><li>自顶向下的设计过程</li><li>在实体集内部进行分组的过程，比如说person实体集分为employee和student</li></ul><p><strong>概化</strong></p><ul><li>自底向上的设计过程</li><li>将共享相同特征的多个实体集合并为一个较高层的实体集</li></ul><p>高层和低层实体集也称为<strong>超类</strong>（superclass）和<strong>子类</strong>（subclass）</p><p><strong>属性继承</strong></p><ul><li>高层实体集的属性被低层实体集继承</li><li>高层实体集所关联的所有属性和联系适用于它的所有低层实体集</li><li>低层实体集特有的性质仅适用于特定的低层实体集</li></ul><p><strong>概化上的约束</strong></p><ul><li>条件定义的</li><li>用户定义的</li><li>不相交：一个实体至多属于一个低层实体集</li><li>重叠：一个实体可以属于多个较低级别实体集</li><li>完全性约束<ul><li>全部概化或特化： 每次高层实体必须属于一个低层实体集</li><li>部分概化或特化：允许一些高层实体不属于任何低层实体集</li></ul></li></ul><p><strong>聚集</strong></p><p>使联系化为高层实体，并且可以参与联系</p><ul><li>将关系视为抽象实体</li><li>允许关系之间的关系</li><li>将关系抽象成新的实体，避免引入冗余</li></ul><p><strong>转为关系模式</strong></p><ul><li>方法一<ul><li>为高级实体形成一个模式</li><li>为每个低级实体集形成一个模式，包括上层实体集的主键和局部属性</li><li>缺点：获取有关员工的信息需要访问两个关系，即对应于低级别模式和高级别模式的关系</li></ul></li><li>方法二<ul><li>为每个实体集构建模式，包括所有本地和继承的属性</li><li>缺点：可能会冗余存储</li></ul></li></ul><h3 id="统一建模语言UML"><a href="#统一建模语言UML" class="headerlink" title="统一建模语言UML"></a>统一建模语言UML</h3><ul><li>类图：与E-R图类似</li><li>用况图：说明用户与系统之间的交互</li><li>活动图：说明系统不同部分之间的任务流</li><li>实现图：在软硬件说明系统的各组成部分以及它们之间的联系</li><li>关联：类比联系集</li></ul><h3 id="数据库设计的其他方面"><a href="#数据库设计的其他方面" class="headerlink" title="数据库设计的其他方面"></a>数据库设计的其他方面</h3><ul><li>数据约束：自动的一致性保持</li><li>使用需求：查询、性能：吞吐量和响应时间</li><li>授权需求</li><li>数据流、工作流</li></ul>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter7 Entity-Relationship Model</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter6 Formal Relational Query Languages</title>
    <link href="https://agoni66.github.io/posts/1000116.html"/>
    <id>https://agoni66.github.io/posts/1000116.html</id>
    <published>2024-08-01T14:30:00.000Z</published>
    <updated>2024-10-05T02:09:24.210Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><p><font size="4"><b>数据库系统概念导航🚀🚀🚀</b></font></p><ol><li><p>🐻‍❄️<a href="https://agoni66.github.io/posts/1000111.html">Chapter1 Introduction</a> </p></li><li><p>🦝<a href="https://agoni66.github.io/posts/1000112.html">Chapter2 Introduction to Relational Model</a></p></li><li><p>🐯<a href="https://agoni66.github.io/posts/1000113.html">Chapter3 Introduction to SQL</a></p></li><li><p>🐱<a href="https://agoni66.github.io/posts/1000114.html">Chapter4 Intermediate SQL</a></p></li><li><p>🐷<a href="https://agoni66.github.io/posts/1000116.html">Chapter6 Formal Relational Query Languages</a> ⇦ 当前位置🪂</p></li><li><p>🐼<a href="https://agoni66.github.io/posts/1000117.html">Chapter7 Entity-Relationship Model</a> </p></li><li><p>🐨<a href="https://agoni66.github.io/posts/1000118.html">Chapter8 Relational Database Design</a></p></li><li><p>🐻<a href="https://agoni66.github.io/posts/1000115.html">Chapter10 Storage and File Structure</a></p></li></ol></div><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><p>关系代数是一种过程化查询语言</p><p>一元运算：对一个关系进行运算</p><p>二元运算：对两个关系进行运算</p><ul><li>选择 σ  $\sigma _{p}\left( R\right)$$$\sigma _{p}\left( r\right) =\left\{  t~| t\in r~and~p\left( t\right) \right\}$$</li><li>投影 π  <script type="math/tex; mode=display">\prod a_{1},\ldots ,a_{n}\left( R\right)</script></li><li>笛卡尔积 x$$r\times s= \{ t,q~| t\in r~and~q\in s\}$$</li><li>自然连接 ⋈</li><li>重命名 ρ<ul><li>$\rho _{x}\left( R\right)$ 表示把关系R重命名为x</li><li>$P<em>{x\left( A_1\ldots ,A</em>{n}\right) }\left( R\right)$</li></ul></li><li>集合差 -$$r\cup S=\left\{  t~| t\in r ~or~ t\in s\right\}$$</li><li>集合交 ∩$$r\cap  S=\left\{  t~| t\in r ~and~ t\in s\right\}$$</li></ul>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter6 Formal Relational Query Languages</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter4 Intermediate SQL</title>
    <link href="https://agoni66.github.io/posts/1000114.html"/>
    <id>https://agoni66.github.io/posts/1000114.html</id>
    <published>2024-07-31T14:30:00.000Z</published>
    <updated>2024-10-03T07:01:13.454Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><p><font size="4"><b>数据库系统概念导航🚀🚀🚀</b></font></p><ol><li><p>🐻‍❄️<a href="https://agoni66.github.io/posts/1000111.html">Chapter1 Introduction</a></p></li><li><p>🦝<a href="https://agoni66.github.io/posts/1000112.html">Chapter2 Introduction to Relational Model</a></p></li><li><p>🐯<a href="https://agoni66.github.io/posts/1000113.html">Chapter3 Introduction to SQL</a></p></li><li><p>🐱<a href="https://agoni66.github.io/posts/1000114.html">Chapter4 Intermediate SQL</a> ⇦ 当前位置🪂</p></li><li><p>🐷<a href="https://agoni66.github.io/posts/1000116.html">Chapter6 Formal Relational Query Languages</a></p></li><li><p>🐼<a href="https://agoni66.github.io/posts/1000117.html">Chapter7 Entity-Relationship Model</a> </p></li><li><p>🐨<a href="https://agoni66.github.io/posts/1000118.html">Chapter8 Relational Database Design</a></p></li><li><p>🐻<a href="https://agoni66.github.io/posts/1000115.html">Chapter10 Storage and File Structure</a></p></li></ol></div><h3 id="连接条件"><a href="#连接条件" class="headerlink" title="连接条件"></a>连接条件</h3><p><code>on</code></p><p>在on语句后写具体的条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">join</span> takes <span class="keyword">on</span> student.ID <span class="operator">=</span> takes.ID;</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student,takes <span class="keyword">where</span> student.ID <span class="operator">=</span> takes.ID;</span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>外连接运算与自然连接运算类似，只不过通过在结果中创建空值的方式，保留了在连接中丢失的元组</p><ul><li>左外连接：left outer join，只保留左边这张表的元组</li><li>右外连接：right outer join，只保留右边那张表的元组</li><li>全外连接：full outer join，保留出现在关系中全部的元组</li><li>内连接：inner join，不保留未匹配元组</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">natural</span> <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> takes;</span><br></pre></td></tr></table></figure><p><strong>左外连接和右外连接是对称的</strong></p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>创建视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_name <span class="keyword">as</span> (查询表达式)</span><br></pre></td></tr></table></figure><p>例如，需要访问instructor关系中除salary之外的所有数据的职员</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> faculty <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> ID, name, dept_name</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><p><strong>一般不允许对视图关系进行修改</strong></p><p>视图更新可能存在问题，比如在插入数据时，如果视图的属性列少于基本表，那么可能会出现以下两种情况</p><ol><li>拒绝插入</li><li>向基本表中插入元组，未赋值的属性值为null</li></ol><p>删除视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> view_name</span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务(transaction)由查询语句(select)和更新语句(update)的序列组成</p><ul><li>commit work：提交当前事务，将事务所做的更新在数据库中长久保存</li><li>rollback work：回滚当前事务，撤销该事务中所有SQL语句对数据库的更新</li></ul><p>一旦事务执行了commit work，就不能通过rollback work撤销了</p><p>一个较好的选择是，允许多条SQL语句包含在关键字<code>begin atomic……end</code>之间，这些SQL语句构成单一事务</p><h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><ul><li>主码约束</li><li>not null</li><li>unique</li><li>check</li><li>参照完整性</li></ul><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p><code>default</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> s</span><br><span class="line">(</span><br><span class="line">sex <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">sno <span class="type">char</span>(<span class="number">5</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="create-table-的拓展"><a href="#create-table-的拓展" class="headerlink" title="create table 的拓展"></a>create table 的拓展</h3><p>创建与现有表的模式相同的表</p><p>例如，创建一个与instructor具有相同模式的新表temp_instructor</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> temp_instructor <span class="keyword">like</span> instructor;</span><br></pre></td></tr></table></figure><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>SQL标准包括<code>select</code> <code>insert</code> <code>update</code> <code>delete</code> </p><p><code>grant</code>语句用来授予权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 表级权限 <span class="keyword">on</span> 关系名或视图名 <span class="keyword">to</span> 用户<span class="operator">/</span>角色列表</span><br></pre></td></tr></table></figure><p>例如，授予数据库用户Amit和Satoshi在department关系上的select权限，授予数据库用户Amit和Satoshi在department关系的budget属性上的update权限，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> department <span class="keyword">to</span> Amit,Satoshi;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">update</span>(budget) <span class="keyword">on</span> department <span class="keyword">to</span> Amit,Satoshi;</span><br></pre></td></tr></table></figure><p><code>revoke</code>语句用来收回权限</p><p>例如，收回授予数据库用户Amit和Satoshi在department关系上的select权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> student <span class="keyword">to</span> Amit,Satoshi;</span><br></pre></td></tr></table></figure><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>在数据库中建立角色集，并授予每个角色一定的权限，然后将角色分配给用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> role instructor;</span><br></pre></td></tr></table></figure><p>角色可以授予给用户，也可以授予给其他角色</p>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter4 Intermediate SQL</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter3 Introduction to SQL</title>
    <link href="https://agoni66.github.io/posts/1000113.html"/>
    <id>https://agoni66.github.io/posts/1000113.html</id>
    <published>2024-07-30T14:30:00.000Z</published>
    <updated>2024-10-03T07:00:57.309Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><p><font size="4"><b>数据库系统概念导航🚀🚀🚀</b></font></p><ol><li><p>🐻‍❄️<a href="https://agoni66.github.io/posts/1000111.html">Chapter1 Introduction</a> </p></li><li><p>🦝<a href="https://agoni66.github.io/posts/1000112.html">Chapter2 Introduction to Relational Model</a></p></li><li><p>🐯<a href="https://agoni66.github.io/posts/1000113.html">Chapter3 Introduction to SQL</a> ⇦ 当前位置🪂</p></li><li><p>🐱<a href="https://agoni66.github.io/posts/1000114.html">Chapter4 Intermediate SQL</a></p></li><li><p>🐷<a href="https://agoni66.github.io/posts/1000116.html">Chapter6 Formal Relational Query Languages</a></p></li><li><p>🐼<a href="https://agoni66.github.io/posts/1000117.html">Chapter7 Entity-Relationship Model</a> </p></li><li><p>🐨<a href="https://agoni66.github.io/posts/1000118.html">Chapter8 Relational Database Design</a></p></li><li><p>🐻<a href="https://agoni66.github.io/posts/1000115.html">Chapter10 Storage and File Structure</a></p></li></ol></div><h3 id="SQL-数据定义语言（-data-definition-language-DDL）"><a href="#SQL-数据定义语言（-data-definition-language-DDL）" class="headerlink" title="SQL 数据定义语言（ data-definition language ,DDL）"></a>SQL 数据定义语言（ data-definition language ,DDL）</h3><ul><li>每个关系的模式</li><li>每个属性关联的值域</li><li>完整性约束</li><li>每个关系要维护的索引集合</li><li>每个关系的安全性和授权信息</li><li>每个关系在磁盘上的物理存储结构</li></ul><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><div class="table-container"><table><thead><tr><th>语法</th><th>语义</th></tr></thead><tbody><tr><td>char(n)</td><td>指定长度n的字符串</td></tr><tr><td>varchar(n)</td><td>最大长度n的字符串</td></tr><tr><td>int</td><td>整形</td></tr><tr><td>smallint</td><td>小整数</td></tr><tr><td>float(n)</td><td>精度至少是n位浮点数</td></tr><tr><td>numeric(p,d)</td><td>定点数，p长度、d精度</td></tr></tbody></table></div><p>每种类型都可能包含一个空值</p><h3 id="基本模式定义"><a href="#基本模式定义" class="headerlink" title="基本模式定义"></a>基本模式定义</h3><p><strong>创建</strong></p><p>创建一个department关系</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department(</span><br><span class="line">dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">building <span class="type">varchar</span>(<span class="number">15</span>),</span><br><span class="line">budget <span class="type">numeric</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">primary</span> key(dept_name));</span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><p>插入一个名叫Smith的生物教师，其id为10211，工资为6000</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> instructor <span class="keyword">values</span>(</span><br><span class="line"><span class="number">10211</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;Biology&#x27;</span>, <span class="number">6000</span>);</span><br></pre></td></tr></table></figure><p><strong>更新</strong></p><p>所有教师的工资将增长5%</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><p>删除元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><p>删除关系</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> r;</span><br></pre></td></tr></table></figure><p><strong>增加</strong></p><p>为关系增加/删除属性 A属性名 D属性的域</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> r <span class="keyword">add</span> A D;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> r <span class="keyword">delete</span> A;</span><br></pre></td></tr></table></figure><h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><ul><li>primary key( ) 主码属性必须非空且唯一</li><li>foreign key( ) references table 外码约束</li><li>not null 不允许空值</li></ul><h3 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h3><p><code>select</code> <code>from</code> <code>where</code></p><ul><li>单关系查询</li><li>多关系查询</li><li>自然连接 <code>natural join</code></li><li>更名运算<code>as</code></li><li>字符串运算<ul><li><code>like</code></li><li><code>%</code> 任意匹配多个字符</li><li><code>_</code> 任意匹配一个字符</li><li><code>\</code> 转义字符</li></ul></li><li><code>*</code> 所有的属性</li><li>次序<ul><li><code>order by</code></li><li><code>desc</code> 降序</li><li><code>asc</code> 升序</li></ul></li><li>集合运算<ul><li>union 并运算 自动去重（不想就union all）</li><li>intersect 交运算 自动去重（不想就intersect all）</li><li>except 差运算</li></ul></li><li>聚集函数<ul><li><code>avg</code> 平均值</li><li><code>min</code> 最小值</li><li><code>max</code> 最大值</li><li><code>sum</code> 总和</li><li><code>count</code> 计数</li></ul></li><li>分组聚集<code>group by</code><ul><li>group by子句中所有属性相同的元组将分为一个组</li></ul></li><li>having子句<ul><li>聚集函数后只能使用having子句</li><li>having子句应用在group by子句上</li></ul></li><li>嵌套子查询<ul><li>至少比某一个大 <code>&gt;some</code></li><li>至少比某一个小 <code>&lt;some</code></li><li><code>=some</code> 就是 <code>in</code></li><li>比所有都大 <code>&gt;all</code></li><li>比所有都小 <code>&lt;all</code></li><li><code>unique</code> 没有重复元素返回true</li><li><code>exists</code> 子查询非空返回true</li></ul></li></ul>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter3 Introduction to SQL</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter2 Introduction to Relational Model</title>
    <link href="https://agoni66.github.io/posts/1000112.html"/>
    <id>https://agoni66.github.io/posts/1000112.html</id>
    <published>2024-07-30T10:30:00.000Z</published>
    <updated>2024-10-03T07:00:49.047Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><p><font size="4"><b>数据库系统概念导航🚀🚀🚀</b></font></p><ol><li><p>🐻‍❄️<a href="https://agoni66.github.io/posts/1000111.html">Chapter1 Introduction</a> </p></li><li><p>🦝<a href="https://agoni66.github.io/posts/1000112.html">Chapter2 Introduction to Relational Model</a> ⇦ 当前位置🪂</p></li><li><p>🐯<a href="https://agoni66.github.io/posts/1000113.html">Chapter3 Introduction to SQL</a></p></li><li><p>🐱<a href="https://agoni66.github.io/posts/1000114.html">Chapter4 Intermediate SQL</a></p></li><li><p>🐷<a href="https://agoni66.github.io/posts/1000116.html">Chapter6 Formal Relational Query Languages</a></p></li><li><p>🐼<a href="https://agoni66.github.io/posts/1000117.html">Chapter7 Entity-Relationship Model</a> </p></li><li><p>🐨<a href="https://agoni66.github.io/posts/1000118.html">Chapter8 Relational Database Design</a></p></li><li><p>🐻<a href="https://agoni66.github.io/posts/1000115.html">Chapter10 Storage and File Structure</a></p></li></ol></div><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>实体</li><li>弱实体：没有主码的实体，对应支配实体</li><li>实体集：实体集里面的实体属性一样 $E_1…E_n$</li><li>域：属性的所有可能值的集合</li><li>联系</li><li>联系集 $$R=\left\{  \left( e_{1}\ldots e_{n}\right) | e_{1}\in E_{1},e_{n}\in E_{n}\right\} $$</li><li>实体 联系都有属性</li><li>关系是无序的</li></ul><h3 id="约束constraint"><a href="#约束constraint" class="headerlink" title="约束constraint"></a>约束constraint</h3><ul><li>关键约束（粗线箭头） 只能是一个</li><li>参与约束<ul><li>完全参与（粗线） 至少一个</li><li>部分参与</li></ul></li></ul><h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p>一个关系中没有两个元组在所有属性中的取值都相同</p><ul><li>超码：一个或多个属性的集合，这些属性足以在一个关系中唯一标识元组</li><li>候选码：最小超码</li><li>主码</li><li>外码：另一个关系的主码被参照</li></ul><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><ul><li>选择——行</li><li>投影——列</li><li>连接</li><li>自然连接</li><li>笛卡尔积</li><li>集合运算<ul><li>交 ∩</li><li>并 ∪</li><li>差 -</li></ul></li></ul>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter2 Introduction to Relational Model</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>DATABASE SYSTEM CONCEPTS-Chapter1 Introduction</title>
    <link href="https://agoni66.github.io/posts/1000111.html"/>
    <id>https://agoni66.github.io/posts/1000111.html</id>
    <published>2024-07-30T02:30:00.000Z</published>
    <updated>2024-10-05T02:09:32.084Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><p><font size="4"><b>数据库系统概念导航🚀🚀🚀</b></font></p><ol><li><p>🐻‍❄️<a href="https://agoni66.github.io/posts/1000111.html">Chapter1 Introduction</a> ⇦ 当前位置🪂</p></li><li><p>🦝<a href="https://agoni66.github.io/posts/1000112.html">Chapter2 Introduction to Relational Model</a></p></li><li><p>🐯<a href="https://agoni66.github.io/posts/1000113.html">Chapter3 Introduction to SQL</a></p></li><li><p>🐱<a href="https://agoni66.github.io/posts/1000114.html">Chapter4 Intermediate SQL</a></p></li><li><p>🐷<a href="https://agoni66.github.io/posts/1000116.html">Chapter6 Formal Relational Query Languages</a></p></li><li><p>🐼<a href="https://agoni66.github.io/posts/1000117.html">Chapter7 Entity-Relationship Model</a> </p></li><li><p>🐨<a href="https://agoni66.github.io/posts/1000118.html">Chapter8 Relational Database Design</a></p></li><li><p>🐻<a href="https://agoni66.github.io/posts/1000115.html">Chapter10 Storage and File Structure</a></p></li></ol></div><h3 id="什么是DBMS？"><a href="#什么是DBMS？" class="headerlink" title="什么是DBMS？"></a>什么是DBMS？</h3><p>数据库是数据的存储、维护一个非常大的集成的数据</p><p>数据库是对现实世界的建模（实体entities 关系）</p><p>数据库管理系统DBMS是存储和管理数据库的软件包</p><h3 id="文件系统和DBMS的对比"><a href="#文件系统和DBMS的对比" class="headerlink" title="文件系统和DBMS的对比"></a>文件系统和DBMS的对比</h3><p>文件系统：应用程序访问的单个文件的集合</p><p>DBMS：用电脑处理的用于记录保存的系统</p><p>文件系统的缺点：</p><ul><li>数据冗余和不一致：多种文件格式，不同文件中的信息重复</li><li>访问数据困难：需要编写新程序来执行每项新任务</li><li>数据孤立</li><li>完整性问题</li><li>原子性问题</li><li>并发访问异常</li><li>安全性问题</li></ul><p>DBMS的优点：</p><ul><li>独立性</li><li>检索 selcet 查询 query</li><li>完整性约束</li><li>安全性（权限、访问控制）</li><li>方便管理和使用</li><li>并发访问</li><li>恢复崩溃</li><li>减少应用开发时间</li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合</p><ul><li>关系模型 (第二章)<ul><li>关系relation，就是由列和行组成的表格</li><li>每个关系都有模式 schema</li><li>模式就是一个实体的模版</li><li>记录record：行</li><li>属性attribute：列</li></ul></li><li>实体-关系数据模型（主要用于数据库设计）</li><li>基于对象的数据模型（面向对象和对象关系）</li><li>半结构化数据模型 (XML)</li><li>其他旧模型：<ul><li>网络模型</li><li>层次模型</li></ul></li></ul><h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><ul><li>外模式（视图） external schema</li><li>概念模式（逻辑模式） conceptual schema</li><li>物理模式（内模式） physical schema</li></ul><p>原因：数据独立性 data independence = 逻辑独立性 + 物理独立性</p><h3 id="DBMS的查询queries"><a href="#DBMS的查询queries" class="headerlink" title="DBMS的查询queries"></a>DBMS的查询queries</h3><ul><li>关系代数和关系演算</li><li>structural query language（SQL）</li><li>数据操作语言DML<ul><li>过程化DML：要求用户指定需要什么数据以及如何获得这些数据</li><li>声明化DML：只要求用户指定需要什么数据</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> instructor.dept_name <span class="operator">=</span> <span class="string">&#x27;History&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>数据定义语言DDL</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> instructor (</span><br><span class="line">ID             <span class="type">char</span>(<span class="number">5</span>),</span><br><span class="line">name           <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">dept_name      <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">salary         <span class="type">numeric</span>(<span class="number">8</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>数据库设计分为 <strong>6 个阶段</strong>：</p><ol><li><strong>需求分析</strong><ol><li>调查机构情况与熟悉业务活动，明确用户的需求，确定系统的边界，生成数据字典和用户需求规格说明书</li><li>搜集资料</li><li>分析整理</li><li>数据流图</li><li>数据字典</li><li>用户确认</li></ol></li><li><p><strong>概念结构设计</strong></p><p> 将需求分析得到的用户需求抽象为概念模型，绘制E-R图</p></li><li><p><strong>逻辑结构设计</strong></p><p> 将E-R图转换为与 DBMS相符合的逻辑结构（包括数据库模式和外模式），例如E-R图向关系模型转换，再根据规范化理论对数据模型进行优化，设计用户子模式</p></li><li><p><strong>物理结构设计</strong></p><p> 通常关系数据库物理设计的内容包括关系模式选择存取方法、以及设计关系、索引等数据库文件的物理存储结构</p></li><li><p><strong>数据库实施</strong></p><p> 建立实际数据库结构、试运行、装入数据</p></li><li><p><strong>数据库运行和维护</strong></p><p> 维护数据库的安全性、完整性控制以及系统的转储和恢复；性能的监督、分析和改进；增加新功能；发现错误和修改错误</p></li></ol><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ol><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ol><p>ACID properties</p><h3 id="DBMS结构"><a href="#DBMS结构" class="headerlink" title="DBMS结构"></a>DBMS结构</h3><ul><li>数据库管理系统</li><li>查询评估引擎<ul><li>分析器</li><li>优化器</li><li>操作器</li><li>操作评估器</li></ul></li><li>CPU</li><li>缓存管理器</li><li>磁盘空间管理器</li><li>并发控制<ul><li>事务管理器</li><li>锁管理器</li></ul></li><li>恢复管理器</li></ul><p><img src="../img/数据库系统概念/1.png" alt="Untitled"></p><hr><h3 id="SQL语句执行流程"><a href="#SQL语句执行流程" class="headerlink" title="SQL语句执行流程"></a><strong>SQL语句执行流程</strong></h3><p><img src="../img/数据库系统概念/2.webp" alt="Untitled"></p><p>MySQL 可以分为 Server 层和存储引擎层两部分</p><ol><li><p><strong>连接器</strong></p><p> <code>mysql -h10.10.0.18 -p3306 -uroot -p</code></p><p> 主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作</p></li><li><p><strong>查询缓存（已经移除）</strong></p><p> 查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集</p><p> 执行查询语句时，看看有没有查询过，有则返回之前结果（以 Key-Value 的形式缓存在内存中），没有则继续查询。<strong>当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</strong></p></li><li><p><strong>分析器</strong></p><p> 分析器主要是用来分析 SQL 语句是来干嘛的</p><p> 第一步，词法分析</p><p> 第二步，语法分析</p><p> <strong>然后报错</strong></p></li><li><p><strong>优化器</strong></p><p> 去选择最优的执行方案</p></li><li><p><strong>执行器</strong></p><p> 首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误</p></li></ol>]]></content>
    
    
    <summary type="html">DATABASE SYSTEM CONCEPTS-Chapter1 Introduction</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="数据库" scheme="https://agoni66.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>算法图解</title>
    <link href="https://agoni66.github.io/posts/1000200.html"/>
    <id>https://agoni66.github.io/posts/1000200.html</id>
    <published>2024-06-07T06:30:00.000Z</published>
    <updated>2024-06-07T06:36:12.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul><li><p>最多查找 $\log_{2}n$ 次</p></li><li><p>时间复杂度：$O(\log n)$</p></li><li><p>有序</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params"><span class="built_in">list</span>, item</span>):</span><br><span class="line">low = <span class="number">0</span></span><br><span class="line">high = <span class="built_in">len</span>(<span class="built_in">list</span>) - <span class="number">1</span> </span><br><span class="line"><span class="keyword">while</span> low &lt;= high: </span><br><span class="line">mid =(low + high)</span><br><span class="line">guess = <span class="built_in">list</span>[mid]</span><br><span class="line"><span class="keyword">if</span> guess == item:</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line"><span class="comment"># mid 如果不是，就从 mid 前后继续查找</span></span><br><span class="line"><span class="keyword">if</span> quess &gt; item: </span><br><span class="line">high = mid - <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h3><p>有一位旅行者需要前往 n 个城市，同时确保旅程最短（计算每种顺序及其总旅程）</p><p>$ O(n!) $</p><p><br/></p><hr><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h2><p>需要将数据存储到内存时，我需要请求将数据提供存储地址，计算机会给我一个存储地址，我再把数据放里面</p><p><strong>数组</strong></p><ul><li><p>需要连续的存储空间，如果不满足，无法添加数据，则复制（移动）到另一个满足的连续空间</p></li><li><p>解决方法：预留空间，会浪费内存</p></li><li><p>支持随机访问和顺序访问</p></li></ul><p><strong>链表</strong></p><ul><li><p>每个元素都存储下一个元素的地址</p></li><li><p>修改和删除简单，只需修改一两个元素指向的地址</p></li><li><p>缺点：最后一个元素不能直接读取</p></li><li><p>只能顺序访问（从第一个元素开始逐个读取元素）</p></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li><p>选择单一指标进行排序</p></li><li><p>每次遍历一遍 选一个出来</p></li><li><p>时间复杂度：$ O（n^2） $</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findSmallest</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt;<span class="built_in">int</span>:</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">定义一个找出数组中最小数的函数，返回其索引</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">smallest = arr[<span class="number">0</span>]</span><br><span class="line">smallest_index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line"><span class="keyword">if</span> arr[i] &lt; smallest:</span><br><span class="line">smallest = arr[i]</span><br><span class="line">smallest_index = i</span><br><span class="line"><span class="keyword">return</span> smallest_index</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">selectionSort</span>(<span class="params">arr</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">选择排序</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">newarr = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">smallest_index = findSmallest(arr)</span><br><span class="line">smallest = arr.pop(smallest_index)</span><br><span class="line"><span class="comment"># 使用内置函数实现</span></span><br><span class="line"><span class="comment"># smallest = min(arr)</span></span><br><span class="line"><span class="comment"># app.remove(smallest)</span></span><br><span class="line">newarr.append(smallest)</span><br><span class="line"><span class="keyword">return</span> newarr</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3.递归"></a>3.递归</h2><blockquote><p>请手写递归逻辑</p></blockquote><p>编写递归函数，必须注意何时停止递归</p><ul><li><p>递归条件：函数调用自己</p></li><li><p>基线条件：函数不再调用自己</p></li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li><p>操作</p><ul><li><p>压入</p></li><li><p>弹出</p></li></ul></li><li><p>调用栈(call stack)</p></li><li><p>函数与栈</p><ul><li><p>函数就是栈</p></li><li><p>哪个函数在栈顶就执行哪个函数</p></li><li><p>调用另一个函数时，当前函数暂停并处于未完成状态</p></li><li><p><strong>调用函数——压栈</strong></p></li><li><p><strong>return——出栈</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0001.jpeg" style="width:78%;height:78%;"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0002.jpeg" style="width:78%;height:78%;"/></div></div></li></ul></li></ul><hr><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="分而治之（divide-and-conquer-D-amp-C）"><a href="#分而治之（divide-and-conquer-D-amp-C）" class="headerlink" title="分而治之（divide and conquer, D&amp;C）"></a>分而治之（divide and conquer, D&amp;C）</h3><ul><li>步骤<ul><li>找出<strong>基线条件</strong></li><li>不断将问题分解（缩小规模），直到符合基线条件</li></ul></li><li><p>例子：sum函数</p><p>  <img src="../img/算法/0003.png" alt="Untitled"></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_arr</span>(<span class="params">arr</span>):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">number = arr.pop()</span><br><span class="line"><span class="keyword">return</span> number + sum_arr(arr)</span><br></pre></td></tr></table></figure></li><li><p>提示：涉及数组的递归函数，基线条件一般是数组为空或只有一个元素</p></li><li>提示：python数组是可变的，传进函数的是数组本身</li></ul><h3 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li>基线条件：数组为空或只包含一个元素</li><li>复杂度：O(nlogn)</li><li>首先选择一个元素——基准值</li><li>接着分区<ul><li>一个小于基准值的子数组</li><li>基准值</li><li>一个大于基准值的子数组</li></ul></li><li>对这两个子数组基进行快速排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">array</span>):</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(array) &lt; <span class="number">2</span>:</span><br><span class="line"><span class="comment"># 基线条件</span></span><br><span class="line"><span class="keyword">return</span> array</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 取基准值</span></span><br><span class="line">pivot = array[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 一个小于基准值的子数组</span></span><br><span class="line">less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=pivot]</span><br><span class="line"><span class="comment"># 一个大于基准值的子数组</span></span><br><span class="line">greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i&gt;pivot]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> quicksort(array) + pivot + quicksort(array)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> quicksort([arr])</span><br></pre></td></tr></table></figure><hr><h2 id="4-散列表"><a href="#4-散列表" class="headerlink" title="4.散列表"></a>4.散列表</h2><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>复杂度：$ O(1)$</p><p>条件：</p><ul><li>必须是一致的，输入和输出一一对应</li><li>将不同的输入映射到不同的数字</li><li>灵活运用索引</li><li>只返回有效索引</li></ul><p>python：字典 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">book = <span class="built_in">dict</span>()</span><br><span class="line">book[<span class="string">&quot;apple&quot;</span>] = <span class="number">0.67</span></span><br><span class="line">book[<span class="string">&quot;milk&quot;</span>] = <span class="number">1.49</span></span><br><span class="line">book[<span class="string">&quot;avocado&quot;</span>] = <span class="number">1.49</span></span><br><span class="line"><span class="built_in">print</span>(book)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;book&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(book.items())</span><br><span class="line"><span class="built_in">print</span>(book.keys())</span><br><span class="line"><span class="built_in">print</span>(book.values())</span><br></pre></td></tr></table></figure><p>散列表由键和值组成</p><h3 id="散列表的应用"><a href="#散列表的应用" class="headerlink" title="散列表的应用"></a>散列表的应用</h3><ul><li>电话簿</li><li>网站地址转IP地址</li><li>缓存</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cache =&#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page</span>(<span class="params">url</span>):</span><br><span class="line"><span class="keyword">if</span> cache.get(url):</span><br><span class="line"><span class="keyword">return</span> cache[url]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">data = get_data_from_server(url)</span><br><span class="line">cache[url] = data</span><br><span class="line"><span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><ul><li>防止重复</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建已投票字典</span></span><br><span class="line">voted = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_voter</span>(<span class="params">name</span>): </span><br><span class="line"><span class="keyword">if</span> voted.get(name):</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;kick them out!&quot;</span> </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">voted[name] = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;let them vote!&quot;</span></span><br></pre></td></tr></table></figure><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>给两个键分配的位置相同</p><ul><li>散列函数很重要</li><li>如果散列表存储的链表很长，散列表的速度将急剧下降</li></ul><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul><li>较低的填装因子</li><li>良好的散列函数</li></ul><p>填装因子：散列表包含的元素数/位置总数</p><p>一旦填装因子大于0.7，可以调整列表长度</p><hr><h2 id="5-广度优先搜索"><a href="#5-广度优先搜索" class="headerlink" title="5.广度优先搜索"></a>5.广度优先搜索</h2><p>breadth-first search, BFS</p><p>效果：找到两样东西之间的最短距离</p><p>最短路径问题(shortest-path problem)</p><ul><li>我去北京天安门，需要几个步骤<ul><li>打车到广州南站</li><li>高铁从广州南站到北京</li><li>打车到北京天安门</li></ul></li><li>使用图来建立问题模型</li><li>使用广度优先搜索解决问题</li></ul><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图模拟一组连接</p><p>图由<strong>节点(node)</strong>和<strong>边(edge)</strong>组成</p><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>解决问题：</p><ol><li>从节点A出发，有前往节点B的路径吗？</li><li>从节点A出发，前往节点B的哪条路经最短？</li></ol><p><strong>队列</strong></p><p>先进先出(First In First Out, FIFO)</p><p>操作：</p><ul><li>入队</li><li>出队</li></ul><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0004.png" style="width:50%;height:50%;"/></div></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;you&quot;</span>] = [<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;claire&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;bob&quot;</span>] = [<span class="string">&quot;anuj&quot;</span>, <span class="string">&quot;peggy&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;alice&quot;</span>] = [<span class="string">&quot;peggy&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;claire&quot;</span>] = [<span class="string">&quot;thom&quot;</span>, <span class="string">&quot;jonny&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;anuj&quot;</span>] = []</span><br><span class="line">graph[<span class="string">&quot;peggy&quot;</span>] = []</span><br><span class="line">graph[<span class="string">&quot;thom&quot;</span>] = []</span><br><span class="line">graph[<span class="string">&quot;jonny&quot;</span>] = []</span><br></pre></td></tr></table></figure><blockquote><p>键-值对的添加顺序不重要，散列表是无序的</p></blockquote><h3 id="🔥实现算法"><a href="#🔥实现算法" class="headerlink" title="🔥实现算法"></a>🔥实现算法</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0005.png" style="width:78%;height:78%;"/></div></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">person_is_seller</span>(<span class="params">name</span>):</span><br><span class="line"><span class="keyword">return</span> name[-<span class="number">1</span>] == <span class="string">&#x27;m&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">name</span>):</span><br><span class="line">search_queue = deque()</span><br><span class="line">search_queue += graph[<span class="string">&quot;you&quot;</span>]</span><br><span class="line">searched = [] <span class="comment"># 记录检查过的人</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> search_queue:<span class="comment"># 只要队列不为空</span></span><br><span class="line"><span class="comment"># 取出队列的第一个人</span></span><br><span class="line">person = search_queue.popleft()</span><br><span class="line"><span class="keyword">if</span> person <span class="keyword">not</span> <span class="keyword">in</span> searched:</span><br><span class="line"><span class="keyword">if</span> person_is_seller(person):</span><br><span class="line"><span class="built_in">print</span>(person + <span class="string">&quot;is a mango seller!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 将其邻居加入队列</span></span><br><span class="line">search_queue += graph[person]</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">search(<span class="string">&quot;you&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>运行时间</strong></p><p>O(V + E) V是顶点数，E为边数</p><p><strong>拓扑排序</strong>是针对有向无环图（DAG，Directed Acyclic Graph）的一种排序算法，它将图中的所有顶点排成一个<strong>线性序列（有序序列）</strong>，使得对于任何一条有向边U→V，顶点U都在顶点V之前 </p><p><strong>树</strong>是特殊的图，其中没有往后指的边</p><hr><h2 id="6-迪克斯特拉算法"><a href="#6-迪克斯特拉算法" class="headerlink" title="6.迪克斯特拉算法"></a>6.迪克斯特拉算法</h2><p>广度优先搜索 找出段数最少的路径</p><p>迪克斯特拉算法 找出最快、总权重最小的路径</p><ol><li>找出最小的节点（本轮权重最小的节点）</li><li>更新该节点的邻居的开销</li><li>重复🔁该过程，直到遍历完所有节点</li><li>计算最终路径</li></ol><div class="note warning no-icon flat"><p>🍁 <strong>找出图中最便宜的节点，并确保没有到该节点的更便宜的路径</strong></p></div><p><strong>术语</strong></p><ul><li>权重(weight)</li><li>加权图(weighted graph)</li><li>非加权图(unweighted graph)</li><li>环(loop)</li></ul><div class="note info no-icon flat"><p>迪克斯特拉算法只适用于有向无环图(directed acyclic graph, DAG)</p></div><p><strong>负权边</strong></p><p>如果有负权边，就不能使用迪克斯特拉算法</p><p>可以使用贝尔曼-福德算法(Bellman-Ford algorithm)</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>需要三个散列表 </p><ol><li>一个散列表存储邻居和前往邻居的开销（邻居的散列表包含开销的散列表）</li><li>一个散列表存储每个节点的开销（从起点开始计算🧮），终点默认为无穷大</li><li>一个散列表存储父节点，默认为没有None</li></ol><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0006.png" style="width:60%;height:60%;"/></div></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新最小的节点</span></span><br><span class="line">node = find_lowest_cost_node(costs) </span><br><span class="line"><span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"><span class="comment"># 获取该节点的开销和邻居散列表</span></span><br><span class="line">cost = costs[node] </span><br><span class="line">neighbors = graph[node] </span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> neighbors.keys():</span><br><span class="line"><span class="comment"># 遍历当前节点的所有邻居</span></span><br><span class="line">new_cost = cost + neighbors[n] </span><br><span class="line"><span class="keyword">if</span> costs[node] &gt; new_cost:</span><br><span class="line"><span class="comment"># 如果经当前节点前往该邻居更近，就更新该邻居的开销</span></span><br><span class="line">costs[node] = new_cost</span><br><span class="line"><span class="comment"># 同时将该邻居的父节点设置为当前节点</span></span><br><span class="line">parents[node] = node   </span><br><span class="line">processed.append(node)</span><br><span class="line">node = find_lowest_cost_node(costs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_lowest_cost_node</span>(<span class="params">costs</span>):</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">从costs散列表找出开销最小的节点</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">lowest_cost = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">lowest_cost_node = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> costs:</span><br><span class="line">cost =costs[node]</span><br><span class="line"><span class="keyword">if</span> cost &lt; lowest_cost <span class="keyword">and</span> node <span class="keyword">not</span> <span class="keyword">in</span> processed:</span><br><span class="line"><span class="comment"># 如果当前节点的开销更小且未处理过</span></span><br><span class="line">lowest_cost = cost</span><br><span class="line">lowest_cost_node = node</span><br><span class="line"><span class="keyword">return</span> lowest_cost_node</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;start&quot;</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;a&quot;</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;b&quot;</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;c&quot;</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;d&quot;</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">&quot;start&quot;</span>][<span class="string">&quot;a&quot;</span>] = <span class="number">5</span></span><br><span class="line">graph[<span class="string">&quot;start&quot;</span>][<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line">graph[<span class="string">&quot;a&quot;</span>][<span class="string">&quot;c&quot;</span>] = <span class="number">4</span></span><br><span class="line">graph[<span class="string">&quot;a&quot;</span>][<span class="string">&quot;d&quot;</span>] = <span class="number">2</span></span><br><span class="line">graph[<span class="string">&quot;b&quot;</span>][<span class="string">&quot;a&quot;</span>] = <span class="number">8</span></span><br><span class="line">graph[<span class="string">&quot;b&quot;</span>][<span class="string">&quot;d&quot;</span>] = <span class="number">7</span></span><br><span class="line">graph[<span class="string">&quot;c&quot;</span>][<span class="string">&quot;d&quot;</span>] = <span class="number">6</span></span><br><span class="line">graph[<span class="string">&quot;c&quot;</span>][<span class="string">&quot;fin&quot;</span>] = <span class="number">3</span></span><br><span class="line">graph[<span class="string">&quot;d&quot;</span>][<span class="string">&quot;fin&quot;</span>] = <span class="number">1</span></span><br><span class="line">graph[<span class="string">&quot;fin&quot;</span>] = &#123;&#125;</span><br><span class="line">costs = &#123;&#125;</span><br><span class="line">inf = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">costs[<span class="string">&quot;a&quot;</span>] = <span class="number">5</span></span><br><span class="line">costs[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line">costs[<span class="string">&quot;c&quot;</span>] = inf</span><br><span class="line">costs[<span class="string">&quot;d&quot;</span>] = inf</span><br><span class="line">costs[<span class="string">&quot;fin&quot;</span>] = inf</span><br><span class="line">parents = &#123;&#125;</span><br><span class="line">parents[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;start&quot;</span></span><br><span class="line">parents[<span class="string">&quot;b&quot;</span>] = <span class="string">&quot;start&quot;</span></span><br><span class="line">parents[<span class="string">&quot;fin&quot;</span>] = <span class="literal">None</span></span><br><span class="line">processed = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_lowest_cost_node</span>(<span class="params">costs</span>):</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">从costs散列表找出开销最小的节点</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">lowest_cost = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">lowest_cost_node = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> costs:</span><br><span class="line">cost =costs[node]</span><br><span class="line"><span class="keyword">if</span> cost &lt; lowest_cost <span class="keyword">and</span> node <span class="keyword">not</span> <span class="keyword">in</span> processed:</span><br><span class="line"><span class="comment"># 如果当前节点的开销更小且未处理过</span></span><br><span class="line">lowest_cost = cost</span><br><span class="line">lowest_cost_node = node</span><br><span class="line"><span class="keyword">return</span> lowest_cost_node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新最小的节点</span></span><br><span class="line">node = find_lowest_cost_node(costs) </span><br><span class="line"><span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"><span class="comment"># 获取该节点的开销和邻居散列表</span></span><br><span class="line">cost = costs[node] </span><br><span class="line">neighbors = graph[node] </span><br><span class="line"><span class="keyword">for</span> neighbor_node <span class="keyword">in</span> neighbors.keys():</span><br><span class="line"><span class="comment"># 遍历当前节点的所有邻居</span></span><br><span class="line">new_cost = cost + neighbors[neighbor_node] </span><br><span class="line"><span class="keyword">if</span> costs[neighbor_node] &gt; new_cost:</span><br><span class="line"><span class="comment"># 如果经当前节点前往该邻居更近，就更新该邻居的开销</span></span><br><span class="line">costs[neighbor_node] = new_cost</span><br><span class="line"><span class="comment"># 同时将该邻居的父节点设置为当前节点</span></span><br><span class="line">parents[neighbor_node] = node   </span><br><span class="line">processed.append(node)</span><br><span class="line">node = find_lowest_cost_node(costs)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(costs[<span class="string">&quot;fin&quot;</span>])</span><br></pre></td></tr></table></figure><div class="note info no-icon flat"><p>🌍 <strong>所有东西都要初始化</strong></p></div><hr><h2 id="7-贪婪算法"><a href="#7-贪婪算法" class="headerlink" title="7.贪婪算法"></a>7.贪婪算法</h2><p>每步都选择局部最优解，最终得到的就是全局最优解</p><p><strong>背包问题🎒</strong></p><p><strong>集合覆盖问题</strong></p><ul><li>近似算法(approximation algorithm)</li><li>选出一个覆盖了最多的未覆盖州的广播台</li><li>重复直到覆盖掉所有州</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">provinces_needed = <span class="built_in">set</span>([<span class="string">&quot;京&quot;</span>,<span class="string">&quot;津&quot;</span>,<span class="string">&quot;冀&quot;</span>,<span class="string">&quot;沪&quot;</span>,<span class="string">&quot;黑&quot;</span>,<span class="string">&quot;琼&quot;</span>,<span class="string">&quot;粤&quot;</span>])</span><br><span class="line">stations = &#123;&#125;</span><br><span class="line">stations[<span class="string">&quot;北京&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;京&quot;</span>,<span class="string">&quot;津&quot;</span>,<span class="string">&quot;冀&quot;</span>])</span><br><span class="line">stations[<span class="string">&quot;天津&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;津&quot;</span>,<span class="string">&quot;冀&quot;</span>,<span class="string">&quot;沪&quot;</span>])</span><br><span class="line">stations[<span class="string">&quot;上海&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;冀&quot;</span>,<span class="string">&quot;沪&quot;</span>,<span class="string">&quot;黑&quot;</span>])</span><br><span class="line">stations[<span class="string">&quot;黑龙江&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;冀&quot;</span>,<span class="string">&quot;黑&quot;</span>,<span class="string">&quot;琼&quot;</span>])</span><br><span class="line">stations[<span class="string">&quot;海南&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;琼&quot;</span>,<span class="string">&quot;粤&quot;</span>])</span><br><span class="line">stations[<span class="string">&quot;广东&quot;</span>] = <span class="built_in">set</span>([<span class="string">&quot;京&quot;</span>,<span class="string">&quot;沪&quot;</span>,<span class="string">&quot;粤&quot;</span>])</span><br><span class="line">final_stations = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> provinces_needed:</span><br><span class="line">    best_station = <span class="literal">None</span></span><br><span class="line">    states_covered = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> station, states_for_station <span class="keyword">in</span> stations.items():</span><br><span class="line">        covered = provinces_needed &amp; states_for_station</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(covered) &gt; <span class="built_in">len</span>(states_covered):</span><br><span class="line">            best_station = station</span><br><span class="line">            states_covered = covered</span><br><span class="line">    final_stations.add(best_station)</span><br><span class="line">    provinces_needed -= states_covered</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(final_stations)</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note primary no-icon flat"><p>创建集合，一个无序的不重复元素序列，<code>set</code> <code>add</code> <code>remove</code> ，交集&amp;、并集｜、差集-</p></div><h3 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h3><p>需要计算所有的解，并从中选出最小/最短的</p><p>阶乘函数(factorial function)</p><p>NP完全问题的特征</p><ul><li>涉及所有组合的</li><li>必须考虑各种可能的情况</li><li>涉及序列且难以解决</li><li>涉及集合且难以解决</li><li>可转换为旅行商问题</li></ul><hr><h2 id="8-动态规划"><a href="#8-动态规划" class="headerlink" title="8.动态规划"></a>8.动态规划</h2><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>简单算法：尝试各种组合，找出价值最高的组合($2^n$)</p><p>动态规划</p><ul><li>先解决子问题，再逐步解决大问题</li><li>都从网格开始<ul><li>各行 为可选择的商品</li><li>各列 为不同容量的背包</li></ul></li></ul><p><strong>吉他行</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0007.png" style="width:85%;height:85%;"/></div></div><p>为了让当前的最大价值最大，在只能偷吉他的情况下，在1、2、3、4磅的背包容量单元格只能填¥1500</p><p><strong>音响行</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0008.png" style="width:85%;height:85%;"/></div></div><p>为了让当前的最大价值最大，在只能偷吉他和音响的情况下，在1、2、3磅的背包容量单元格只能填¥1500，因为音响太重了，在4磅的背包单元格终于可以填音响，更新为¥3000</p><p><strong>笔记本行</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0009.png" style="width:90%;height:90%;"/></div></div><p>笔记本较重，3磅的背包容量单元格可以装下笔记本，更新为¥2000</p><p><img src="../img/算法/0010.png" alt="Untitled"></p><p>在4磅1的背包容量单元格可以同时装下吉他和笔记本，更新为¥3500</p><p><strong>总结</strong></p><p><img src="../img/算法/0011.png" alt="Untitled"></p><ul><li>沿着一列往下走时，最大价值不可能降低</li><li>行的排列顺序与结果无关</li><li>逐行or逐列排序都没有关系</li><li>增加一件更小的商品会增加颗粒度，必须调整网络</li><li>不可以偷商品的一部分</li><li>旅游行程最优化可以使用背包问题</li></ul><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0012.png" style="width:85%;height:85%;"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0013.png" style="width:85%;height:85%;"/></div></div><div class="note info no-icon flat"><p>但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用</p></div><h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="../img/算法/0014.png" style="width:80%;height:80%;"/></div></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> word_a[i] == word_b[j]: <span class="comment"># 如果相同设为左上角+1</span></span><br><span class="line">cell[i][j] = cell[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 如果不同设为0</span></span><br><span class="line">cell[i][j] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>答案为网格中最大的数字</strong></p><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p><img src="../img/算法/0015.png" alt="Untitled"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> word_a[i] == word_b[j]: <span class="comment"># 如果相同设为左上角+1</span></span><br><span class="line">cell[i][j] = cell[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 如果不同设为0</span></span><br><span class="line">cell[i][j] = <span class="built_in">max</span>(cell[i-<span class="number">1</span>][j],cell[i][j-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><hr><h2 id="9-K最近邻算法"><a href="#9-K最近邻算法" class="headerlink" title="9.K最近邻算法"></a>9.K最近邻算法</h2><p>k-nearest neighbors, KNN</p><ol><li>对水果进行分类，比如哈密瓜🍈和西瓜🍉中有一个神秘的水果</li><li>查看它三个最近的邻居</li><li>在这些邻居中，哈密瓜🍈数量多于西瓜🍉，因此很可能是哈密瓜</li></ol><h3 id="创建推荐系统"><a href="#创建推荐系统" class="headerlink" title="创建推荐系统"></a>创建推荐系统</h3><p><strong>特征抽取</strong></p><p>计算两点的距离可以用毕达哥斯拉公式</p><script type="math/tex; mode=display">\sqrt{ \left( x_{1}-x_{2}\right) ^{2}+ \left (y_{1}-y_{2}\right)^{2} }</script><p><strong>余弦相似度</strong></p><p>余弦相似度的取值范围从-1到1：</p><ul><li>1 表示向量完全相同（指向同一方向）</li><li>0 表示向量正交（完全不同）</li><li>1 表示向量完全相反（指向相反方向）</li></ul><p><strong>计算公式</strong></p><p>对于两个向量 <strong>A</strong> 和 <strong>B</strong>，余弦相似度cosine(<strong>A</strong>,<strong>B</strong>) 定义为：</p><p>$\text{cosine}(\mathbf{A}, \mathbf{B}) = \frac{\mathbf{A} \cdot \mathbf{B}}{|\mathbf{A}| |\mathbf{B}|}$</p><p>其中：</p><ul><li><strong>A</strong>⋅<strong>B</strong> 是向量 <strong>A</strong> 和 <strong>B</strong> 的点积（内积）</li><li>∥<strong>A</strong>∥ 和 ∥<strong>B</strong>∥ 分别是向量 <strong>A</strong> 和 <strong>B</strong> 的欧几里得范数（长度）</li></ul><p>$\text{cosine}(\mathbf{A}, \mathbf{B}) = \frac{\sum<em>{i=1}^{n} a_i \cdot b_i}{\sqrt{\sum</em>{i=1}^{n} a<em>i^2} \cdot \sqrt{\sum</em>{i=1}^{n} b_i^2}}$</p><p><strong>实例</strong></p><p>假设有两个向量A=[a1,a2,a3]和B=[b1,b2,b3]，它们的余弦相似度计算如下：</p><p>$\text{cosine}(\mathbf{A}, \mathbf{B}) = \frac{a_1 b_1 + a_2 b_2 + a_3 b_3}{\sqrt{a_1^2 + a_2^2 + a_3^2} \cdot \sqrt{b_1^2 + b_2^2 + b_3^2}}$。</p><p>若是评价标准不同呢？</p><p>可使用归一化(normalization)。你可计算每位用户的平均评分，并据此来调整用户的评分</p><p><strong>回归</strong></p><p>就是根据已有数据预测结果（如一个数字）</p><div class="note warning no-icon flat"><p>🏆 <strong>KNN — 分类和回归</strong></p></div><p>建议根据sqrt(n)来推荐</p><h3 id="机器学习简介"><a href="#机器学习简介" class="headerlink" title="机器学习简介"></a>机器学习简介</h3><p><strong>OCR(optical character recognition)，光学字符识别</strong></p><ol><li>浏览大量的数字图像，提取特征（线段、点、曲线等）</li><li>遇到新图像时，提取该特征并找出最近的邻居都是谁</li></ol><p><strong>创建垃圾邮件过滤器</strong></p><p>朴素贝叶斯分类器(Naive Bayes classifier)</p><p>假设特征之间相互独立</p><p>$P(A|B) = \frac{P(B|A) \cdot P(A)}{P(B)}$</p><p>$y = \arg\max<em>{C_i} P(C_i|X) = \arg\max</em>{C_i} \frac{P(X|C_i) \cdot P(C_i)}{P(X)}$</p><p><strong>预测股票情绪</strong></p><p>几乎不可能</p><hr><h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a>10.总结</h2><ul><li>第一章<ul><li>二分查找的速度比简单查找快得多</li><li>O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多</li><li>算法运行时间并不以秒为单位</li><li>算法运行时间是从其增速的角度度量的</li><li>算法运行时间用大O表示法表示</li></ul></li><li>第二章<ul><li>计算机内存犹如一大堆抽屉</li><li>需要存储多个元素时，可使用数组或链表</li><li>数组的元素都在一起</li><li>链表的元素是分开的，其中每个元素都存储了下一个元素的地址</li><li>数组的读取速度很快</li><li>链表的插入和删除速度很快</li><li>在同一个数组中，所有元素的类型都必须相同(都为int、double等)</li></ul></li><li>第三章<ul><li>递归指的是调用自己的函数</li><li>每个递归函数都有两个条件:基线条件和递归条件</li><li>栈有两种操作:压入和弹出</li><li>所有函数调用都进入调用栈</li><li>调用栈可能很长，这将占用大量的内存</li><li>每次递归会创建新的栈帧，循环始终使用一个栈帧</li></ul></li><li>第四章<ul><li>D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元素的数组</li><li>实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O（n logn）</li><li>大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在</li><li>比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O（log n）的速度比O（n）快得多</li></ul></li><li>第五章<ul><li>你可以结合散列函数和数组来创建散列表</li><li>冲突很糟糕，你应使用可以最大限度减少冲突的散列函数</li><li>散列表的查找、插入和删除速度都非常快</li><li>散列表适合用于模拟映射关系</li><li>一旦填装因子超过0.7，就该调整散列表的长度</li><li>散列表可用于缓存数据（例如，在Web服务器上）</li><li>散列表非常适合用于防止重复</li></ul></li><li>第六章<ul><li>广度优先搜索指出是否有从A到B的路径</li><li>如果有，广度优先搜索将找出最短路径</li><li>面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来解决问题</li><li>有向图中的边为箭头，箭头的方向指定了关系的方向，例如，rama radit表示rama欠adit钱</li><li>无向图中的边不带箭头，其中的关系是双向的，例如，ross - rachel表示 “ross 与rachel约会，而rachel也与ross约会”</li><li>队列是先进先出（FIFO）的。</li><li>栈是后进先出（LIFO）的。</li><li>你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列</li><li>对于检查过的人，务必不要再去检查，否则可能导致无限循环</li></ul></li><li>第七章<ul><li>广度优先搜索用于在非加权图中查找最短路径</li><li>迪克斯特拉算法用于在加权图中查找最短路径</li><li>仅当权重为正时狄克斯特拉算法才管用</li><li>如果图中包含负权边，请使用贝尔曼-福德算法</li></ul></li><li>第八章<ul><li>贪婪算法寻找局部最优解，企图以这种方式获得全局最优解</li><li>对于NP完全问题，还没有找到快速解决方案</li><li>面临NP完全问题时，最佳的做法是使用近似算法</li><li>贪婪算法易于实现、运行速度快，是不错的近似算法</li></ul></li><li>第九章<ul><li>需要在给定约束条件下优化某种指标时，动态规划很有用</li><li>问题可分解为离散子问题时，可使用动态规划来解决</li><li>每种动态规划解决方案都涉及网格</li><li>单元格中的值通常就是你要优化的值</li><li>每个单元格都是一个子问题，因此你需要考虑将问题分解为子问题</li><li>没有放之四海皆准的计算动态规划解决方案的公式</li></ul></li><li>第十章<ul><li>KNN用于分类和回归，需要考虑最近的邻居</li><li>分类就是编组</li><li>回归就是预测结果(如数字)</li><li>特征抽取意味着将物品(如水果或用户)转换为一系列可比较的数字</li><li>能否挑选合适的特征事关KNN算法的成败</li></ul></li></ul><hr>]]></content>
    
    
    <summary type="html">入门的第一本算法书</summary>
    
    
    
    <category term="编程学习" scheme="https://agoni66.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="算法" scheme="https://agoni66.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（六）</title>
    <link href="https://agoni66.github.io/posts/1000106.html"/>
    <id>https://agoni66.github.io/posts/1000106.html</id>
    <published>2024-06-04T08:30:00.000Z</published>
    <updated>2024-09-10T01:17:25.989Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><p><font size="4"><b>计算机网络导航🚀🚀🚀</b></font></p><ol><li><p>🍕<a href="https://agoni66.github.io/posts/1000101.html">第一章 概述</a></p></li><li><p>🍔<a href="https://agoni66.github.io/posts/1000102.html">第二章 物理层</a></p></li><li><p>🍟<a href="https://agoni66.github.io/posts/1000103.html">第三章 数据链路层</a></p></li><li><p>🌭<a href="https://agoni66.github.io/posts/1000104.html">第四章 网际层</a></p></li><li><p>🍿<a href="https://agoni66.github.io/posts/1000105.html">第五章 运输层</a></p></li><li><p>🧂<a href="https://agoni66.github.io/posts/1000106.html">第六章 应用层</a> ⇦ 当前位置🪂</p></li></ol></div><div class="note warning modern"><p><b>图片加载较慢，请耐心等待！🌤️🌥️🌦️</b></p></div><h2 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h2><p>应用层是计算机网络体系结构的<strong>最顶层</strong>，是<strong>设计和建立计算机网络的最终目的</strong>，也是计算机网络中发展最快的部分</p><h2 id="知识点一：客户-服务器方式（C-S方式）和对等方式（P2P方式）"><a href="#知识点一：客户-服务器方式（C-S方式）和对等方式（P2P方式）" class="headerlink" title="知识点一：客户/服务器方式（C/S方式）和对等方式（P2P方式）"></a>知识点一：客户/服务器方式（C/S方式）和对等方式（P2P方式）</h2><p>开发一种新的网络应用首先要考虑的问题就是<strong>网络应用程序在各种端系统上的组织方式和它们之间的关系</strong></p><p>目前流行的主要有以下两种：</p><div class="note danger no-icon flat"><p>📏 <strong>客户/服务器(Client/Server，C/S)方式</strong></p></div><ul><li>客户和服务器是指通信中所涉及的两个应用进程</li><li>客户/服务器方式所描述的是进程之间服务和被服务的关系</li><li>客户是服务请求方，服务器是服务提供方</li><li>服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号(例如HTTP服务器的默认端口号为80)，而运行服务器的主机也具有固定的IP地址</li><li>基于C/S方式的应用服务通常是 <strong><code>服务集中型</code></strong> 的，即应用服务集中在网络中比客户计算机少得多的服务器计算机上<ul><li>由于一台服务器计算机要为多个客户机提供服务，在C/S应用中，<strong>常会出现服务器计算机跟不上众多客户机请求的情况</strong></li><li>为此，在C/S应用中，常用<strong>计算机群集</strong>(或服务器场)构建一个强大的虚拟服务器</li></ul></li></ul><div class="note danger no-icon flat"><p>📏 <strong>对等(Peer-to-Peer，P2P)方式</strong></p></div><p>在P2P方式中，<strong>没有固定的服务请求者和服务提供者</strong>，分布在网络边缘各端系统中的应用进程是对等的，被称为<strong>对等方</strong>。<strong>对等方相互之间直接通信</strong>，每个对等方既是服务的请求者，又是服务的提供者。</p><ul><li>基于P2P的应用是 <strong><code>服务分散型</code></strong> 的，因为服务不是集中在少数几个服务器计算机中，而是分散在大量对等计算机中，这些计算机并不为服务提供商所有，而是为个人控制的桌面计算机和笔记本电脑，它们通常位于住宅、校园和办公室中</li><li>P2P方式的最突出特性之一就是它的<strong>可扩展性</strong>。因为系统每增加一个对等方，不仅增加的是服务的请求者，同时也增加了服务的提供者，系统性能不会因规模的增大而降低</li><li>P2P方式<strong>具有成本上的优势</strong>，因为它通常不需要庞大的服务器设施和服务器带宽。为了降低成本，服务提供商对于将P2P方式用于应用的兴趣越来越大</li></ul><hr><h2 id="✨知识点二：动态主机配置协议DHCP"><a href="#✨知识点二：动态主机配置协议DHCP" class="headerlink" title="✨知识点二：动态主机配置协议DHCP"></a>✨知识点二：动态主机配置协议DHCP</h2><p>互联网广泛使用的 <strong><code>动态主机配置协议 DHCP</code></strong> (Dynamic Host Configuration Protocol) 提供了 <strong><code>即插即用</code></strong> 连网 (plug-and-play networking) 的机制</p><p>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置</p><h3 id="DHCP-使用客户-服务器方式"><a href="#DHCP-使用客户-服务器方式" class="headerlink" title="DHCP 使用客户 - 服务器方式"></a><strong>DHCP 使用客户 - 服务器方式</strong></h3><ul><li>需要 IP 地址的主机在启动时就向 DHCP 服务器<strong>广播</strong>发送发现报文 （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但<strong>只有 DHCP 服务器才回答此广播报文</strong></li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）</li></ul><h3 id="DHCP-工作方式"><a href="#DHCP-工作方式" class="headerlink" title="DHCP 工作方式"></a><strong>DHCP 工作方式</strong></h3><ul><li>DHCP 使用客户-服务器方式，采用请求/应答方式工作。</li><li>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），<strong>DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口</strong></li></ul><h3 id="DHCP交互过程"><a href="#DHCP交互过程" class="headerlink" title="DHCP交互过程"></a><strong>DHCP交互过程</strong></h3><ol><li>DHCP客户端将 <strong><code>广播发送DHCP发现报文</code></strong>（DHCP DISCOVER）<ul><li>事务ID</li><li>DHCP客户端的MAC地址</li></ul></li></ol><ul><li><strong>封装该报文的IP数据报的源IP地址为0.0.0.0</strong>，这是因为主机目前还未分配到IP地址，因此使用该地址代替</li><li><strong>目的IP地址为广播地址255.255.255.255</strong>，之所以广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器。它们的IP地址各是什么</li><li>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送</li></ul><ol><li>DHCP服务端将 <strong><code>广播发送DHCP提供报文</code>（DHCP OFFER）</strong><ul><li>事务ID：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的</li><li>配置信息<ul><li>IP地址：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址（使用ARP来确保所选IP地址未被网络中其他主机占用）</li><li>子网掩码</li><li>地址租期</li><li>默认网关</li><li>DNS服务器</li></ul></li></ul></li><li><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong><ul><li>事务ID</li><li>DHCP客户端的MAC地址</li><li>接收的租约中的IP地址</li><li>提供此租约的DHCP服务器端的IP地址</li><li>源地址：0.0.0.0，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器。它首先要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址</li><li>目的地址：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器</li></ul></li></ol><p>DHCP客户收到该报文后就可以使用租用的IP地址</p><p>在使用前还会 <strong><code>进行ARP检测</code></strong></p><p>使用ARP检测所分配到的IP地址是否已被网络中其他主机占用</p><ul><li>若被占用：给DHCP服务器发送“DHCPDECLINE”报文撤销IP地址租约，并重新发送“DHCP DISCOVER”报文</li><li>若未被占用：可以使用租约中的IP地址与网络中其他主机通信了</li></ul><p><img src="../img/计算机网络/5200.png" alt="Untitled"></p><h3 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a><strong>DHCP中继代理</strong></h3><p>给该路由器配置DHCP服务器的IP地址并使之成为DHCP中继代理</p><p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p><hr><h2 id="✨知识点三：域名系统DNS"><a href="#✨知识点三：域名系统DNS" class="headerlink" title="✨知识点三：域名系统DNS"></a>✨知识点三：域名系统DNS</h2><p>因特网采用层<strong>次树状结构的域名结构</strong></p><p>域名的结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名</p><p>.三级域名.二级域名.顶级域名</p><p>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母。</p><p>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边。</p><p>完整的域名不超过255个字符</p><p>域名系统既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。</p><p>各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理</p><p><strong>顶级域名TLD</strong>(Top Level Domain)分为以下三类：</p><div class="table-container"><table><thead><tr><th>国家顶级域名nTLD</th><th>采用IS03166的规定。如cn表示中国，us表示美国，uk表示英国、等等</th></tr></thead><tbody><tr><td>通用顶级域名gTLD</td><td>最常见的通用顶级域名有七个，即:com(公司企业net(网络服务机美国教育结构)、构)、org(非营利性组织)、int(国际组织)、edugov(美国政府部门)、mil(美国军事部门)</td></tr><tr><td>反向域arpa</td><td>用于反向域名解析，即IP地址反向解析为域名。</td></tr></tbody></table></div><p>在<strong>国家顶级域名下注册的二级域名均由该国家自行确定</strong>。例如，顶级域名为jp的日本将其教育和企业机构的二级域名定为ac和co，而不用edu和com</p><p>我国则将<strong>二级域名划分为以下两类</strong>：</p><div class="table-container"><table><thead><tr><th>类别域名</th><th>共七个:ac(科研机构)om(工、商、金融等企业)、edu(教育机构)gov(政府部门)、net(提供网络服务的机构)、mil(军事机构)和org(非营利性组织)。</th></tr></thead><tbody><tr><td>行政区域名</td><td>共34个，适用于我国的各省、自治区、直辖市。例如:bj为北京市、sh为上海市、js为江苏省，等等。</td></tr></tbody></table></div><p>注意：名称相同的域名其等级未必相同</p><p><strong><span class='p h3 blue'>域名解析过程</span></strong></p><p><img src="../img/计算机网络/5300.png" alt="Untitled"></p><p>为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了<strong>高速缓存</strong>。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p><p>由于域名到IP地址的映射关系并不是永久不变，为保持高速缓存中的内容正确，域名服务器<strong>应为每项内容设置计时器并删除超过合理时间的项</strong>(例如，每个项目只存放两天)。</p><p>不但在本地域名服务器中需要高速缓存，在用户主机中也很需要。许多用户主机在启动时从本地域名服务器下载域名和IP地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到域名时才向域名服务器查询。同理，主机也需要保持高速缓存中内容的正确性</p><p><img src="../img/计算机网络/5301.png" alt="Untitled"></p><p><img src="../img/计算机网络/5302.png" alt="Untitled"></p><hr><h2 id="✨知识点四：文件传送协议FTP"><a href="#✨知识点四：文件传送协议FTP" class="headerlink" title="✨知识点四：文件传送协议FTP"></a>✨知识点四：文件传送协议FTP</h2><p><strong><code>文件传送协议FTP</code></strong>(File Transfer Protocol)是因特网上使用得最广泛的文件传送协议。</p><ul><li>FTP提供<strong>交互式的访问</strong>，允许客户<strong>指明文件的类型与格式</strong>(如指明是否使用ASCI码)，并允许<strong>文件具有存取权限</strong>(如访问文件的用户必须经过授权，并输入有效的口令)</li><li><strong>FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件</strong></li></ul><p><strong><span class='p h3 blue'>基本工作原理</span></strong></p><p> <strong><code>主动模式</code></strong> 就是客户告诉服务器我要喝茶 把杯子放好  倒水 喝完 拿走 再喝的话 再拿来 喝完再拿走</p><p> <strong><code>被动连接</code></strong> 就是客户你要喝茶自己端着杯子过来 我给你茶水 喝完拿走杯子 再喝 再过来</p><p>控制连接与数据连接</p><p><img src="../img/计算机网络/5400.png" alt="Untitled"></p><p><img src="../img/计算机网络/5401.png" alt="Untitled"></p><p><img src="../img/计算机网络/5402.png" alt="Untitled"></p><hr><h2 id="✨知识点五：电子邮件"><a href="#✨知识点五：电子邮件" class="headerlink" title="✨知识点五：电子邮件"></a>✨知识点五：电子邮件</h2><p>电子邮件系统采用 <strong><code>客户/服务器方式</code></strong></p><p>电子邮件系统的三个主要组成构件</p><p> <strong><code>用户代理</code>， <code>邮件服务器</code>，以及 <code>电子邮件所需的协议</code></strong></p><ul><li><strong>用户代理</strong>是用户与电子邮件系统的接口，又称为<strong>电子邮件客户端软件</strong></li><li><strong>邮件服务器</strong>是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是<strong>发送和接收邮件</strong>，同时还要负责维护用户的邮箱</li><li><strong>协议</strong>包括<strong>邮件发送协议</strong>(例如SMTP)和<strong>邮件读取协议</strong>(例如POP3，IMAP)</li></ul><p><img src="../img/计算机网络/5500.png" alt="Untitled"></p><h3 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理"></a><strong>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理</strong></h3><p><img src="../img/计算机网络/5501.png" alt="Untitled"></p><p><strong>14条SMTP命令</strong></p><p><strong>21种SMTP应答</strong></p><p>有什么就答什么，我爱说实话</p><h3 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a><strong>电子邮件的信息格式</strong></h3><ul><li>电子邮件的信息格式并不是由SMTP定义的，而是在RFC822中单独定义的。这个RFC文档已在2008年更新为RFC 5322。一个电子邮件有 <strong><code>信封和内容</code>两部分</strong>。而内容又由 <strong><code>首部和主体</code>两部分构成</strong>。</li><li><strong>SMTP协议只能传送 <code>ASCII码</code>文本数据</strong>，不能传送可执行文件或其他的二进制对象</li><li>SMTP不能满足传送多媒体邮件(例如带有图片、音频或视频数据)的需要。并且许多其他非英语国家的文字(例如中文、俄文、甚至带有重音符号的法文或德文)也无法用SMTP传送</li><li>为解决SMTP传送非ASCII码文本的问题，提出了<strong>多用途因特网邮件扩展MIME</strong>(MulipurposeIntemetMai Extensions)。<ul><li>增加了<strong>5个新的邮件首部字段</strong>，这些字段提供了有关邮件主体的信息。</li><li>定义了<strong>许多邮件内容的格式</strong>，对多媒体电子邮件的表示方法进行了标准化。</li><li>定义了<strong>传送编码</strong>，可对任何内容格式进行转换，而不会被邮件系统改变</li></ul></li><li>实际上，MIME不积极用于SMTP，也用于面向ASCII字符的HTTP</li></ul><h3 id="邮件读取"><a href="#邮件读取" class="headerlink" title="邮件读取"></a><strong>邮件读取</strong></h3><ul><li><strong><code>邮局协议POP</code></strong> (Post0ffice Protocol)，POP3是其第三个版本，是<strong>因特网正式标准</strong>。非常简单、功能有限的邮件读取协议。用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机。不允许用户在邮件服务器上管理自己的邮件。(例如创建文件夹，对邮件进行分类管理等)。</li><li><strong><code>因特网邮件访问协议IMAP</code></strong> (IntermetMessage Access Protocol)，IMAP4是其第四个版本，目前还只是因特网建议标准。功能比POP3强大的邮件读取协议。用户在自己的计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此IMAP是一个联机协议。</li><li>POP3和IMAP4都采用 <strong><code>基于TCP连接的客户/服务器方式</code></strong>。POP3使用熟知端口110，IMAP4使用熟知端口143。</li></ul><h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a><strong>基于万维网的电子邮件</strong></h3><p>通过<strong>浏览器登录</strong>(提供用户名和口令)邮件服务器万维网网站就可以撰写、收发、阅读和管理电子邮件。这种工作模式与IMAP很类似，不同的是用户计算机无需安装专门的用户代理程序，只需要使用通用的万维网浏览器。</p><p>邮件服务器网站通常都提供非常强大和方便的邮件管理功能，用户可以在邮件服务器网站上管理和处理自己的邮件，而不需要将邮件下载到本地进行管理。</p><p><img src="../img/计算机网络/5502.png" alt="Untitled"></p><p><img src="../img/计算机网络/5503.png" alt="Untitled"></p><p><img src="../img/计算机网络/5504.png" alt="Untitled"></p><p><img src="../img/计算机网络/5505.png" alt="Untitled"></p><hr><h2 id="✨知识点六：万维网"><a href="#✨知识点六：万维网" class="headerlink" title="✨知识点六：万维网"></a>✨知识点六：万维网</h2><ul><li>万维网 WWW (World Wide Web) 并非某种特殊的计算机网络。</li><li>万维网是一个大规模的、联机式的<strong>信息储藏所</strong>。</li><li>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li><li>这种访问方式称为“<strong>链接</strong>”。</li><li>万维网以<strong>客户 - 服务器</strong>方式工作。</li><li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。</li><li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)</li><li>浏览器最重要的部分是<strong>渲染引擎</strong>，也就是<strong>浏览器内核</strong>。负责对网页内容进行解析和显示。</li></ul><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h3><p>为了方便地访问在世界范围的文档，万维网使用 <strong><code>统一资源定位符URL</code></strong> 来指明因特网上任何种类“资源”的位置。URL的一般形式由以下四个部分组成:</p><div class="note info no-icon flat"><p>🌐 <strong>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</strong></p></div><h3 id="超文本传输协议HTTP（Hyper-Transfer-Protocol）"><a href="#超文本传输协议HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="超文本传输协议HTTP（Hyper Transfer Protocol）"></a><strong>超文本传输协议HTTP（Hyper Transfer Protocol）</strong></h3><ol><li>每个万维网网点都有一个服务器进程，它不断地 <strong><code>监听 TCP 的端口 80</code></strong>，以便发现是否有浏览器向它发出连接建立请求。</li><li>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。</li><li>最后，TCP 连接就被释放了</li></ol><h3 id="HTTP的报文格式"><a href="#HTTP的报文格式" class="headerlink" title="HTTP的报文格式"></a><strong>HTTP的报文格式</strong></h3><p><img src="../img/计算机网络/5600.png" alt="Untitled"></p><h3 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a><strong>使用Cookie在服务器上记录用户信息</strong></h3><p>早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态的文档。因此HTTP被设计为一种 <strong><code>无状态</code></strong> 的协议。这样可以简化服务器的设计</p><p>现在，用户可以通过万维网实现各种复杂的应用，如网上购物、电子商务等。这些应用往往需要万维网服务器能够识别用户</p><p>Cookie提供了一种机制使得万维网服务器能够“记住”用户，而无需用户主动提供用户标识信息。也就是<strong>Cookie是一种对无状态的HTTP进行状态化的技术</strong></p><h3 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a><strong>万维网缓存与代理服务器</strong></h3><p>在万维网中还可以使用缓存机制以提高万维网的效率。</p><p>万维网缓存又称为<strong>Web缓存</strong>(WebCache)，可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为<strong>代理服务器</strong>(ProxyServer)。</p><p>Web缓存把最近的一些请求和响应暂存在本地磁盘中。<strong>当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源</strong>。</p><p>若WEb缓存的命中率比较高</p><p>则会大大减小了该链路上的通信量，因而减少了访问因特网的时延</p><p><img src="../img/计算机网络/5601.png" alt="Untitled"></p><p><img src="../img/计算机网络/5602.png" alt="Untitled"></p><hr>]]></content>
    
    
    <summary type="html">计网</summary>
    
    
    
    <category term="期末复习" scheme="https://agoni66.github.io/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="计算机网络" scheme="https://agoni66.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="四大件" scheme="https://agoni66.github.io/tags/%E5%9B%9B%E5%A4%A7%E4%BB%B6/"/>
    
  </entry>
  
</feed>
